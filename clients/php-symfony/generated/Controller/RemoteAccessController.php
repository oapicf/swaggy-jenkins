<?php

/**
 * RemoteAccessController
 * PHP version 8.1.1
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * Swaggy Jenkins
 *
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * The version of the OpenAPI document: 2.0.1-pre.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use JMS\Serializer\Exception\RuntimeException as SerializerRuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\Api\RemoteAccessApiInterface;
use OpenAPI\Server\Model\ComputerSet;
use OpenAPI\Server\Model\FreeStyleBuild;
use OpenAPI\Server\Model\FreeStyleProject;
use OpenAPI\Server\Model\Hudson;
use OpenAPI\Server\Model\ListView;
use OpenAPI\Server\Model\Queue;

/**
 * RemoteAccessController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class RemoteAccessController extends Controller
{

    /**
     * Operation getComputer
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getComputerAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $depth = $request->query->get('depth');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $depth = $this->deserialize($depth, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($depth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getComputer($depth, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved computer details';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getJenkins
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getJenkinsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getJenkins($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved Jenkins details';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getJob
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getJobAction(Request $request, $name)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getJob($name, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved job details';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getJobConfig
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getJobConfigAction(Request $request, $name)
    {
        // Figure out what data format to return to the client
        $produces = ['text/xml'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getJobConfig($name, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved job configuration in config.xml format';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getJobLastBuild
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getJobLastBuildAction(Request $request, $name)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getJobLastBuild($name, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved job&#39;s last build details';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getJobProgressiveText
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getJobProgressiveTextAction(Request $request, $name, $number)
    {
        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $start = $request->query->get('start');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $number = $this->deserialize($number, 'string', 'string');
            $start = $this->deserialize($start, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($number, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($start, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->getJobProgressiveText($name, $number, $start, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved job&#39;s build progressive text output';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getQueue
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getQueueAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getQueue($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved queue details';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getQueueItem
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getQueueItemAction(Request $request, $number)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $number = $this->deserialize($number, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($number, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getQueueItem($number, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved queued item details';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getView
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getViewAction(Request $request, $name)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getView($name, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved view details';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'View cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation getViewConfig
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function getViewConfigAction(Request $request, $name)
    {
        // Figure out what data format to return to the client
        $produces = ['text/xml'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->getViewConfig($name, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved view configuration in config.xml format';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'View cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation headJenkins
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function headJenkinsAction(Request $request)
    {
        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->headJenkins($responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved Jenkins headers';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postCreateItem
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postCreateItemAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $name = $request->query->get('name');
        $from = $request->query->get('from');
        $mode = $request->query->get('mode');
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');
        $contentType = $request->headers->get('Content-Type');
        $body = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $from = $this->deserialize($from, 'string', 'string');
            $mode = $this->deserialize($mode, 'string', 'string');
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
            $contentType = $this->deserialize($contentType, 'string', 'string');
            $inputFormat = $request->getMimeType($request->getContentType());
            $body = $this->deserialize($body, 'string', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($from, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($mode, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($contentType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($body, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postCreateItem($name, $from, $mode, $jenkinsCrumb, $contentType, $body, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully created a new job';
                    break;
                case 400:
                    $message = 'An error has occurred - error message is embedded inside the HTML response';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postCreateView
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postCreateViewAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $name = $request->query->get('name');
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');
        $contentType = $request->headers->get('Content-Type');
        $body = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
            $contentType = $this->deserialize($contentType, 'string', 'string');
            $inputFormat = $request->getMimeType($request->getContentType());
            $body = $this->deserialize($body, 'string', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($contentType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($body, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postCreateView($name, $jenkinsCrumb, $contentType, $body, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully created the view';
                    break;
                case 400:
                    $message = 'An error has occurred - error message is embedded inside the HTML response';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postJobBuild
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postJobBuildAction(Request $request, $name)
    {
        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $json = $request->query->get('json');
        $token = $request->query->get('token');
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $json = $this->deserialize($json, 'string', 'string');
            $token = $this->deserialize($token, 'string', 'string');
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($json, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($token, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postJobBuild($name, $json, $token, $jenkinsCrumb, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully built the job (backward compatibility for older versions of Jenkins)';
                    break;
                case 201:
                    $message = 'Successfully built the job';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postJobConfig
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postJobConfigAction(Request $request, $name)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');
        $body = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $inputFormat = $request->getMimeType($request->getContentType());
            $body = $this->deserialize($body, 'string', $inputFormat);
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($body, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postJobConfig($name, $body, $jenkinsCrumb, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully retrieved job configuration in config.xml format';
                    break;
                case 400:
                    $message = 'An error has occurred - error message is embedded inside the HTML response';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postJobDelete
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postJobDeleteAction(Request $request, $name)
    {
        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postJobDelete($name, $jenkinsCrumb, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully deleted the job';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postJobDisable
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postJobDisableAction(Request $request, $name)
    {
        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postJobDisable($name, $jenkinsCrumb, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully disabled the job';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postJobEnable
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postJobEnableAction(Request $request, $name)
    {
        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postJobEnable($name, $jenkinsCrumb, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully enabled the job';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postJobLastBuildStop
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postJobLastBuildStopAction(Request $request, $name)
    {
        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postJobLastBuildStop($name, $jenkinsCrumb, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully stopped the job';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'Job cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation postViewConfig
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function postViewConfigAction(Request $request, $name)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Handle authentication
        // Authentication 'jenkins_auth' required
        // HTTP basic authentication required
        $securityjenkins_auth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $jenkinsCrumb = $request->headers->get('Jenkins-Crumb');
        $body = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $name = $this->deserialize($name, 'string', 'string');
            $inputFormat = $request->getMimeType($request->getContentType());
            $body = $this->deserialize($body, 'string', $inputFormat);
            $jenkinsCrumb = $this->deserialize($jenkinsCrumb, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($name, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($body, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($jenkinsCrumb, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'jenkins_auth'
            $handler->setjenkins_auth($securityjenkins_auth);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->postViewConfig($name, $body, $jenkinsCrumb, $responseCode, $responseHeaders);

            // Find default response message
            $message = '';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Successfully updated view configuration';
                    break;
                case 400:
                    $message = 'An error has occurred - error message is embedded inside the HTML response';
                    break;
                case 401:
                    $message = 'Authentication failed - incorrect username and/or password';
                    break;
                case 403:
                    $message = 'Jenkins requires authentication - please set username and password';
                    break;
                case 404:
                    $message = 'View cannot be found on Jenkins instance';
                    break;
            }

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return RemoteAccessApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('remoteAccess');
    }
}
