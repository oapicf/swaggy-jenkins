/* tslint:disable */
/* eslint-disable */
/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * The version of the OpenAPI document: 1.5.1-pre.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AllView
 */
export interface AllView {
    /**
     * 
     * @type {string}
     * @memberof AllView
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllView
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface BranchImpl
 */
export interface BranchImpl {
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof BranchImpl
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    'fullDisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    'organization'?: string;
    /**
     * 
     * @type {Array<StringParameterDefinition>}
     * @memberof BranchImpl
     */
    'parameters'?: Array<StringParameterDefinition>;
    /**
     * 
     * @type {BranchImplpermissions}
     * @memberof BranchImpl
     */
    'permissions'?: BranchImplpermissions;
    /**
     * 
     * @type {number}
     * @memberof BranchImpl
     */
    'weatherScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof BranchImpl
     */
    'pullRequest'?: string;
    /**
     * 
     * @type {BranchImpllinks}
     * @memberof BranchImpl
     */
    '_links'?: BranchImpllinks;
    /**
     * 
     * @type {PipelineRunImpl}
     * @memberof BranchImpl
     */
    'latestRun'?: PipelineRunImpl;
}
/**
 * 
 * @export
 * @interface BranchImpllinks
 */
export interface BranchImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    'self'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    'actions'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    'runs'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof BranchImpllinks
     */
    'queue'?: Link;
    /**
     * 
     * @type {string}
     * @memberof BranchImpllinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface BranchImplpermissions
 */
export interface BranchImplpermissions {
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    'create'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    'read'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    'start'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BranchImplpermissions
     */
    'stop'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BranchImplpermissions
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface CauseAction
 */
export interface CauseAction {
    /**
     * 
     * @type {string}
     * @memberof CauseAction
     */
    '_class'?: string;
    /**
     * 
     * @type {Array<CauseUserIdCause>}
     * @memberof CauseAction
     */
    'causes'?: Array<CauseUserIdCause>;
}
/**
 * 
 * @export
 * @interface CauseUserIdCause
 */
export interface CauseUserIdCause {
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    'shortDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CauseUserIdCause
     */
    'userName'?: string;
}
/**
 * 
 * @export
 * @interface ClassesByClass
 */
export interface ClassesByClass {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassesByClass
     */
    'classes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClassesByClass
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface ClockDifference
 */
export interface ClockDifference {
    /**
     * 
     * @type {string}
     * @memberof ClockDifference
     */
    '_class'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClockDifference
     */
    'diff'?: number;
}
/**
 * 
 * @export
 * @interface ComputerSet
 */
export interface ComputerSet {
    /**
     * 
     * @type {string}
     * @memberof ComputerSet
     */
    '_class'?: string;
    /**
     * 
     * @type {number}
     * @memberof ComputerSet
     */
    'busyExecutors'?: number;
    /**
     * 
     * @type {Array<HudsonMasterComputer>}
     * @memberof ComputerSet
     */
    'computer'?: Array<HudsonMasterComputer>;
    /**
     * 
     * @type {string}
     * @memberof ComputerSet
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ComputerSet
     */
    'totalExecutors'?: number;
}
/**
 * 
 * @export
 * @interface DefaultCrumbIssuer
 */
export interface DefaultCrumbIssuer {
    /**
     * 
     * @type {string}
     * @memberof DefaultCrumbIssuer
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultCrumbIssuer
     */
    'crumb'?: string;
    /**
     * 
     * @type {string}
     * @memberof DefaultCrumbIssuer
     */
    'crumbRequestField'?: string;
}
/**
 * 
 * @export
 * @interface DiskSpaceMonitorDescriptorDiskSpace
 */
export interface DiskSpaceMonitorDescriptorDiskSpace {
    /**
     * 
     * @type {string}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    '_class'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiskSpaceMonitorDescriptorDiskSpace
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface EmptyChangeLogSet
 */
export interface EmptyChangeLogSet {
    /**
     * 
     * @type {string}
     * @memberof EmptyChangeLogSet
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmptyChangeLogSet
     */
    'kind'?: string;
}
/**
 * 
 * @export
 * @interface ExtensionClassContainerImpl1
 */
export interface ExtensionClassContainerImpl1 {
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassContainerImpl1
     */
    '_class'?: string;
    /**
     * 
     * @type {ExtensionClassContainerImpl1links}
     * @memberof ExtensionClassContainerImpl1
     */
    '_links'?: ExtensionClassContainerImpl1links;
    /**
     * 
     * @type {ExtensionClassContainerImpl1map}
     * @memberof ExtensionClassContainerImpl1
     */
    'map'?: ExtensionClassContainerImpl1map;
}
/**
 * 
 * @export
 * @interface ExtensionClassContainerImpl1links
 */
export interface ExtensionClassContainerImpl1links {
    /**
     * 
     * @type {Link}
     * @memberof ExtensionClassContainerImpl1links
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassContainerImpl1links
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface ExtensionClassContainerImpl1map
 */
export interface ExtensionClassContainerImpl1map {
    /**
     * 
     * @type {ExtensionClassImpl}
     * @memberof ExtensionClassContainerImpl1map
     */
    'io.jenkins.blueocean.service.embedded.rest.PipelineImpl'?: ExtensionClassImpl;
    /**
     * 
     * @type {ExtensionClassImpl}
     * @memberof ExtensionClassContainerImpl1map
     */
    'io.jenkins.blueocean.service.embedded.rest.MultiBranchPipelineImpl'?: ExtensionClassImpl;
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassContainerImpl1map
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface ExtensionClassImpl
 */
export interface ExtensionClassImpl {
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {ExtensionClassImpllinks}
     * @memberof ExtensionClassImpl
     */
    '_links'?: ExtensionClassImpllinks;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtensionClassImpl
     */
    'classes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ExtensionClassImpllinks
 */
export interface ExtensionClassImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof ExtensionClassImpllinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof ExtensionClassImpllinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface FavoriteImpl
 */
export interface FavoriteImpl {
    /**
     * 
     * @type {string}
     * @memberof FavoriteImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {FavoriteImpllinks}
     * @memberof FavoriteImpl
     */
    '_links'?: FavoriteImpllinks;
    /**
     * 
     * @type {PipelineImpl}
     * @memberof FavoriteImpl
     */
    'item'?: PipelineImpl;
}
/**
 * 
 * @export
 * @interface FavoriteImpllinks
 */
export interface FavoriteImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof FavoriteImpllinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof FavoriteImpllinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface FreeStyleBuild
 */
export interface FreeStyleBuild {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    '_class'?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    'number'?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'url'?: string;
    /**
     * 
     * @type {Array<CauseAction>}
     * @memberof FreeStyleBuild
     */
    'actions'?: Array<CauseAction>;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleBuild
     */
    'building'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    'estimatedDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'executor'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'fullDisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleBuild
     */
    'keepLog'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    'queueId'?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'result'?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleBuild
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleBuild
     */
    'builtOn'?: string;
    /**
     * 
     * @type {EmptyChangeLogSet}
     * @memberof FreeStyleBuild
     */
    'changeSet'?: EmptyChangeLogSet;
}
/**
 * 
 * @export
 * @interface FreeStyleProject
 */
export interface FreeStyleProject {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'color'?: string;
    /**
     * 
     * @type {Array<FreeStyleProjectactions>}
     * @memberof FreeStyleProject
     */
    'actions'?: Array<FreeStyleProjectactions>;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'displayNameOrNull'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'fullDisplayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'fullName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    'buildable'?: boolean;
    /**
     * 
     * @type {Array<FreeStyleBuild>}
     * @memberof FreeStyleProject
     */
    'builds'?: Array<FreeStyleBuild>;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    'firstBuild'?: FreeStyleBuild;
    /**
     * 
     * @type {Array<FreeStyleProjecthealthReport>}
     * @memberof FreeStyleProject
     */
    'healthReport'?: Array<FreeStyleProjecthealthReport>;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    'inQueue'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    'keepDependencies'?: boolean;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    'lastBuild'?: FreeStyleBuild;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    'lastCompletedBuild'?: FreeStyleBuild;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'lastFailedBuild'?: string;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    'lastStableBuild'?: FreeStyleBuild;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof FreeStyleProject
     */
    'lastSuccessfulBuild'?: FreeStyleBuild;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'lastUnstableBuild'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'lastUnsuccessfulBuild'?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleProject
     */
    'nextBuildNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProject
     */
    'queueItem'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FreeStyleProject
     */
    'concurrentBuild'?: boolean;
    /**
     * 
     * @type {NullSCM}
     * @memberof FreeStyleProject
     */
    'scm'?: NullSCM;
}
/**
 * 
 * @export
 * @interface FreeStyleProjectactions
 */
export interface FreeStyleProjectactions {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjectactions
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface FreeStyleProjecthealthReport
 */
export interface FreeStyleProjecthealthReport {
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    'iconClassName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    'iconUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof FreeStyleProjecthealthReport
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof FreeStyleProjecthealthReport
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface GenericResource
 */
export interface GenericResource {
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof GenericResource
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericResource
     */
    'startTime'?: string;
}
/**
 * 
 * @export
 * @interface GithubContent
 */
export interface GithubContent {
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    'sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    'repo'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubContent
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubContent
     */
    'base64Data'?: string;
}
/**
 * 
 * @export
 * @interface GithubFile
 */
export interface GithubFile {
    /**
     * 
     * @type {GithubContent}
     * @memberof GithubFile
     */
    'content'?: GithubContent;
    /**
     * 
     * @type {string}
     * @memberof GithubFile
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface GithubOrganization
 */
export interface GithubOrganization {
    /**
     * 
     * @type {string}
     * @memberof GithubOrganization
     */
    '_class'?: string;
    /**
     * 
     * @type {GithubOrganizationlinks}
     * @memberof GithubOrganization
     */
    '_links'?: GithubOrganizationlinks;
    /**
     * 
     * @type {boolean}
     * @memberof GithubOrganization
     */
    'jenkinsOrganizationPipeline'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubOrganization
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GithubOrganizationlinks
 */
export interface GithubOrganizationlinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubOrganizationlinks
     */
    'repositories'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof GithubOrganizationlinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubOrganizationlinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface GithubRepositories
 */
export interface GithubRepositories {
    /**
     * 
     * @type {string}
     * @memberof GithubRepositories
     */
    '_class'?: string;
    /**
     * 
     * @type {GithubRepositorieslinks}
     * @memberof GithubRepositories
     */
    '_links'?: GithubRepositorieslinks;
    /**
     * 
     * @type {Array<GithubRepository>}
     * @memberof GithubRepositories
     */
    'items'?: Array<GithubRepository>;
    /**
     * 
     * @type {number}
     * @memberof GithubRepositories
     */
    'lastPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubRepositories
     */
    'nextPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubRepositories
     */
    'pageSize'?: number;
}
/**
 * 
 * @export
 * @interface GithubRepositorieslinks
 */
export interface GithubRepositorieslinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubRepositorieslinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubRepositorieslinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface GithubRepository
 */
export interface GithubRepository {
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    '_class'?: string;
    /**
     * 
     * @type {GithubRepositorylinks}
     * @memberof GithubRepository
     */
    '_links'?: GithubRepositorylinks;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    'defaultBranch'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    'name'?: string;
    /**
     * 
     * @type {GithubRepositorypermissions}
     * @memberof GithubRepository
     */
    'permissions'?: GithubRepositorypermissions;
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepository
     */
    'private'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubRepository
     */
    'fullName'?: string;
}
/**
 * 
 * @export
 * @interface GithubRepositorylinks
 */
export interface GithubRepositorylinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubRepositorylinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubRepositorylinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface GithubRepositorypermissions
 */
export interface GithubRepositorypermissions {
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepositorypermissions
     */
    'admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepositorypermissions
     */
    'push'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GithubRepositorypermissions
     */
    'pull'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubRepositorypermissions
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface GithubRespositoryContainer
 */
export interface GithubRespositoryContainer {
    /**
     * 
     * @type {string}
     * @memberof GithubRespositoryContainer
     */
    '_class'?: string;
    /**
     * 
     * @type {GithubRespositoryContainerlinks}
     * @memberof GithubRespositoryContainer
     */
    '_links'?: GithubRespositoryContainerlinks;
    /**
     * 
     * @type {GithubRepositories}
     * @memberof GithubRespositoryContainer
     */
    'repositories'?: GithubRepositories;
}
/**
 * 
 * @export
 * @interface GithubRespositoryContainerlinks
 */
export interface GithubRespositoryContainerlinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubRespositoryContainerlinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubRespositoryContainerlinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface GithubScm
 */
export interface GithubScm {
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    '_class'?: string;
    /**
     * 
     * @type {GithubScmlinks}
     * @memberof GithubScm
     */
    '_links'?: GithubScmlinks;
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    'credentialId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubScm
     */
    'uri'?: string;
}
/**
 * 
 * @export
 * @interface GithubScmlinks
 */
export interface GithubScmlinks {
    /**
     * 
     * @type {Link}
     * @memberof GithubScmlinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof GithubScmlinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface Hudson
 */
export interface Hudson {
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    '_class'?: string;
    /**
     * 
     * @type {Array<HudsonassignedLabels>}
     * @memberof Hudson
     */
    'assignedLabels'?: Array<HudsonassignedLabels>;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    'mode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    'nodeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    'nodeName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Hudson
     */
    'numExecutors'?: number;
    /**
     * 
     * @type {string}
     * @memberof Hudson
     */
    'description'?: string;
    /**
     * 
     * @type {Array<FreeStyleProject>}
     * @memberof Hudson
     */
    'jobs'?: Array<FreeStyleProject>;
    /**
     * 
     * @type {AllView}
     * @memberof Hudson
     */
    'primaryView'?: AllView;
    /**
     * 
     * @type {boolean}
     * @memberof Hudson
     */
    'quietingDown'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Hudson
     */
    'slaveAgentPort'?: number;
    /**
     * 
     * @type {UnlabeledLoadStatistics}
     * @memberof Hudson
     */
    'unlabeledLoad'?: UnlabeledLoadStatistics;
    /**
     * 
     * @type {boolean}
     * @memberof Hudson
     */
    'useCrumbs'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Hudson
     */
    'useSecurity'?: boolean;
    /**
     * 
     * @type {Array<AllView>}
     * @memberof Hudson
     */
    'views'?: Array<AllView>;
}
/**
 * 
 * @export
 * @interface HudsonMasterComputer
 */
export interface HudsonMasterComputer {
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    'displayName'?: string;
    /**
     * 
     * @type {Array<HudsonMasterComputerexecutors>}
     * @memberof HudsonMasterComputer
     */
    'executors'?: Array<HudsonMasterComputerexecutors>;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    'iconClassName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    'idle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    'jnlpAgent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    'launchSupported'?: boolean;
    /**
     * 
     * @type {Label1}
     * @memberof HudsonMasterComputer
     */
    'loadStatistics'?: Label1;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    'manualLaunchAllowed'?: boolean;
    /**
     * 
     * @type {HudsonMasterComputermonitorData}
     * @memberof HudsonMasterComputer
     */
    'monitorData'?: HudsonMasterComputermonitorData;
    /**
     * 
     * @type {number}
     * @memberof HudsonMasterComputer
     */
    'numExecutors'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    'offline'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    'offlineCause'?: string;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputer
     */
    'offlineCauseReason'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputer
     */
    'temporarilyOffline'?: boolean;
}
/**
 * 
 * @export
 * @interface HudsonMasterComputerexecutors
 */
export interface HudsonMasterComputerexecutors {
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof HudsonMasterComputerexecutors
     */
    'currentExecutable'?: FreeStyleBuild;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputerexecutors
     */
    'idle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HudsonMasterComputerexecutors
     */
    'likelyStuck'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HudsonMasterComputerexecutors
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof HudsonMasterComputerexecutors
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputerexecutors
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface HudsonMasterComputermonitorData
 */
export interface HudsonMasterComputermonitorData {
    /**
     * 
     * @type {SwapSpaceMonitorMemoryUsage2}
     * @memberof HudsonMasterComputermonitorData
     */
    'hudson.node_monitors.SwapSpaceMonitor'?: SwapSpaceMonitorMemoryUsage2;
    /**
     * 
     * @type {DiskSpaceMonitorDescriptorDiskSpace}
     * @memberof HudsonMasterComputermonitorData
     */
    'hudson.node_monitors.TemporarySpaceMonitor'?: DiskSpaceMonitorDescriptorDiskSpace;
    /**
     * 
     * @type {DiskSpaceMonitorDescriptorDiskSpace}
     * @memberof HudsonMasterComputermonitorData
     */
    'hudson.node_monitors.DiskSpaceMonitor'?: DiskSpaceMonitorDescriptorDiskSpace;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputermonitorData
     */
    'hudson.node_monitors.ArchitectureMonitor'?: string;
    /**
     * 
     * @type {ResponseTimeMonitorData}
     * @memberof HudsonMasterComputermonitorData
     */
    'hudson.node_monitors.ResponseTimeMonitor'?: ResponseTimeMonitorData;
    /**
     * 
     * @type {ClockDifference}
     * @memberof HudsonMasterComputermonitorData
     */
    'hudson.node_monitors.ClockMonitor'?: ClockDifference;
    /**
     * 
     * @type {string}
     * @memberof HudsonMasterComputermonitorData
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface HudsonassignedLabels
 */
export interface HudsonassignedLabels {
    /**
     * 
     * @type {string}
     * @memberof HudsonassignedLabels
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface InputStepImpl
 */
export interface InputStepImpl {
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {InputStepImpllinks}
     * @memberof InputStepImpl
     */
    '_links'?: InputStepImpllinks;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    'ok'?: string;
    /**
     * 
     * @type {Array<StringParameterDefinition>}
     * @memberof InputStepImpl
     */
    'parameters'?: Array<StringParameterDefinition>;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpl
     */
    'submitter'?: string;
}
/**
 * 
 * @export
 * @interface InputStepImpllinks
 */
export interface InputStepImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof InputStepImpllinks
     */
    'self'?: Link;
    /**
     * 
     * @type {string}
     * @memberof InputStepImpllinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface Label1
 */
export interface Label1 {
    /**
     * 
     * @type {string}
     * @memberof Label1
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
}
/**
 * 
 * @export
 * @interface ListView
 */
export interface ListView {
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    'description'?: string;
    /**
     * 
     * @type {Array<FreeStyleProject>}
     * @memberof ListView
     */
    'jobs'?: Array<FreeStyleProject>;
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListView
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface MultibranchPipeline
 */
export interface MultibranchPipeline {
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    'latestRun'?: string;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    'organization'?: string;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'weatherScore'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MultibranchPipeline
     */
    'branchNames'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'numberOfFailingBranches'?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'numberOfFailingPullRequests'?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'numberOfSuccessfulBranches'?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'numberOfSuccessfulPullRequests'?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'totalNumberOfBranches'?: number;
    /**
     * 
     * @type {number}
     * @memberof MultibranchPipeline
     */
    'totalNumberOfPullRequests'?: number;
    /**
     * 
     * @type {string}
     * @memberof MultibranchPipeline
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface NullSCM
 */
export interface NullSCM {
    /**
     * 
     * @type {string}
     * @memberof NullSCM
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    'weatherScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pipeline
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {PipelinelatestRun}
     * @memberof Pipeline
     */
    'latestRun'?: PipelinelatestRun;
}
/**
 * 
 * @export
 * @interface PipelineActivity
 */
export interface PipelineActivity {
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    '_class'?: string;
    /**
     * 
     * @type {Array<PipelineActivityartifacts>}
     * @memberof PipelineActivity
     */
    'artifacts'?: Array<PipelineActivityartifacts>;
    /**
     * 
     * @type {number}
     * @memberof PipelineActivity
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineActivity
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'enQueueTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'pipeline'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'runSummary'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivity
     */
    'commitId'?: string;
}
/**
 * 
 * @export
 * @interface PipelineActivityartifacts
 */
export interface PipelineActivityartifacts {
    /**
     * 
     * @type {string}
     * @memberof PipelineActivityartifacts
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineActivityartifacts
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivityartifacts
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineActivityartifacts
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineBranchesitem
 */
export interface PipelineBranchesitem {
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitem
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitem
     */
    'weatherScore'?: number;
    /**
     * 
     * @type {PipelineBranchesitemlatestRun}
     * @memberof PipelineBranchesitem
     */
    'latestRun'?: PipelineBranchesitemlatestRun;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    'organization'?: string;
    /**
     * 
     * @type {PipelineBranchesitempullRequest}
     * @memberof PipelineBranchesitem
     */
    'pullRequest'?: PipelineBranchesitempullRequest;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitem
     */
    'totalNumberOfPullRequests'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitem
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineBranchesitemlatestRun
 */
export interface PipelineBranchesitemlatestRun {
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitemlatestRun
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineBranchesitemlatestRun
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'enQueueTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'pipeline'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'runSummary'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    'commitId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitemlatestRun
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineBranchesitempullRequest
 */
export interface PipelineBranchesitempullRequest {
    /**
     * 
     * @type {PipelineBranchesitempullRequestlinks}
     * @memberof PipelineBranchesitempullRequest
     */
    '_links'?: PipelineBranchesitempullRequestlinks;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequest
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineBranchesitempullRequestlinks
 */
export interface PipelineBranchesitempullRequestlinks {
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequestlinks
     */
    'self'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBranchesitempullRequestlinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineFolderImpl
 */
export interface PipelineFolderImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineFolderImpl
     */
    'organization'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineFolderImpl
     */
    'numberOfFolders'?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineFolderImpl
     */
    'numberOfPipelines'?: number;
}
/**
 * 
 * @export
 * @interface PipelineImpl
 */
export interface PipelineImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineImpl
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    'latestRun'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpl
     */
    'organization'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineImpl
     */
    'weatherScore'?: number;
    /**
     * 
     * @type {PipelineImpllinks}
     * @memberof PipelineImpl
     */
    '_links'?: PipelineImpllinks;
}
/**
 * 
 * @export
 * @interface PipelineImpllinks
 */
export interface PipelineImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    'runs'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    'self'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    'queue'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineImpllinks
     */
    'actions'?: Link;
    /**
     * 
     * @type {string}
     * @memberof PipelineImpllinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineRun
 */
export interface PipelineRun {
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    '_class'?: string;
    /**
     * 
     * @type {Array<PipelineRunartifacts>}
     * @memberof PipelineRun
     */
    'artifacts'?: Array<PipelineRunartifacts>;
    /**
     * 
     * @type {number}
     * @memberof PipelineRun
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelineRun
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'enQueueTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'pipeline'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'runSummary'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRun
     */
    'commitId'?: string;
}
/**
 * 
 * @export
 * @interface PipelineRunImpl
 */
export interface PipelineRunImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {PipelineRunImpllinks}
     * @memberof PipelineRunImpl
     */
    '_links'?: PipelineRunImpllinks;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunImpl
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'enQueueTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunImpl
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'pipeline'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'runSummary'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpl
     */
    'commitId'?: string;
}
/**
 * 
 * @export
 * @interface PipelineRunImpllinks
 */
export interface PipelineRunImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    'nodes'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    'log'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    'self'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    'actions'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineRunImpllinks
     */
    'steps'?: Link;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunImpllinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineRunNode
 */
export interface PipelineRunNode {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunNode
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {Array<PipelineRunNodeedges>}
     * @memberof PipelineRunNode
     */
    'edges'?: Array<PipelineRunNodeedges>;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNode
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface PipelineRunNodeedges
 */
export interface PipelineRunNodeedges {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNodeedges
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunNodeedges
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineRunartifacts
 */
export interface PipelineRunartifacts {
    /**
     * 
     * @type {string}
     * @memberof PipelineRunartifacts
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineRunartifacts
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunartifacts
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineRunartifacts
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelineStepImpl
 */
export interface PipelineStepImpl {
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {PipelineStepImpllinks}
     * @memberof PipelineStepImpl
     */
    '_links'?: PipelineStepImpllinks;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    'displayName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelineStepImpl
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    'id'?: string;
    /**
     * 
     * @type {InputStepImpl}
     * @memberof PipelineStepImpl
     */
    'input'?: InputStepImpl;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpl
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface PipelineStepImpllinks
 */
export interface PipelineStepImpllinks {
    /**
     * 
     * @type {Link}
     * @memberof PipelineStepImpllinks
     */
    'self'?: Link;
    /**
     * 
     * @type {Link}
     * @memberof PipelineStepImpllinks
     */
    'actions'?: Link;
    /**
     * 
     * @type {string}
     * @memberof PipelineStepImpllinks
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelinelatestRun
 */
export interface PipelinelatestRun {
    /**
     * 
     * @type {Array<PipelinelatestRunartifacts>}
     * @memberof PipelinelatestRun
     */
    'artifacts'?: Array<PipelinelatestRunartifacts>;
    /**
     * 
     * @type {number}
     * @memberof PipelinelatestRun
     */
    'durationInMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof PipelinelatestRun
     */
    'estimatedDurationInMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'enQueueTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'pipeline'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'result'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'runSummary'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    'commitId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRun
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface PipelinelatestRunartifacts
 */
export interface PipelinelatestRunartifacts {
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRunartifacts
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PipelinelatestRunartifacts
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRunartifacts
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelinelatestRunartifacts
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface Queue
 */
export interface Queue {
    /**
     * 
     * @type {string}
     * @memberof Queue
     */
    '_class'?: string;
    /**
     * 
     * @type {Array<QueueBlockedItem>}
     * @memberof Queue
     */
    'items'?: Array<QueueBlockedItem>;
}
/**
 * 
 * @export
 * @interface QueueBlockedItem
 */
export interface QueueBlockedItem {
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    '_class'?: string;
    /**
     * 
     * @type {Array<CauseAction>}
     * @memberof QueueBlockedItem
     */
    'actions'?: Array<CauseAction>;
    /**
     * 
     * @type {boolean}
     * @memberof QueueBlockedItem
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueBlockedItem
     */
    'buildable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QueueBlockedItem
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueueBlockedItem
     */
    'inQueueSince'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    'params'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueueBlockedItem
     */
    'stuck'?: boolean;
    /**
     * 
     * @type {FreeStyleProject}
     * @memberof QueueBlockedItem
     */
    'task'?: FreeStyleProject;
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueBlockedItem
     */
    'why'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueBlockedItem
     */
    'buildableStartMilliseconds'?: number;
}
/**
 * 
 * @export
 * @interface QueueItemImpl
 */
export interface QueueItemImpl {
    /**
     * 
     * @type {string}
     * @memberof QueueItemImpl
     */
    '_class'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueItemImpl
     */
    'expectedBuildNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueueItemImpl
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueItemImpl
     */
    'pipeline'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueueItemImpl
     */
    'queuedTime'?: number;
}
/**
 * 
 * @export
 * @interface QueueLeftItem
 */
export interface QueueLeftItem {
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    '_class'?: string;
    /**
     * 
     * @type {Array<CauseAction>}
     * @memberof QueueLeftItem
     */
    'actions'?: Array<CauseAction>;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    'blocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    'buildable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QueueLeftItem
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueueLeftItem
     */
    'inQueueSince'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    'params'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    'stuck'?: boolean;
    /**
     * 
     * @type {FreeStyleProject}
     * @memberof QueueLeftItem
     */
    'task'?: FreeStyleProject;
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueLeftItem
     */
    'why'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QueueLeftItem
     */
    'cancelled'?: boolean;
    /**
     * 
     * @type {FreeStyleBuild}
     * @memberof QueueLeftItem
     */
    'executable'?: FreeStyleBuild;
}
/**
 * 
 * @export
 * @interface ResponseTimeMonitorData
 */
export interface ResponseTimeMonitorData {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeMonitorData
     */
    '_class'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeMonitorData
     */
    'timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeMonitorData
     */
    'average'?: number;
}
/**
 * 
 * @export
 * @interface StringParameterDefinition
 */
export interface StringParameterDefinition {
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    '_class'?: string;
    /**
     * 
     * @type {StringParameterValue}
     * @memberof StringParameterDefinition
     */
    'defaultParameterValue'?: StringParameterValue;
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterDefinition
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface StringParameterValue
 */
export interface StringParameterValue {
    /**
     * 
     * @type {string}
     * @memberof StringParameterValue
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterValue
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StringParameterValue
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface SwapSpaceMonitorMemoryUsage2
 */
export interface SwapSpaceMonitorMemoryUsage2 {
    /**
     * 
     * @type {string}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    '_class'?: string;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    'availablePhysicalMemory'?: number;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    'availableSwapSpace'?: number;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    'totalPhysicalMemory'?: number;
    /**
     * 
     * @type {number}
     * @memberof SwapSpaceMonitorMemoryUsage2
     */
    'totalSwapSpace'?: number;
}
/**
 * 
 * @export
 * @interface UnlabeledLoadStatistics
 */
export interface UnlabeledLoadStatistics {
    /**
     * 
     * @type {string}
     * @memberof UnlabeledLoadStatistics
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    '_class'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
}

/**
 * BaseApi - axios parameter creator
 * @export
 */
export const BaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crumbIssuer/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BaseApi - functional programming interface
 * @export
 */
export const BaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrumb(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultCrumbIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrumb(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BaseApi - factory interface
 * @export
 */
export const BaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BaseApiFp(configuration)
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options?: any): AxiosPromise<DefaultCrumbIssuer> {
            return localVarFp.getCrumb(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BaseApi - object-oriented interface
 * @export
 * @class BaseApi
 * @extends {BaseAPI}
 */
export class BaseApi extends BaseAPI {
    /**
     * Retrieve CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BaseApi
     */
    public getCrumb(options?: AxiosRequestConfig) {
        return BaseApiFp(this.configuration).getCrumb(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlueOceanApi - axios parameter creator
 * @export
 */
export const BlueOceanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineQueueItem: async (organization: string, pipeline: string, queue: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('deletePipelineQueueItem', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('deletePipelineQueueItem', 'pipeline', pipeline)
            // verify required parameter 'queue' is not null or undefined
            assertParamExists('deletePipelineQueueItem', 'queue', queue)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser: async (organization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getAuthenticatedUser', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}/user/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClasses: async (_class: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getClasses', '_class', _class)
            const localVarPath = `/blue/rest/classes/{class}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey: async (key: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getJsonWebKey', 'key', key)
            const localVarPath = `/jwt-auth/jwks/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebToken: async (expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jwt-auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expiryTimeInMins !== undefined) {
                localVarQueryParameter['expiryTimeInMins'] = expiryTimeInMins;
            }

            if (maxExpiryTimeInMins !== undefined) {
                localVarQueryParameter['maxExpiryTimeInMins'] = maxExpiryTimeInMins;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation: async (organization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getOrganisation', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blue/rest/organizations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: async (organization: string, pipeline: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipeline', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipeline', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineActivities: async (organization: string, pipeline: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineActivities', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineActivities', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranch: async (organization: string, pipeline: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineBranch', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineBranch', 'pipeline', pipeline)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getPipelineBranch', 'branch', branch)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranchRun: async (organization: string, pipeline: string, branch: string, run: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'pipeline', pipeline)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'branch', branch)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranches: async (organization: string, pipeline: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineBranches', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineBranches', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolder: async (organization: string, folder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineFolder', 'organization', organization)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getPipelineFolder', 'folder', folder)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{folder}/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolderPipeline: async (organization: string, pipeline: string, folder: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineFolderPipeline', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineFolderPipeline', 'pipeline', pipeline)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getPipelineFolderPipeline', 'folder', folder)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineQueue: async (organization: string, pipeline: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineQueue', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineQueue', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun: async (organization: string, pipeline: string, run: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRun', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunLog: async (organization: string, pipeline: string, run: string, start?: number, download?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunLog', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunLog', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunLog', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNode: async (organization: string, pipeline: string, run: string, node: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNode', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNode', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNode', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNode', 'node', node)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStep: async (organization: string, pipeline: string, run: string, node: string, step: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'node', node)
            // verify required parameter 'step' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'step', step)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStepLog: async (organization: string, pipeline: string, run: string, node: string, step: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'node', node)
            // verify required parameter 'step' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'step', step)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeSteps: async (organization: string, pipeline: string, run: string, node: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'node', node)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodes: async (organization: string, pipeline: string, run: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodes', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodes', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodes', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRuns: async (organization: string, pipeline: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRuns', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRuns', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines: async (organization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelines', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCM: async (organization: string, scm: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCM', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCM', 'scm', scm)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepositories: async (organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCMOrganisationRepositories', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCMOrganisationRepositories', 'scm', scm)
            // verify required parameter 'scmOrganisation' is not null or undefined
            assertParamExists('getSCMOrganisationRepositories', 'scmOrganisation', scmOrganisation)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)))
                .replace(`{${"scmOrganisation"}}`, encodeURIComponent(String(scmOrganisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepository: async (organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'scm', scm)
            // verify required parameter 'scmOrganisation' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'scmOrganisation', scmOrganisation)
            // verify required parameter 'repository' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'repository', repository)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)))
                .replace(`{${"scmOrganisation"}}`, encodeURIComponent(String(scmOrganisation)))
                .replace(`{${"repository"}}`, encodeURIComponent(String(repository)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisations: async (organization: string, scm: string, credentialId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCMOrganisations', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCMOrganisations', 'scm', scm)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (organization: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getUser', 'organization', organization)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUser', 'user', user)
            const localVarPath = `/blue/rest/organizations/{organization}/users/{user}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites: async (user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserFavorites', 'user', user)
            const localVarPath = `/blue/rest/users/{user}/favorites`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (organization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getUsers', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}/users/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRun: async (organization: string, pipeline: string, run: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('postPipelineRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('postPipelineRun', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('postPipelineRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRuns: async (organization: string, pipeline: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('postPipelineRuns', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('postPipelineRuns', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineFavorite: async (organization: string, pipeline: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('putPipelineFavorite', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('putPipelineFavorite', 'pipeline', pipeline)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putPipelineFavorite', 'body', body)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineRun: async (organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('putPipelineRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('putPipelineRun', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('putPipelineRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (blocking !== undefined) {
                localVarQueryParameter['blocking'] = blocking;
            }

            if (timeOutInSecs !== undefined) {
                localVarQueryParameter['timeOutInSecs'] = timeOutInSecs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('search', 'q', q)
            const localVarPath = `/blue/rest/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClasses: async (q: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchClasses', 'q', q)
            const localVarPath = `/blue/rest/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlueOceanApi - functional programming interface
 * @export
 */
export const BlueOceanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlueOceanApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineQueueItem(organization, pipeline, queue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticatedUser(organization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatedUser(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClasses(_class: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClasses(_class, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonWebKey(key: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonWebKey(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganisation(organization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganisation(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganisations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organisation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganisations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipeline(organization: string, pipeline: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipeline(organization, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineActivities(organization: string, pipeline: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineActivities(organization, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineBranch(organization: string, pipeline: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineBranch(organization, pipeline, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineBranchRun(organization, pipeline, branch, run, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineBranches(organization: string, pipeline: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultibranchPipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineBranches(organization, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineFolder(organization: string, folder: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineFolderImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineFolder(organization, folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineFolderPipeline(organization, pipeline, folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineQueue(organization: string, pipeline: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QueueItemImpl>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineQueue(organization, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRun(organization: string, pipeline: string, run: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRun(organization, pipeline, run, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunLog(organization, pipeline, run, start, download, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRunNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNode(organization, pipeline, run, node, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineStepImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodeStep(organization, pipeline, run, node, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineStepImpl>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodeSteps(organization, pipeline, run, node, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRunNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodes(organization, pipeline, run, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRuns(organization: string, pipeline: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRuns(organization, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelines(organization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pipeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelines(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCM(organization: string, scm: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubScm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCM(organization, scm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GithubOrganization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GithubOrganization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GithubOrganization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCMOrganisations(organization, scm, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(organization: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(organization, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFavorites(user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FavoriteImpl>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFavorites(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(organization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPipelineRun(organization: string, pipeline: string, run: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueItemImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPipelineRun(organization, pipeline, run, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPipelineRuns(organization: string, pipeline: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueItemImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPipelineRuns(organization, pipeline, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPipelineFavorite(organization: string, pipeline: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPipelineFavorite(organization, pipeline, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchClasses(q: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchClasses(q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlueOceanApi - factory interface
 * @export
 */
export const BlueOceanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlueOceanApiFp(configuration)
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePipelineQueueItem(organization, pipeline, queue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser(organization: string, options?: any): AxiosPromise<User> {
            return localVarFp.getAuthenticatedUser(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClasses(_class: string, options?: any): AxiosPromise<string> {
            return localVarFp.getClasses(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(key: number, options?: any): AxiosPromise<string> {
            return localVarFp.getJsonWebKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: any): AxiosPromise<string> {
            return localVarFp.getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organization: string, options?: any): AxiosPromise<Organisation> {
            return localVarFp.getOrganisation(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations(options?: any): AxiosPromise<Array<Organisation>> {
            return localVarFp.getOrganisations(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(organization: string, pipeline: string, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.getPipeline(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineActivities(organization: string, pipeline: string, options?: any): AxiosPromise<Array<PipelineActivity>> {
            return localVarFp.getPipelineActivities(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranch(organization: string, pipeline: string, branch: string, options?: any): AxiosPromise<BranchImpl> {
            return localVarFp.getPipelineBranch(organization, pipeline, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: any): AxiosPromise<PipelineRun> {
            return localVarFp.getPipelineBranchRun(organization, pipeline, branch, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranches(organization: string, pipeline: string, options?: any): AxiosPromise<MultibranchPipeline> {
            return localVarFp.getPipelineBranches(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolder(organization: string, folder: string, options?: any): AxiosPromise<PipelineFolderImpl> {
            return localVarFp.getPipelineFolder(organization, folder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: any): AxiosPromise<PipelineImpl> {
            return localVarFp.getPipelineFolderPipeline(organization, pipeline, folder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineQueue(organization: string, pipeline: string, options?: any): AxiosPromise<Array<QueueItemImpl>> {
            return localVarFp.getPipelineQueue(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun(organization: string, pipeline: string, run: string, options?: any): AxiosPromise<PipelineRun> {
            return localVarFp.getPipelineRun(organization, pipeline, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.getPipelineRunLog(organization, pipeline, run, start, download, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: any): AxiosPromise<PipelineRunNode> {
            return localVarFp.getPipelineRunNode(organization, pipeline, run, node, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: any): AxiosPromise<PipelineStepImpl> {
            return localVarFp.getPipelineRunNodeStep(organization, pipeline, run, node, step, options).then((request) => request(axios, basePath));
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: any): AxiosPromise<Array<PipelineStepImpl>> {
            return localVarFp.getPipelineRunNodeSteps(organization, pipeline, run, node, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: any): AxiosPromise<Array<PipelineRunNode>> {
            return localVarFp.getPipelineRunNodes(organization, pipeline, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRuns(organization: string, pipeline: string, options?: any): AxiosPromise<Array<PipelineRun>> {
            return localVarFp.getPipelineRuns(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(organization: string, options?: any): AxiosPromise<Array<Pipeline>> {
            return localVarFp.getPipelines(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCM(organization: string, scm: string, options?: any): AxiosPromise<GithubScm> {
            return localVarFp.getSCM(organization, scm, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: any): AxiosPromise<Array<GithubOrganization>> {
            return localVarFp.getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: any): AxiosPromise<Array<GithubOrganization>> {
            return localVarFp.getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: any): AxiosPromise<Array<GithubOrganization>> {
            return localVarFp.getSCMOrganisations(organization, scm, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(organization: string, user: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites(user: string, options?: any): AxiosPromise<Array<FavoriteImpl>> {
            return localVarFp.getUserFavorites(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(organization: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUsers(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRun(organization: string, pipeline: string, run: string, options?: any): AxiosPromise<QueueItemImpl> {
            return localVarFp.postPipelineRun(organization, pipeline, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRuns(organization: string, pipeline: string, options?: any): AxiosPromise<QueueItemImpl> {
            return localVarFp.postPipelineRuns(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineFavorite(organization: string, pipeline: string, body: boolean, options?: any): AxiosPromise<FavoriteImpl> {
            return localVarFp.putPipelineFavorite(organization, pipeline, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: any): AxiosPromise<PipelineRun> {
            return localVarFp.putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, options?: any): AxiosPromise<string> {
            return localVarFp.search(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClasses(q: string, options?: any): AxiosPromise<string> {
            return localVarFp.searchClasses(q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlueOceanApi - object-oriented interface
 * @export
 * @class BlueOceanApi
 * @extends {BaseAPI}
 */
export class BlueOceanApi extends BaseAPI {
    /**
     * Delete queue item from an organization pipeline queue
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} queue Name of the queue item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).deletePipelineQueueItem(organization, pipeline, queue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve authenticated user details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getAuthenticatedUser(organization: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getAuthenticatedUser(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of class names supported by a given class
     * @param {string} _class Name of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getClasses(_class: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getClasses(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve JSON Web Key
     * @param {number} key Key ID received as part of JWT header field kid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getJsonWebKey(key: number, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getJsonWebKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve JSON Web Token
     * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
     * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve organization details
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getOrganisation(organization: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getOrganisation(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all organizations details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getOrganisations(options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getOrganisations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve pipeline details for an organization
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipeline(organization: string, pipeline: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipeline(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all activities details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineActivities(organization: string, pipeline: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineActivities(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve branch details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} branch Name of the branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineBranch(organization: string, pipeline: string, branch: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineBranch(organization, pipeline, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve branch run details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} branch Name of the branch
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineBranchRun(organization, pipeline, branch, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all branches details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineBranches(organization: string, pipeline: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineBranches(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve pipeline folder for an organization
     * @param {string} organization Name of the organization
     * @param {string} folder Name of the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineFolder(organization: string, folder: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineFolder(organization, folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve pipeline details for an organization folder
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} folder Name of the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineFolderPipeline(organization, pipeline, folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve queue details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineQueue(organization: string, pipeline: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineQueue(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRun(organization: string, pipeline: string, run: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRun(organization, pipeline, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get log for a pipeline run
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {number} [start] Start position of the log
     * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunLog(organization, pipeline, run, start, download, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run node details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNode(organization, pipeline, run, node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run node details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {string} step Name of the step
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeStep(organization, pipeline, run, node, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get log for a pipeline run node step
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {string} step Name of the step
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run node steps details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeSteps(organization, pipeline, run, node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run nodes details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodes(organization, pipeline, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all runs details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelineRuns(organization: string, pipeline: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRuns(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all pipelines details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getPipelines(organization: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelines(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCM(organization: string, scm: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCM(organization, scm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM organization repositories details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} scmOrganisation Name of the SCM organization
     * @param {string} [credentialId] Credential ID
     * @param {number} [pageSize] Number of items in a page
     * @param {number} [pageNumber] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM organization repository details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} scmOrganisation Name of the SCM organization
     * @param {string} repository Name of the SCM repository
     * @param {string} [credentialId] Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM organizations details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} [credentialId] Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisations(organization, scm, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user details for an organization
     * @param {string} organization Name of the organization
     * @param {string} user Name of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getUser(organization: string, user: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getUser(organization, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user favorites details for an organization
     * @param {string} user Name of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getUserFavorites(user: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getUserFavorites(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public getUsers(organization: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getUsers(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replay an organization pipeline run
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public postPipelineRun(organization: string, pipeline: string, run: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).postPipelineRun(organization, pipeline, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a build for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public postPipelineRuns(organization: string, pipeline: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).postPipelineRuns(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Favorite/unfavorite a pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public putPipelineFavorite(organization: string, pipeline: string, body: boolean, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).putPipelineFavorite(organization, pipeline, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a build of an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} [blocking] Set to true to make blocking stop, default: false
     * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for any resource details
     * @param {string} q Query string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public search(q: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).search(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get classes details
     * @param {string} q Query string containing an array of class names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlueOceanApi
     */
    public searchClasses(q: string, options?: AxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).searchClasses(q, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RemoteAccessApi - axios parameter creator
 * @export
 */
export const RemoteAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComputer: async (depth: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'depth' is not null or undefined
            assertParamExists('getComputer', 'depth', depth)
            const localVarPath = `/computer/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJenkins: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJob', 'name', name)
            const localVarPath = `/job/{name}/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobConfig: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJobConfig', 'name', name)
            const localVarPath = `/job/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job\'s last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLastBuild: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJobLastBuild', 'name', name)
            const localVarPath = `/job/{name}/lastBuild/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job\'s build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProgressiveText: async (name: string, number: string, start: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJobProgressiveText', 'name', name)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getJobProgressiveText', 'number', number)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getJobProgressiveText', 'start', start)
            const localVarPath = `/job/{name}/{number}/logText/progressiveText`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/queue/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueItem: async (number: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getQueueItem', 'number', number)
            const localVarPath = `/queue/item/{number}/api/json`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getView', 'name', name)
            const localVarPath = `/view/{name}/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConfig: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getViewConfig', 'name', name)
            const localVarPath = `/view/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headJenkins: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateItem: async (name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postCreateItem', 'name', name)
            const localVarPath = `/createItem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateView: async (name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postCreateView', 'name', name)
            const localVarPath = `/createView`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobBuild: async (name: string, json: string, token?: string, jenkinsCrumb?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobBuild', 'name', name)
            // verify required parameter 'json' is not null or undefined
            assertParamExists('postJobBuild', 'json', json)
            const localVarPath = `/job/{name}/build`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (json !== undefined) {
                localVarQueryParameter['json'] = json;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobConfig: async (name: string, body: string, jenkinsCrumb?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobConfig', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postJobConfig', 'body', body)
            const localVarPath = `/job/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDelete: async (name: string, jenkinsCrumb?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobDelete', 'name', name)
            const localVarPath = `/job/{name}/doDelete`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDisable: async (name: string, jenkinsCrumb?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobDisable', 'name', name)
            const localVarPath = `/job/{name}/disable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEnable: async (name: string, jenkinsCrumb?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobEnable', 'name', name)
            const localVarPath = `/job/{name}/enable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobLastBuildStop: async (name: string, jenkinsCrumb?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobLastBuildStop', 'name', name)
            const localVarPath = `/job/{name}/lastBuild/stop`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postViewConfig: async (name: string, body: string, jenkinsCrumb?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postViewConfig', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postViewConfig', 'body', body)
            const localVarPath = `/view/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (jenkinsCrumb !== undefined && jenkinsCrumb !== null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteAccessApi - functional programming interface
 * @export
 */
export const RemoteAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemoteAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComputer(depth: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComputerSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComputer(depth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJenkins(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hudson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJenkins(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreeStyleProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobConfig(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobConfig(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve job\'s last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobLastBuild(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreeStyleBuild>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLastBuild(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve job\'s build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobProgressiveText(name: string, number: string, start: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobProgressiveText(name, number, start, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueue(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Queue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueue(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueItem(number: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Queue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueItem(number, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getView(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getView(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewConfig(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewConfig(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headJenkins(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.headJenkins(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCreateView(name, jenkinsCrumb, contentType, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobBuild(name, json, token, jenkinsCrumb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobConfig(name, body, jenkinsCrumb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobDelete(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobDelete(name, jenkinsCrumb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobDisable(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobDisable(name, jenkinsCrumb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobEnable(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobEnable(name, jenkinsCrumb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobLastBuildStop(name, jenkinsCrumb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postViewConfig(name, body, jenkinsCrumb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RemoteAccessApi - factory interface
 * @export
 */
export const RemoteAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemoteAccessApiFp(configuration)
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComputer(depth: number, options?: any): AxiosPromise<ComputerSet> {
            return localVarFp.getComputer(depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJenkins(options?: any): AxiosPromise<Hudson> {
            return localVarFp.getJenkins(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(name: string, options?: any): AxiosPromise<FreeStyleProject> {
            return localVarFp.getJob(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobConfig(name: string, options?: any): AxiosPromise<string> {
            return localVarFp.getJobConfig(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job\'s last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLastBuild(name: string, options?: any): AxiosPromise<FreeStyleBuild> {
            return localVarFp.getJobLastBuild(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job\'s build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProgressiveText(name: string, number: string, start: string, options?: any): AxiosPromise<void> {
            return localVarFp.getJobProgressiveText(name, number, start, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(options?: any): AxiosPromise<Queue> {
            return localVarFp.getQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueItem(number: string, options?: any): AxiosPromise<Queue> {
            return localVarFp.getQueueItem(number, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(name: string, options?: any): AxiosPromise<ListView> {
            return localVarFp.getView(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConfig(name: string, options?: any): AxiosPromise<string> {
            return localVarFp.getViewConfig(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headJenkins(options?: any): AxiosPromise<void> {
            return localVarFp.headJenkins(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postCreateView(name, jenkinsCrumb, contentType, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postJobBuild(name, json, token, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postJobConfig(name, body, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDelete(name: string, jenkinsCrumb?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postJobDelete(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDisable(name: string, jenkinsCrumb?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postJobDisable(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEnable(name: string, jenkinsCrumb?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postJobEnable(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postJobLastBuildStop(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: any): AxiosPromise<void> {
            return localVarFp.postViewConfig(name, body, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemoteAccessApi - object-oriented interface
 * @export
 * @class RemoteAccessApi
 * @extends {BaseAPI}
 */
export class RemoteAccessApi extends BaseAPI {
    /**
     * Retrieve computer details
     * @param {number} depth Recursion depth in response model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getComputer(depth: number, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getComputer(depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Jenkins details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJenkins(options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJenkins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job details
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJob(name: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJob(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job configuration
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJobConfig(name: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJobConfig(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job\'s last build details
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJobLastBuild(name: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJobLastBuild(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job\'s build progressive text output
     * @param {string} name Name of the job
     * @param {string} number Build number
     * @param {string} start Starting point of progressive text output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getJobProgressiveText(name: string, number: string, start: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJobProgressiveText(name, number, start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve queue details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getQueue(options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve queued item details
     * @param {string} number Queue number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getQueueItem(number: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getQueueItem(number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve view details
     * @param {string} name Name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getView(name: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getView(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve view configuration
     * @param {string} name Name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public getViewConfig(name: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getViewConfig(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Jenkins headers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public headJenkins(options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).headJenkins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new job using job configuration, or copied from an existing job
     * @param {string} name Name of the new job
     * @param {string} [from] Existing job to copy from
     * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {string} [contentType] Content type header application/xml
     * @param {string} [body] Job configuration in config.xml format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new view using view configuration
     * @param {string} name Name of the new view
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {string} [contentType] Content type header application/xml
     * @param {string} [body] View configuration in config.xml format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postCreateView(name, jenkinsCrumb, contentType, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Build a job
     * @param {string} name Name of the job
     * @param {string} json 
     * @param {string} [token] 
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobBuild(name, json, token, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update job configuration
     * @param {string} name Name of the job
     * @param {string} body Job configuration in config.xml format
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobConfig(name, body, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobDelete(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobDelete(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobDisable(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobDisable(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobEnable(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobEnable(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobLastBuildStop(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update view configuration
     * @param {string} name Name of the view
     * @param {string} body View configuration in config.xml format
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteAccessApi
     */
    public postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: AxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postViewConfig(name, body, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }
}


