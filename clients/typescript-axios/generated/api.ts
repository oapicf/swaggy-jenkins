/* tslint:disable */
/* eslint-disable */
/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * The version of the OpenAPI document: 3.2.1-pre.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AllView {
    '_class'?: string;
    'name'?: string;
    'url'?: string;
}
export interface BranchImpl {
    '_class'?: string;
    'displayName'?: string;
    'estimatedDurationInMillis'?: number;
    'fullDisplayName'?: string;
    'fullName'?: string;
    'name'?: string;
    'organization'?: string;
    'parameters'?: Array<StringParameterDefinition>;
    'permissions'?: BranchImplpermissions;
    'weatherScore'?: number;
    'pullRequest'?: string;
    '_links'?: BranchImpllinks;
    'latestRun'?: PipelineRunImpl;
}
export interface BranchImpllinks {
    'self'?: Link;
    'actions'?: Link;
    'runs'?: Link;
    'queue'?: Link;
    '_class'?: string;
}
export interface BranchImplpermissions {
    'create'?: boolean;
    'read'?: boolean;
    'start'?: boolean;
    'stop'?: boolean;
    '_class'?: string;
}
export interface CauseAction {
    '_class'?: string;
    'causes'?: Array<CauseUserIdCause>;
}
export interface CauseUserIdCause {
    '_class'?: string;
    'shortDescription'?: string;
    'userId'?: string;
    'userName'?: string;
}
export interface ClassesByClass {
    'classes'?: Array<string>;
    '_class'?: string;
}
export interface ClockDifference {
    '_class'?: string;
    'diff'?: number;
}
export interface ComputerSet {
    '_class'?: string;
    'busyExecutors'?: number;
    'computer'?: Array<HudsonMasterComputer>;
    'displayName'?: string;
    'totalExecutors'?: number;
}
export interface DefaultCrumbIssuer {
    '_class'?: string;
    'crumb'?: string;
    'crumbRequestField'?: string;
}
export interface DiskSpaceMonitorDescriptorDiskSpace {
    '_class'?: string;
    'timestamp'?: number;
    'path'?: string;
    'size'?: number;
}
export interface EmptyChangeLogSet {
    '_class'?: string;
    'kind'?: string;
}
export interface ExtensionClassContainerImpl1 {
    '_class'?: string;
    '_links'?: ExtensionClassContainerImpl1links;
    'map'?: ExtensionClassContainerImpl1map;
}
export interface ExtensionClassContainerImpl1links {
    'self'?: Link;
    '_class'?: string;
}
export interface ExtensionClassContainerImpl1map {
    'io.jenkins.blueocean.service.embedded.rest.PipelineImpl'?: ExtensionClassImpl;
    'io.jenkins.blueocean.service.embedded.rest.MultiBranchPipelineImpl'?: ExtensionClassImpl;
    '_class'?: string;
}
export interface ExtensionClassImpl {
    '_class'?: string;
    '_links'?: ExtensionClassImpllinks;
    'classes'?: Array<string>;
}
export interface ExtensionClassImpllinks {
    'self'?: Link;
    '_class'?: string;
}
export interface FavoriteImpl {
    '_class'?: string;
    '_links'?: FavoriteImpllinks;
    'item'?: PipelineImpl;
}
export interface FavoriteImpllinks {
    'self'?: Link;
    '_class'?: string;
}
export interface FreeStyleBuild {
    '_class'?: string;
    'number'?: number;
    'url'?: string;
    'actions'?: Array<CauseAction>;
    'building'?: boolean;
    'description'?: string;
    'displayName'?: string;
    'duration'?: number;
    'estimatedDuration'?: number;
    'executor'?: string;
    'fullDisplayName'?: string;
    'id'?: string;
    'keepLog'?: boolean;
    'queueId'?: number;
    'result'?: string;
    'timestamp'?: number;
    'builtOn'?: string;
    'changeSet'?: EmptyChangeLogSet;
}
export interface FreeStyleProject {
    '_class'?: string;
    'name'?: string;
    'url'?: string;
    'color'?: string;
    'actions'?: Array<FreeStyleProjectactions>;
    'description'?: string;
    'displayName'?: string;
    'displayNameOrNull'?: string;
    'fullDisplayName'?: string;
    'fullName'?: string;
    'buildable'?: boolean;
    'builds'?: Array<FreeStyleBuild>;
    'firstBuild'?: FreeStyleBuild;
    'healthReport'?: Array<FreeStyleProjecthealthReport>;
    'inQueue'?: boolean;
    'keepDependencies'?: boolean;
    'lastBuild'?: FreeStyleBuild;
    'lastCompletedBuild'?: FreeStyleBuild;
    'lastFailedBuild'?: string;
    'lastStableBuild'?: FreeStyleBuild;
    'lastSuccessfulBuild'?: FreeStyleBuild;
    'lastUnstableBuild'?: string;
    'lastUnsuccessfulBuild'?: string;
    'nextBuildNumber'?: number;
    'queueItem'?: string;
    'concurrentBuild'?: boolean;
    'scm'?: NullSCM;
}
export interface FreeStyleProjectactions {
    '_class'?: string;
}
export interface FreeStyleProjecthealthReport {
    'description'?: string;
    'iconClassName'?: string;
    'iconUrl'?: string;
    'score'?: number;
    '_class'?: string;
}
export interface GenericResource {
    '_class'?: string;
    'displayName'?: string;
    'durationInMillis'?: number;
    'id'?: string;
    'result'?: string;
    'startTime'?: string;
}
export interface GithubContent {
    'name'?: string;
    'sha'?: string;
    '_class'?: string;
    'repo'?: string;
    'size'?: number;
    'owner'?: string;
    'path'?: string;
    'base64Data'?: string;
}
export interface GithubFile {
    'content'?: GithubContent;
    '_class'?: string;
}
export interface GithubOrganization {
    '_class'?: string;
    '_links'?: GithubOrganizationlinks;
    'jenkinsOrganizationPipeline'?: boolean;
    'name'?: string;
}
export interface GithubOrganizationlinks {
    'repositories'?: Link;
    'self'?: Link;
    '_class'?: string;
}
export interface GithubRepositories {
    '_class'?: string;
    '_links'?: GithubRepositorieslinks;
    'items'?: Array<GithubRepository>;
    'lastPage'?: number;
    'nextPage'?: number;
    'pageSize'?: number;
}
export interface GithubRepositorieslinks {
    'self'?: Link;
    '_class'?: string;
}
export interface GithubRepository {
    '_class'?: string;
    '_links'?: GithubRepositorylinks;
    'defaultBranch'?: string;
    'description'?: string;
    'name'?: string;
    'permissions'?: GithubRepositorypermissions;
    'private'?: boolean;
    'fullName'?: string;
}
export interface GithubRepositorylinks {
    'self'?: Link;
    '_class'?: string;
}
export interface GithubRepositorypermissions {
    'admin'?: boolean;
    'push'?: boolean;
    'pull'?: boolean;
    '_class'?: string;
}
export interface GithubRespositoryContainer {
    '_class'?: string;
    '_links'?: GithubRespositoryContainerlinks;
    'repositories'?: GithubRepositories;
}
export interface GithubRespositoryContainerlinks {
    'self'?: Link;
    '_class'?: string;
}
export interface GithubScm {
    '_class'?: string;
    '_links'?: GithubScmlinks;
    'credentialId'?: string;
    'id'?: string;
    'uri'?: string;
}
export interface GithubScmlinks {
    'self'?: Link;
    '_class'?: string;
}
export interface Hudson {
    '_class'?: string;
    'assignedLabels'?: Array<HudsonassignedLabels>;
    'mode'?: string;
    'nodeDescription'?: string;
    'nodeName'?: string;
    'numExecutors'?: number;
    'description'?: string;
    'jobs'?: Array<FreeStyleProject>;
    'primaryView'?: AllView;
    'quietingDown'?: boolean;
    'slaveAgentPort'?: number;
    'unlabeledLoad'?: UnlabeledLoadStatistics;
    'useCrumbs'?: boolean;
    'useSecurity'?: boolean;
    'views'?: Array<AllView>;
}
export interface HudsonMasterComputer {
    '_class'?: string;
    'displayName'?: string;
    'executors'?: Array<HudsonMasterComputerexecutors>;
    'icon'?: string;
    'iconClassName'?: string;
    'idle'?: boolean;
    'jnlpAgent'?: boolean;
    'launchSupported'?: boolean;
    'loadStatistics'?: Label1;
    'manualLaunchAllowed'?: boolean;
    'monitorData'?: HudsonMasterComputermonitorData;
    'numExecutors'?: number;
    'offline'?: boolean;
    'offlineCause'?: string;
    'offlineCauseReason'?: string;
    'temporarilyOffline'?: boolean;
}
export interface HudsonMasterComputerexecutors {
    'currentExecutable'?: FreeStyleBuild;
    'idle'?: boolean;
    'likelyStuck'?: boolean;
    'number'?: number;
    'progress'?: number;
    '_class'?: string;
}
export interface HudsonMasterComputermonitorData {
    'hudson.node_monitors.SwapSpaceMonitor'?: SwapSpaceMonitorMemoryUsage2;
    'hudson.node_monitors.TemporarySpaceMonitor'?: DiskSpaceMonitorDescriptorDiskSpace;
    'hudson.node_monitors.DiskSpaceMonitor'?: DiskSpaceMonitorDescriptorDiskSpace;
    'hudson.node_monitors.ArchitectureMonitor'?: string;
    'hudson.node_monitors.ResponseTimeMonitor'?: ResponseTimeMonitorData;
    'hudson.node_monitors.ClockMonitor'?: ClockDifference;
    '_class'?: string;
}
export interface HudsonassignedLabels {
    '_class'?: string;
}
export interface InputStepImpl {
    '_class'?: string;
    '_links'?: InputStepImpllinks;
    'id'?: string;
    'message'?: string;
    'ok'?: string;
    'parameters'?: Array<StringParameterDefinition>;
    'submitter'?: string;
}
export interface InputStepImpllinks {
    'self'?: Link;
    '_class'?: string;
}
export interface Label1 {
    '_class'?: string;
}
export interface Link {
    '_class'?: string;
    'href'?: string;
}
export interface ListView {
    '_class'?: string;
    'description'?: string;
    'jobs'?: Array<FreeStyleProject>;
    'name'?: string;
    'url'?: string;
}
export interface MultibranchPipeline {
    'displayName'?: string;
    'estimatedDurationInMillis'?: number;
    'latestRun'?: string;
    'name'?: string;
    'organization'?: string;
    'weatherScore'?: number;
    'branchNames'?: Array<string>;
    'numberOfFailingBranches'?: number;
    'numberOfFailingPullRequests'?: number;
    'numberOfSuccessfulBranches'?: number;
    'numberOfSuccessfulPullRequests'?: number;
    'totalNumberOfBranches'?: number;
    'totalNumberOfPullRequests'?: number;
    '_class'?: string;
}
export interface NullSCM {
    '_class'?: string;
}
export interface Organisation {
    '_class'?: string;
    'name'?: string;
}
export interface Pipeline {
    '_class'?: string;
    'organization'?: string;
    'name'?: string;
    'displayName'?: string;
    'fullName'?: string;
    'weatherScore'?: number;
    'estimatedDurationInMillis'?: number;
    'latestRun'?: PipelinelatestRun;
}
export interface PipelineActivity {
    '_class'?: string;
    'artifacts'?: Array<PipelineActivityartifacts>;
    'durationInMillis'?: number;
    'estimatedDurationInMillis'?: number;
    'enQueueTime'?: string;
    'endTime'?: string;
    'id'?: string;
    'organization'?: string;
    'pipeline'?: string;
    'result'?: string;
    'runSummary'?: string;
    'startTime'?: string;
    'state'?: string;
    'type'?: string;
    'commitId'?: string;
}
export interface PipelineActivityartifacts {
    'name'?: string;
    'size'?: number;
    'url'?: string;
    '_class'?: string;
}
export interface PipelineBranchesitem {
    'displayName'?: string;
    'estimatedDurationInMillis'?: number;
    'name'?: string;
    'weatherScore'?: number;
    'latestRun'?: PipelineBranchesitemlatestRun;
    'organization'?: string;
    'pullRequest'?: PipelineBranchesitempullRequest;
    'totalNumberOfPullRequests'?: number;
    '_class'?: string;
}
export interface PipelineBranchesitemlatestRun {
    'durationInMillis'?: number;
    'estimatedDurationInMillis'?: number;
    'enQueueTime'?: string;
    'endTime'?: string;
    'id'?: string;
    'organization'?: string;
    'pipeline'?: string;
    'result'?: string;
    'runSummary'?: string;
    'startTime'?: string;
    'state'?: string;
    'type'?: string;
    'commitId'?: string;
    '_class'?: string;
}
export interface PipelineBranchesitempullRequest {
    '_links'?: PipelineBranchesitempullRequestlinks;
    'author'?: string;
    'id'?: string;
    'title'?: string;
    'url'?: string;
    '_class'?: string;
}
export interface PipelineBranchesitempullRequestlinks {
    'self'?: string;
    '_class'?: string;
}
export interface PipelineFolderImpl {
    '_class'?: string;
    'displayName'?: string;
    'fullName'?: string;
    'name'?: string;
    'organization'?: string;
    'numberOfFolders'?: number;
    'numberOfPipelines'?: number;
}
export interface PipelineImpl {
    '_class'?: string;
    'displayName'?: string;
    'estimatedDurationInMillis'?: number;
    'fullName'?: string;
    'latestRun'?: string;
    'name'?: string;
    'organization'?: string;
    'weatherScore'?: number;
    '_links'?: PipelineImpllinks;
}
export interface PipelineImpllinks {
    'self'?: Link;
    'actions'?: Link;
    'runs'?: Link;
    'queue'?: Link;
    '_class'?: string;
}
export interface PipelineRun {
    '_class'?: string;
    'artifacts'?: Array<PipelineRunartifacts>;
    'durationInMillis'?: number;
    'estimatedDurationInMillis'?: number;
    'enQueueTime'?: string;
    'endTime'?: string;
    'id'?: string;
    'organization'?: string;
    'pipeline'?: string;
    'result'?: string;
    'runSummary'?: string;
    'startTime'?: string;
    'state'?: string;
    'type'?: string;
    'commitId'?: string;
}
export interface PipelineRunImpl {
    '_class'?: string;
    '_links'?: PipelineRunImpllinks;
    'durationInMillis'?: number;
    'enQueueTime'?: string;
    'endTime'?: string;
    'estimatedDurationInMillis'?: number;
    'id'?: string;
    'organization'?: string;
    'pipeline'?: string;
    'result'?: string;
    'runSummary'?: string;
    'startTime'?: string;
    'state'?: string;
    'type'?: string;
    'commitId'?: string;
}
export interface PipelineRunImpllinks {
    'nodes'?: Link;
    'log'?: Link;
    'self'?: Link;
    'actions'?: Link;
    'steps'?: Link;
    '_class'?: string;
}
export interface PipelineRunNode {
    '_class'?: string;
    'displayName'?: string;
    'durationInMillis'?: number;
    'edges'?: Array<PipelineRunNodeedges>;
    'id'?: string;
    'result'?: string;
    'startTime'?: string;
    'state'?: string;
}
export interface PipelineRunNodeedges {
    'id'?: string;
    '_class'?: string;
}
export interface PipelineRunartifacts {
    'name'?: string;
    'size'?: number;
    'url'?: string;
    '_class'?: string;
}
export interface PipelineStepImpl {
    '_class'?: string;
    '_links'?: PipelineStepImpllinks;
    'displayName'?: string;
    'durationInMillis'?: number;
    'id'?: string;
    'input'?: InputStepImpl;
    'result'?: string;
    'startTime'?: string;
    'state'?: string;
}
export interface PipelineStepImpllinks {
    'self'?: Link;
    'actions'?: Link;
    '_class'?: string;
}
export interface PipelinelatestRun {
    'artifacts'?: Array<PipelinelatestRunartifacts>;
    'durationInMillis'?: number;
    'estimatedDurationInMillis'?: number;
    'enQueueTime'?: string;
    'endTime'?: string;
    'id'?: string;
    'organization'?: string;
    'pipeline'?: string;
    'result'?: string;
    'runSummary'?: string;
    'startTime'?: string;
    'state'?: string;
    'type'?: string;
    'commitId'?: string;
    '_class'?: string;
}
export interface PipelinelatestRunartifacts {
    'name'?: string;
    'size'?: number;
    'url'?: string;
    '_class'?: string;
}
export interface Queue {
    '_class'?: string;
    'items'?: Array<QueueBlockedItem>;
}
export interface QueueBlockedItem {
    '_class'?: string;
    'actions'?: Array<CauseAction>;
    'blocked'?: boolean;
    'buildable'?: boolean;
    'id'?: number;
    'inQueueSince'?: number;
    'params'?: string;
    'stuck'?: boolean;
    'task'?: FreeStyleProject;
    'url'?: string;
    'why'?: string;
    'buildableStartMilliseconds'?: number;
}
export interface QueueItemImpl {
    '_class'?: string;
    'expectedBuildNumber'?: number;
    'id'?: string;
    'pipeline'?: string;
    'queuedTime'?: number;
}
export interface QueueLeftItem {
    '_class'?: string;
    'actions'?: Array<CauseAction>;
    'blocked'?: boolean;
    'buildable'?: boolean;
    'id'?: number;
    'inQueueSince'?: number;
    'params'?: string;
    'stuck'?: boolean;
    'task'?: FreeStyleProject;
    'url'?: string;
    'why'?: string;
    'cancelled'?: boolean;
    'executable'?: FreeStyleBuild;
}
export interface ResponseTimeMonitorData {
    '_class'?: string;
    'timestamp'?: number;
    'average'?: number;
}
export interface StringParameterDefinition {
    '_class'?: string;
    'defaultParameterValue'?: StringParameterValue;
    'description'?: string;
    'name'?: string;
    'type'?: string;
}
export interface StringParameterValue {
    '_class'?: string;
    'name'?: string;
    'value'?: string;
}
export interface SwapSpaceMonitorMemoryUsage2 {
    '_class'?: string;
    'availablePhysicalMemory'?: number;
    'availableSwapSpace'?: number;
    'totalPhysicalMemory'?: number;
    'totalSwapSpace'?: number;
}
export interface UnlabeledLoadStatistics {
    '_class'?: string;
}
export interface User {
    '_class'?: string;
    'id'?: string;
    'fullName'?: string;
    'email'?: string;
    'name'?: string;
}

/**
 * BaseApi - axios parameter creator
 */
export const BaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crumbIssuer/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BaseApi - functional programming interface
 */
export const BaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrumb(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultCrumbIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrumb(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BaseApi.getCrumb']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BaseApi - factory interface
 */
export const BaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BaseApiFp(configuration)
    return {
        /**
         * Retrieve CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrumb(options?: RawAxiosRequestConfig): AxiosPromise<DefaultCrumbIssuer> {
            return localVarFp.getCrumb(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BaseApi - object-oriented interface
 */
export class BaseApi extends BaseAPI {
    /**
     * Retrieve CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCrumb(options?: RawAxiosRequestConfig) {
        return BaseApiFp(this.configuration).getCrumb(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlueOceanApi - axios parameter creator
 */
export const BlueOceanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineQueueItem: async (organization: string, pipeline: string, queue: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('deletePipelineQueueItem', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('deletePipelineQueueItem', 'pipeline', pipeline)
            // verify required parameter 'queue' is not null or undefined
            assertParamExists('deletePipelineQueueItem', 'queue', queue)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser: async (organization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getAuthenticatedUser', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}/user/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClasses: async (_class: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('getClasses', '_class', _class)
            const localVarPath = `/blue/rest/classes/{class}`
                .replace(`{${"class"}}`, encodeURIComponent(String(_class)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey: async (key: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getJsonWebKey', 'key', key)
            const localVarPath = `/jwt-auth/jwks/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebToken: async (expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jwt-auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expiryTimeInMins !== undefined) {
                localVarQueryParameter['expiryTimeInMins'] = expiryTimeInMins;
            }

            if (maxExpiryTimeInMins !== undefined) {
                localVarQueryParameter['maxExpiryTimeInMins'] = maxExpiryTimeInMins;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation: async (organization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getOrganisation', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blue/rest/organizations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: async (organization: string, pipeline: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipeline', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipeline', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineActivities: async (organization: string, pipeline: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineActivities', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineActivities', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranch: async (organization: string, pipeline: string, branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineBranch', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineBranch', 'pipeline', pipeline)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getPipelineBranch', 'branch', branch)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranchRun: async (organization: string, pipeline: string, branch: string, run: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'pipeline', pipeline)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'branch', branch)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineBranchRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranches: async (organization: string, pipeline: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineBranches', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineBranches', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolder: async (organization: string, folder: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineFolder', 'organization', organization)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getPipelineFolder', 'folder', folder)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{folder}/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolderPipeline: async (organization: string, pipeline: string, folder: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineFolderPipeline', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineFolderPipeline', 'pipeline', pipeline)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getPipelineFolderPipeline', 'folder', folder)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineQueue: async (organization: string, pipeline: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineQueue', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineQueue', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun: async (organization: string, pipeline: string, run: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRun', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunLog: async (organization: string, pipeline: string, run: string, start?: number, download?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunLog', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunLog', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunLog', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNode: async (organization: string, pipeline: string, run: string, node: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNode', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNode', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNode', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNode', 'node', node)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStep: async (organization: string, pipeline: string, run: string, node: string, step: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'node', node)
            // verify required parameter 'step' is not null or undefined
            assertParamExists('getPipelineRunNodeStep', 'step', step)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStepLog: async (organization: string, pipeline: string, run: string, node: string, step: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'node', node)
            // verify required parameter 'step' is not null or undefined
            assertParamExists('getPipelineRunNodeStepLog', 'step', step)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeSteps: async (organization: string, pipeline: string, run: string, node: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'run', run)
            // verify required parameter 'node' is not null or undefined
            assertParamExists('getPipelineRunNodeSteps', 'node', node)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodes: async (organization: string, pipeline: string, run: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRunNodes', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRunNodes', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('getPipelineRunNodes', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRuns: async (organization: string, pipeline: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelineRuns', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('getPipelineRuns', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines: async (organization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getPipelines', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCM: async (organization: string, scm: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCM', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCM', 'scm', scm)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepositories: async (organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCMOrganisationRepositories', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCMOrganisationRepositories', 'scm', scm)
            // verify required parameter 'scmOrganisation' is not null or undefined
            assertParamExists('getSCMOrganisationRepositories', 'scmOrganisation', scmOrganisation)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)))
                .replace(`{${"scmOrganisation"}}`, encodeURIComponent(String(scmOrganisation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepository: async (organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'scm', scm)
            // verify required parameter 'scmOrganisation' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'scmOrganisation', scmOrganisation)
            // verify required parameter 'repository' is not null or undefined
            assertParamExists('getSCMOrganisationRepository', 'repository', repository)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)))
                .replace(`{${"scmOrganisation"}}`, encodeURIComponent(String(scmOrganisation)))
                .replace(`{${"repository"}}`, encodeURIComponent(String(repository)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisations: async (organization: string, scm: string, credentialId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getSCMOrganisations', 'organization', organization)
            // verify required parameter 'scm' is not null or undefined
            assertParamExists('getSCMOrganisations', 'scm', scm)
            const localVarPath = `/blue/rest/organizations/{organization}/scm/{scm}/organizations`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"scm"}}`, encodeURIComponent(String(scm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (credentialId !== undefined) {
                localVarQueryParameter['credentialId'] = credentialId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (organization: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getUser', 'organization', organization)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUser', 'user', user)
            const localVarPath = `/blue/rest/organizations/{organization}/users/{user}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('getUserFavorites', 'user', user)
            const localVarPath = `/blue/rest/users/{user}/favorites`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (organization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getUsers', 'organization', organization)
            const localVarPath = `/blue/rest/organizations/{organization}/users/`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRun: async (organization: string, pipeline: string, run: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('postPipelineRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('postPipelineRun', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('postPipelineRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRuns: async (organization: string, pipeline: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('postPipelineRuns', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('postPipelineRuns', 'pipeline', pipeline)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineFavorite: async (organization: string, pipeline: string, body: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('putPipelineFavorite', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('putPipelineFavorite', 'pipeline', pipeline)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putPipelineFavorite', 'body', body)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineRun: async (organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('putPipelineRun', 'organization', organization)
            // verify required parameter 'pipeline' is not null or undefined
            assertParamExists('putPipelineRun', 'pipeline', pipeline)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('putPipelineRun', 'run', run)
            const localVarPath = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"pipeline"}}`, encodeURIComponent(String(pipeline)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (blocking !== undefined) {
                localVarQueryParameter['blocking'] = blocking;
            }

            if (timeOutInSecs !== undefined) {
                localVarQueryParameter['timeOutInSecs'] = timeOutInSecs;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('search', 'q', q)
            const localVarPath = `/blue/rest/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClasses: async (q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchClasses', 'q', q)
            const localVarPath = `/blue/rest/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlueOceanApi - functional programming interface
 */
export const BlueOceanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlueOceanApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineQueueItem(organization, pipeline, queue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.deletePipelineQueueItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticatedUser(organization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatedUser(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getAuthenticatedUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClasses(_class: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClasses(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonWebKey(key: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonWebKey(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getJsonWebKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getJsonWebToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganisation(organization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganisation(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getOrganisation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganisations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organisation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganisations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getOrganisations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipeline(organization: string, pipeline: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipeline(organization, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineActivities(organization: string, pipeline: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineActivities(organization, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineActivities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineBranch(organization: string, pipeline: string, branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineBranch(organization, pipeline, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineBranchRun(organization, pipeline, branch, run, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineBranchRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineBranches(organization: string, pipeline: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultibranchPipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineBranches(organization, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineFolder(organization: string, folder: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineFolderImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineFolder(organization, folder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineFolderPipeline(organization, pipeline, folder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineFolderPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineQueue(organization: string, pipeline: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QueueItemImpl>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineQueue(organization, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRun(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRun(organization, pipeline, run, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunLog(organization, pipeline, run, start, download, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRunLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRunNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNode(organization, pipeline, run, node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRunNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineStepImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodeStep(organization, pipeline, run, node, step, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRunNodeStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRunNodeStepLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineStepImpl>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodeSteps(organization, pipeline, run, node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRunNodeSteps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRunNode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRunNodes(organization, pipeline, run, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRunNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRuns(organization: string, pipeline: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRuns(organization, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelineRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelines(organization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pipeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelines(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getPipelines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCM(organization: string, scm: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubScm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCM(organization, scm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getSCM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GithubOrganization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getSCMOrganisationRepositories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GithubOrganization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getSCMOrganisationRepository']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GithubOrganization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSCMOrganisations(organization, scm, credentialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getSCMOrganisations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(organization: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(organization, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFavorites(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FavoriteImpl>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFavorites(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getUserFavorites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(organization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPipelineRun(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueItemImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPipelineRun(organization, pipeline, run, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.postPipelineRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPipelineRuns(organization: string, pipeline: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueItemImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPipelineRuns(organization, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.postPipelineRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPipelineFavorite(organization: string, pipeline: string, body: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteImpl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPipelineFavorite(organization, pipeline, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.putPipelineFavorite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.putPipelineRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchClasses(q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchClasses(q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlueOceanApi.searchClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlueOceanApi - factory interface
 */
export const BlueOceanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlueOceanApiFp(configuration)
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} queue Name of the queue item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineQueueItem(organization, pipeline, queue, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedUser(organization: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getAuthenticatedUser(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of class names supported by a given class
         * @param {string} _class Name of the class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClasses(_class: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getClasses(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve JSON Web Key
         * @param {number} key Key ID received as part of JWT header field kid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebKey(key: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getJsonWebKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve JSON Web Token
         * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
         * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve organization details
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organization: string, options?: RawAxiosRequestConfig): AxiosPromise<Organisation> {
            return localVarFp.getOrganisation(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all organizations details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisations(options?: RawAxiosRequestConfig): AxiosPromise<Array<Organisation>> {
            return localVarFp.getOrganisations(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve pipeline details for an organization
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(organization: string, pipeline: string, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.getPipeline(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineActivities(organization: string, pipeline: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PipelineActivity>> {
            return localVarFp.getPipelineActivities(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranch(organization: string, pipeline: string, branch: string, options?: RawAxiosRequestConfig): AxiosPromise<BranchImpl> {
            return localVarFp.getPipelineBranch(organization, pipeline, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} branch Name of the branch
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.getPipelineBranchRun(organization, pipeline, branch, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineBranches(organization: string, pipeline: string, options?: RawAxiosRequestConfig): AxiosPromise<MultibranchPipeline> {
            return localVarFp.getPipelineBranches(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param {string} organization Name of the organization
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolder(organization: string, folder: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineFolderImpl> {
            return localVarFp.getPipelineFolder(organization, folder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} folder Name of the folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineImpl> {
            return localVarFp.getPipelineFolderPipeline(organization, pipeline, folder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineQueue(organization: string, pipeline: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<QueueItemImpl>> {
            return localVarFp.getPipelineQueue(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.getPipelineRun(organization, pipeline, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Get log for a pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {number} [start] Start position of the log
         * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getPipelineRunLog(organization, pipeline, run, start, download, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineRunNode> {
            return localVarFp.getPipelineRunNode(organization, pipeline, run, node, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: RawAxiosRequestConfig): AxiosPromise<PipelineStepImpl> {
            return localVarFp.getPipelineRunNodeStep(organization, pipeline, run, node, step, options).then((request) => request(axios, basePath));
        },
        /**
         * Get log for a pipeline run node step
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {string} step Name of the step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} node Name of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PipelineStepImpl>> {
            return localVarFp.getPipelineRunNodeSteps(organization, pipeline, run, node, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PipelineRunNode>> {
            return localVarFp.getPipelineRunNodes(organization, pipeline, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRuns(organization: string, pipeline: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PipelineRun>> {
            return localVarFp.getPipelineRuns(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(organization: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pipeline>> {
            return localVarFp.getPipelines(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCM(organization: string, scm: string, options?: RawAxiosRequestConfig): AxiosPromise<GithubScm> {
            return localVarFp.getSCM(organization, scm, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} [credentialId] Credential ID
         * @param {number} [pageSize] Number of items in a page
         * @param {number} [pageNumber] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GithubOrganization>> {
            return localVarFp.getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} scmOrganisation Name of the SCM organization
         * @param {string} repository Name of the SCM repository
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GithubOrganization>> {
            return localVarFp.getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param {string} organization Name of the organization
         * @param {string} scm Name of SCM
         * @param {string} [credentialId] Credential ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GithubOrganization>> {
            return localVarFp.getSCMOrganisations(organization, scm, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user details for an organization
         * @param {string} organization Name of the organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(organization: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user favorites details for an organization
         * @param {string} user Name of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFavorites(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FavoriteImpl>> {
            return localVarFp.getUserFavorites(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users details for an organization
         * @param {string} organization Name of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(organization: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUsers(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Replay an organization pipeline run
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRun(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig): AxiosPromise<QueueItemImpl> {
            return localVarFp.postPipelineRun(organization, pipeline, run, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a build for an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPipelineRuns(organization: string, pipeline: string, options?: RawAxiosRequestConfig): AxiosPromise<QueueItemImpl> {
            return localVarFp.postPipelineRuns(organization, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineFavorite(organization: string, pipeline: string, body: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FavoriteImpl> {
            return localVarFp.putPipelineFavorite(organization, pipeline, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop a build of an organization pipeline
         * @param {string} organization Name of the organization
         * @param {string} pipeline Name of the pipeline
         * @param {string} run Name of the run
         * @param {string} [blocking] Set to true to make blocking stop, default: false
         * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: RawAxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for any resource details
         * @param {string} q Query string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(q: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.search(q, options).then((request) => request(axios, basePath));
        },
        /**
         * Get classes details
         * @param {string} q Query string containing an array of class names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClasses(q: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.searchClasses(q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlueOceanApi - object-oriented interface
 */
export class BlueOceanApi extends BaseAPI {
    /**
     * Delete queue item from an organization pipeline queue
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} queue Name of the queue item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePipelineQueueItem(organization: string, pipeline: string, queue: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).deletePipelineQueueItem(organization, pipeline, queue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve authenticated user details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthenticatedUser(organization: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getAuthenticatedUser(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of class names supported by a given class
     * @param {string} _class Name of the class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClasses(_class: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getClasses(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve JSON Web Key
     * @param {number} key Key ID received as part of JWT header field kid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJsonWebKey(key: number, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getJsonWebKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve JSON Web Token
     * @param {number} [expiryTimeInMins] Token expiry time in minutes, default: 30 minutes
     * @param {number} [maxExpiryTimeInMins] Maximum token expiry time in minutes, default: 480 minutes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJsonWebToken(expiryTimeInMins?: number, maxExpiryTimeInMins?: number, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve organization details
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrganisation(organization: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getOrganisation(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all organizations details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrganisations(options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getOrganisations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve pipeline details for an organization
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipeline(organization: string, pipeline: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipeline(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all activities details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineActivities(organization: string, pipeline: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineActivities(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve branch details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} branch Name of the branch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineBranch(organization: string, pipeline: string, branch: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineBranch(organization, pipeline, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve branch run details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} branch Name of the branch
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineBranchRun(organization: string, pipeline: string, branch: string, run: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineBranchRun(organization, pipeline, branch, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all branches details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineBranches(organization: string, pipeline: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineBranches(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve pipeline folder for an organization
     * @param {string} organization Name of the organization
     * @param {string} folder Name of the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineFolder(organization: string, folder: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineFolder(organization, folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve pipeline details for an organization folder
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} folder Name of the folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineFolderPipeline(organization: string, pipeline: string, folder: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineFolderPipeline(organization, pipeline, folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve queue details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineQueue(organization: string, pipeline: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineQueue(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRun(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRun(organization, pipeline, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get log for a pipeline run
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {number} [start] Start position of the log
     * @param {boolean} [download] Set to true in order to download the file, otherwise it\&#39;s passed as a response body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRunLog(organization: string, pipeline: string, run: string, start?: number, download?: boolean, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunLog(organization, pipeline, run, start, download, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run node details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRunNode(organization: string, pipeline: string, run: string, node: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNode(organization, pipeline, run, node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run node details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {string} step Name of the step
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRunNodeStep(organization: string, pipeline: string, run: string, node: string, step: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeStep(organization, pipeline, run, node, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get log for a pipeline run node step
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {string} step Name of the step
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRunNodeStepLog(organization: string, pipeline: string, run: string, node: string, step: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeStepLog(organization, pipeline, run, node, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run node steps details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} node Name of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRunNodeSteps(organization: string, pipeline: string, run: string, node: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodeSteps(organization, pipeline, run, node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve run nodes details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRunNodes(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRunNodes(organization, pipeline, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all runs details for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelineRuns(organization: string, pipeline: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelineRuns(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all pipelines details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPipelines(organization: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getPipelines(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSCM(organization: string, scm: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCM(organization, scm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM organization repositories details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} scmOrganisation Name of the SCM organization
     * @param {string} [credentialId] Credential ID
     * @param {number} [pageSize] Number of items in a page
     * @param {number} [pageNumber] Page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSCMOrganisationRepositories(organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM organization repository details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} scmOrganisation Name of the SCM organization
     * @param {string} repository Name of the SCM repository
     * @param {string} [credentialId] Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSCMOrganisationRepository(organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve SCM organizations details for an organization
     * @param {string} organization Name of the organization
     * @param {string} scm Name of SCM
     * @param {string} [credentialId] Credential ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSCMOrganisations(organization: string, scm: string, credentialId?: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getSCMOrganisations(organization, scm, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user details for an organization
     * @param {string} organization Name of the organization
     * @param {string} user Name of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUser(organization: string, user: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getUser(organization, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user favorites details for an organization
     * @param {string} user Name of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserFavorites(user: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getUserFavorites(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users details for an organization
     * @param {string} organization Name of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(organization: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).getUsers(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replay an organization pipeline run
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPipelineRun(organization: string, pipeline: string, run: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).postPipelineRun(organization, pipeline, run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a build for an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPipelineRuns(organization: string, pipeline: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).postPipelineRuns(organization, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Favorite/unfavorite a pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {boolean} body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putPipelineFavorite(organization: string, pipeline: string, body: boolean, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).putPipelineFavorite(organization, pipeline, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a build of an organization pipeline
     * @param {string} organization Name of the organization
     * @param {string} pipeline Name of the pipeline
     * @param {string} run Name of the run
     * @param {string} [blocking] Set to true to make blocking stop, default: false
     * @param {number} [timeOutInSecs] Timeout in seconds, default: 10 seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putPipelineRun(organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for any resource details
     * @param {string} q Query string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public search(q: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).search(q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get classes details
     * @param {string} q Query string containing an array of class names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchClasses(q: string, options?: RawAxiosRequestConfig) {
        return BlueOceanApiFp(this.configuration).searchClasses(q, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RemoteAccessApi - axios parameter creator
 */
export const RemoteAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComputer: async (depth: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'depth' is not null or undefined
            assertParamExists('getComputer', 'depth', depth)
            const localVarPath = `/computer/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJenkins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJob', 'name', name)
            const localVarPath = `/job/{name}/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobConfig: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJobConfig', 'name', name)
            const localVarPath = `/job/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'text/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job\'s last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLastBuild: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJobLastBuild', 'name', name)
            const localVarPath = `/job/{name}/lastBuild/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve job\'s build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProgressiveText: async (name: string, number: string, start: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getJobProgressiveText', 'name', name)
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getJobProgressiveText', 'number', number)
            // verify required parameter 'start' is not null or undefined
            assertParamExists('getJobProgressiveText', 'start', start)
            const localVarPath = `/job/{name}/{number}/logText/progressiveText`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/queue/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueItem: async (number: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('getQueueItem', 'number', number)
            const localVarPath = `/queue/item/{number}/api/json`
                .replace(`{${"number"}}`, encodeURIComponent(String(number)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getView', 'name', name)
            const localVarPath = `/view/{name}/api/json`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConfig: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getViewConfig', 'name', name)
            const localVarPath = `/view/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Accept'] = 'text/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headJenkins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateItem: async (name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postCreateItem', 'name', name)
            const localVarPath = `/createItem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateView: async (name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postCreateView', 'name', name)
            const localVarPath = `/createView`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobBuild: async (name: string, json: string, token?: string, jenkinsCrumb?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobBuild', 'name', name)
            // verify required parameter 'json' is not null or undefined
            assertParamExists('postJobBuild', 'json', json)
            const localVarPath = `/job/{name}/build`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (json !== undefined) {
                localVarQueryParameter['json'] = json;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobConfig: async (name: string, body: string, jenkinsCrumb?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobConfig', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postJobConfig', 'body', body)
            const localVarPath = `/job/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDelete: async (name: string, jenkinsCrumb?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobDelete', 'name', name)
            const localVarPath = `/job/{name}/doDelete`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDisable: async (name: string, jenkinsCrumb?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobDisable', 'name', name)
            const localVarPath = `/job/{name}/disable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEnable: async (name: string, jenkinsCrumb?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobEnable', 'name', name)
            const localVarPath = `/job/{name}/enable`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobLastBuildStop: async (name: string, jenkinsCrumb?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postJobLastBuildStop', 'name', name)
            const localVarPath = `/job/{name}/lastBuild/stop`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postViewConfig: async (name: string, body: string, jenkinsCrumb?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postViewConfig', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postViewConfig', 'body', body)
            const localVarPath = `/view/{name}/config.xml`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jenkins_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            if (jenkinsCrumb != null) {
                localVarHeaderParameter['Jenkins-Crumb'] = String(jenkinsCrumb);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteAccessApi - functional programming interface
 */
export const RemoteAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemoteAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComputer(depth: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComputerSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComputer(depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getComputer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJenkins(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hudson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJenkins(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getJenkins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreeStyleProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobConfig(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobConfig(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getJobConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve job\'s last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobLastBuild(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FreeStyleBuild>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLastBuild(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getJobLastBuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve job\'s build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobProgressiveText(name: string, number: string, start: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobProgressiveText(name, number, start, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getJobProgressiveText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueue(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Queue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueue(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueItem(number: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Queue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueItem(number, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getQueueItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getView(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getView(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewConfig(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getViewConfig(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.getViewConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headJenkins(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.headJenkins(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.headJenkins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postCreateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCreateView(name, jenkinsCrumb, contentType, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postCreateView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobBuild(name, json, token, jenkinsCrumb, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postJobBuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobConfig(name, body, jenkinsCrumb, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postJobConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobDelete(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobDelete(name, jenkinsCrumb, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postJobDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobDisable(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobDisable(name, jenkinsCrumb, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postJobDisable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobEnable(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobEnable(name, jenkinsCrumb, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postJobEnable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postJobLastBuildStop(name, jenkinsCrumb, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postJobLastBuildStop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postViewConfig(name, body, jenkinsCrumb, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RemoteAccessApi.postViewConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RemoteAccessApi - factory interface
 */
export const RemoteAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemoteAccessApiFp(configuration)
    return {
        /**
         * Retrieve computer details
         * @param {number} depth Recursion depth in response model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComputer(depth: number, options?: RawAxiosRequestConfig): AxiosPromise<ComputerSet> {
            return localVarFp.getComputer(depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Jenkins details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJenkins(options?: RawAxiosRequestConfig): AxiosPromise<Hudson> {
            return localVarFp.getJenkins(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(name: string, options?: RawAxiosRequestConfig): AxiosPromise<FreeStyleProject> {
            return localVarFp.getJob(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job configuration
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobConfig(name: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getJobConfig(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job\'s last build details
         * @param {string} name Name of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLastBuild(name: string, options?: RawAxiosRequestConfig): AxiosPromise<FreeStyleBuild> {
            return localVarFp.getJobLastBuild(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve job\'s build progressive text output
         * @param {string} name Name of the job
         * @param {string} number Build number
         * @param {string} start Starting point of progressive text output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobProgressiveText(name: string, number: string, start: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getJobProgressiveText(name, number, start, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve queue details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(options?: RawAxiosRequestConfig): AxiosPromise<Queue> {
            return localVarFp.getQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve queued item details
         * @param {string} number Queue number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueItem(number: string, options?: RawAxiosRequestConfig): AxiosPromise<Queue> {
            return localVarFp.getQueueItem(number, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve view details
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(name: string, options?: RawAxiosRequestConfig): AxiosPromise<ListView> {
            return localVarFp.getView(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve view configuration
         * @param {string} name Name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConfig(name: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getViewConfig(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Jenkins headers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headJenkins(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.headJenkins(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param {string} name Name of the new job
         * @param {string} [from] Existing job to copy from
         * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] Job configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new view using view configuration
         * @param {string} name Name of the new view
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {string} [contentType] Content type header application/xml
         * @param {string} [body] View configuration in config.xml format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postCreateView(name, jenkinsCrumb, contentType, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Build a job
         * @param {string} name Name of the job
         * @param {string} json 
         * @param {string} [token] 
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postJobBuild(name, json, token, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Update job configuration
         * @param {string} name Name of the job
         * @param {string} body Job configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postJobConfig(name, body, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDelete(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postJobDelete(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobDisable(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postJobDisable(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobEnable(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postJobEnable(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop a job
         * @param {string} name Name of the job
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postJobLastBuildStop(name, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
        /**
         * Update view configuration
         * @param {string} name Name of the view
         * @param {string} body View configuration in config.xml format
         * @param {string} [jenkinsCrumb] CSRF protection token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postViewConfig(name, body, jenkinsCrumb, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemoteAccessApi - object-oriented interface
 */
export class RemoteAccessApi extends BaseAPI {
    /**
     * Retrieve computer details
     * @param {number} depth Recursion depth in response model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getComputer(depth: number, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getComputer(depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Jenkins details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJenkins(options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJenkins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job details
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJob(name: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJob(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job configuration
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJobConfig(name: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJobConfig(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job\'s last build details
     * @param {string} name Name of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJobLastBuild(name: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJobLastBuild(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve job\'s build progressive text output
     * @param {string} name Name of the job
     * @param {string} number Build number
     * @param {string} start Starting point of progressive text output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJobProgressiveText(name: string, number: string, start: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getJobProgressiveText(name, number, start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve queue details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQueue(options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve queued item details
     * @param {string} number Queue number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQueueItem(number: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getQueueItem(number, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve view details
     * @param {string} name Name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getView(name: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getView(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve view configuration
     * @param {string} name Name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getViewConfig(name: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).getViewConfig(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Jenkins headers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public headJenkins(options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).headJenkins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new job using job configuration, or copied from an existing job
     * @param {string} name Name of the new job
     * @param {string} [from] Existing job to copy from
     * @param {string} [mode] Set to \&#39;copy\&#39; for copying an existing job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {string} [contentType] Content type header application/xml
     * @param {string} [body] Job configuration in config.xml format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCreateItem(name: string, from?: string, mode?: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postCreateItem(name, from, mode, jenkinsCrumb, contentType, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new view using view configuration
     * @param {string} name Name of the new view
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {string} [contentType] Content type header application/xml
     * @param {string} [body] View configuration in config.xml format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCreateView(name: string, jenkinsCrumb?: string, contentType?: string, body?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postCreateView(name, jenkinsCrumb, contentType, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Build a job
     * @param {string} name Name of the job
     * @param {string} json 
     * @param {string} [token] 
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postJobBuild(name: string, json: string, token?: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobBuild(name, json, token, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update job configuration
     * @param {string} name Name of the job
     * @param {string} body Job configuration in config.xml format
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postJobConfig(name: string, body: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobConfig(name, body, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postJobDelete(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobDelete(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postJobDisable(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobDisable(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postJobEnable(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobEnable(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a job
     * @param {string} name Name of the job
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postJobLastBuildStop(name: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postJobLastBuildStop(name, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update view configuration
     * @param {string} name Name of the view
     * @param {string} body View configuration in config.xml format
     * @param {string} [jenkinsCrumb] CSRF protection token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postViewConfig(name: string, body: string, jenkinsCrumb?: string, options?: RawAxiosRequestConfig) {
        return RemoteAccessApiFp(this.configuration).postViewConfig(name, body, jenkinsCrumb, options).then((request) => request(this.axios, this.basePath));
    }
}



