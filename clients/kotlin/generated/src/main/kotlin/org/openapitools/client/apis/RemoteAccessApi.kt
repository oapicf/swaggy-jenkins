/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ComputerSet
import org.openapitools.client.models.FreeStyleBuild
import org.openapitools.client.models.FreeStyleProject
import org.openapitools.client.models.Hudson
import org.openapitools.client.models.ListView
import org.openapitools.client.models.Queue

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class RemoteAccessApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * GET /computer/api/json
     * 
     * Retrieve computer details
     * @param depth Recursion depth in response model
     * @return ComputerSet
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getComputer(depth: kotlin.Int) : ComputerSet {
        val localVarResponse = getComputerWithHttpInfo(depth = depth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ComputerSet
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /computer/api/json
     * 
     * Retrieve computer details
     * @param depth Recursion depth in response model
     * @return ApiResponse<ComputerSet?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getComputerWithHttpInfo(depth: kotlin.Int) : ApiResponse<ComputerSet?> {
        val localVariableConfig = getComputerRequestConfig(depth = depth)

        return request<Unit, ComputerSet>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getComputer
     *
     * @param depth Recursion depth in response model
     * @return RequestConfig
     */
    fun getComputerRequestConfig(depth: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("depth", listOf(depth.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/computer/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/json
     * 
     * Retrieve Jenkins details
     * @return Hudson
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJenkins() : Hudson {
        val localVarResponse = getJenkinsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Hudson
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/json
     * 
     * Retrieve Jenkins details
     * @return ApiResponse<Hudson?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getJenkinsWithHttpInfo() : ApiResponse<Hudson?> {
        val localVariableConfig = getJenkinsRequestConfig()

        return request<Unit, Hudson>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getJenkins
     *
     * @return RequestConfig
     */
    fun getJenkinsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /job/{name}/api/json
     * 
     * Retrieve job details
     * @param name Name of the job
     * @return FreeStyleProject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJob(name: kotlin.String) : FreeStyleProject {
        val localVarResponse = getJobWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FreeStyleProject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /job/{name}/api/json
     * 
     * Retrieve job details
     * @param name Name of the job
     * @return ApiResponse<FreeStyleProject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getJobWithHttpInfo(name: kotlin.String) : ApiResponse<FreeStyleProject?> {
        val localVariableConfig = getJobRequestConfig(name = name)

        return request<Unit, FreeStyleProject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getJob
     *
     * @param name Name of the job
     * @return RequestConfig
     */
    fun getJobRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/job/{name}/api/json".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /job/{name}/config.xml
     * 
     * Retrieve job configuration
     * @param name Name of the job
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJobConfig(name: kotlin.String) : kotlin.String {
        val localVarResponse = getJobConfigWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /job/{name}/config.xml
     * 
     * Retrieve job configuration
     * @param name Name of the job
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getJobConfigWithHttpInfo(name: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getJobConfigRequestConfig(name = name)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getJobConfig
     *
     * @param name Name of the job
     * @return RequestConfig
     */
    fun getJobConfigRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/job/{name}/config.xml".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /job/{name}/lastBuild/api/json
     * 
     * Retrieve job&#39;s last build details
     * @param name Name of the job
     * @return FreeStyleBuild
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJobLastBuild(name: kotlin.String) : FreeStyleBuild {
        val localVarResponse = getJobLastBuildWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FreeStyleBuild
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /job/{name}/lastBuild/api/json
     * 
     * Retrieve job&#39;s last build details
     * @param name Name of the job
     * @return ApiResponse<FreeStyleBuild?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getJobLastBuildWithHttpInfo(name: kotlin.String) : ApiResponse<FreeStyleBuild?> {
        val localVariableConfig = getJobLastBuildRequestConfig(name = name)

        return request<Unit, FreeStyleBuild>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getJobLastBuild
     *
     * @param name Name of the job
     * @return RequestConfig
     */
    fun getJobLastBuildRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/job/{name}/lastBuild/api/json".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /job/{name}/{number}/logText/progressiveText
     * 
     * Retrieve job&#39;s build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJobProgressiveText(name: kotlin.String, number: kotlin.String, start: kotlin.String) : Unit {
        val localVarResponse = getJobProgressiveTextWithHttpInfo(name = name, number = number, start = start)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /job/{name}/{number}/logText/progressiveText
     * 
     * Retrieve job&#39;s build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun getJobProgressiveTextWithHttpInfo(name: kotlin.String, number: kotlin.String, start: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = getJobProgressiveTextRequestConfig(name = name, number = number, start = start)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getJobProgressiveText
     *
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     * @return RequestConfig
     */
    fun getJobProgressiveTextRequestConfig(name: kotlin.String, number: kotlin.String, start: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start", listOf(start.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/job/{name}/{number}/logText/progressiveText".replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"number"+"}", encodeURIComponent(number.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /queue/api/json
     * 
     * Retrieve queue details
     * @return Queue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getQueue() : Queue {
        val localVarResponse = getQueueWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Queue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /queue/api/json
     * 
     * Retrieve queue details
     * @return ApiResponse<Queue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getQueueWithHttpInfo() : ApiResponse<Queue?> {
        val localVariableConfig = getQueueRequestConfig()

        return request<Unit, Queue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getQueue
     *
     * @return RequestConfig
     */
    fun getQueueRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/queue/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /queue/item/{number}/api/json
     * 
     * Retrieve queued item details
     * @param number Queue number
     * @return Queue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getQueueItem(number: kotlin.String) : Queue {
        val localVarResponse = getQueueItemWithHttpInfo(number = number)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Queue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /queue/item/{number}/api/json
     * 
     * Retrieve queued item details
     * @param number Queue number
     * @return ApiResponse<Queue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getQueueItemWithHttpInfo(number: kotlin.String) : ApiResponse<Queue?> {
        val localVariableConfig = getQueueItemRequestConfig(number = number)

        return request<Unit, Queue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getQueueItem
     *
     * @param number Queue number
     * @return RequestConfig
     */
    fun getQueueItemRequestConfig(number: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/queue/item/{number}/api/json".replace("{"+"number"+"}", encodeURIComponent(number.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /view/{name}/api/json
     * 
     * Retrieve view details
     * @param name Name of the view
     * @return ListView
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getView(name: kotlin.String) : ListView {
        val localVarResponse = getViewWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListView
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /view/{name}/api/json
     * 
     * Retrieve view details
     * @param name Name of the view
     * @return ApiResponse<ListView?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getViewWithHttpInfo(name: kotlin.String) : ApiResponse<ListView?> {
        val localVariableConfig = getViewRequestConfig(name = name)

        return request<Unit, ListView>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getView
     *
     * @param name Name of the view
     * @return RequestConfig
     */
    fun getViewRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/view/{name}/api/json".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /view/{name}/config.xml
     * 
     * Retrieve view configuration
     * @param name Name of the view
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getViewConfig(name: kotlin.String) : kotlin.String {
        val localVarResponse = getViewConfigWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /view/{name}/config.xml
     * 
     * Retrieve view configuration
     * @param name Name of the view
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getViewConfigWithHttpInfo(name: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getViewConfigRequestConfig(name = name)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getViewConfig
     *
     * @param name Name of the view
     * @return RequestConfig
     */
    fun getViewConfigRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/view/{name}/config.xml".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * HEAD /api/json
     * 
     * Retrieve Jenkins headers
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun headJenkins() : Unit {
        val localVarResponse = headJenkinsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * HEAD /api/json
     * 
     * Retrieve Jenkins headers
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun headJenkinsWithHttpInfo() : ApiResponse<Unit?> {
        val localVariableConfig = headJenkinsRequestConfig()

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation headJenkins
     *
     * @return RequestConfig
     */
    fun headJenkinsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.HEAD,
            path = "/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /createItem
     * 
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from (optional)
     * @param mode Set to &#39;copy&#39; for copying an existing job (optional)
     * @param jenkinsCrumb CSRF protection token (optional)
     * @param contentType Content type header application/xml (optional)
     * @param body Job configuration in config.xml format (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postCreateItem(name: kotlin.String, from: kotlin.String? = null, mode: kotlin.String? = null, jenkinsCrumb: kotlin.String? = null, contentType: kotlin.String? = null, body: kotlin.String? = null) : Unit {
        val localVarResponse = postCreateItemWithHttpInfo(name = name, from = from, mode = mode, jenkinsCrumb = jenkinsCrumb, contentType = contentType, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /createItem
     * 
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from (optional)
     * @param mode Set to &#39;copy&#39; for copying an existing job (optional)
     * @param jenkinsCrumb CSRF protection token (optional)
     * @param contentType Content type header application/xml (optional)
     * @param body Job configuration in config.xml format (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postCreateItemWithHttpInfo(name: kotlin.String, from: kotlin.String?, mode: kotlin.String?, jenkinsCrumb: kotlin.String?, contentType: kotlin.String?, body: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postCreateItemRequestConfig(name = name, from = from, mode = mode, jenkinsCrumb = jenkinsCrumb, contentType = contentType, body = body)

        return request<kotlin.String, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postCreateItem
     *
     * @param name Name of the new job
     * @param from Existing job to copy from (optional)
     * @param mode Set to &#39;copy&#39; for copying an existing job (optional)
     * @param jenkinsCrumb CSRF protection token (optional)
     * @param contentType Content type header application/xml (optional)
     * @param body Job configuration in config.xml format (optional)
     * @return RequestConfig
     */
    fun postCreateItemRequestConfig(name: kotlin.String, from: kotlin.String?, mode: kotlin.String?, jenkinsCrumb: kotlin.String?, contentType: kotlin.String?, body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("name", listOf(name.toString()))
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/createItem",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /createView
     * 
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param jenkinsCrumb CSRF protection token (optional)
     * @param contentType Content type header application/xml (optional)
     * @param body View configuration in config.xml format (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postCreateView(name: kotlin.String, jenkinsCrumb: kotlin.String? = null, contentType: kotlin.String? = null, body: kotlin.String? = null) : Unit {
        val localVarResponse = postCreateViewWithHttpInfo(name = name, jenkinsCrumb = jenkinsCrumb, contentType = contentType, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /createView
     * 
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param jenkinsCrumb CSRF protection token (optional)
     * @param contentType Content type header application/xml (optional)
     * @param body View configuration in config.xml format (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postCreateViewWithHttpInfo(name: kotlin.String, jenkinsCrumb: kotlin.String?, contentType: kotlin.String?, body: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postCreateViewRequestConfig(name = name, jenkinsCrumb = jenkinsCrumb, contentType = contentType, body = body)

        return request<kotlin.String, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postCreateView
     *
     * @param name Name of the new view
     * @param jenkinsCrumb CSRF protection token (optional)
     * @param contentType Content type header application/xml (optional)
     * @param body View configuration in config.xml format (optional)
     * @return RequestConfig
     */
    fun postCreateViewRequestConfig(name: kotlin.String, jenkinsCrumb: kotlin.String?, contentType: kotlin.String?, body: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("name", listOf(name.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/createView",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /job/{name}/build
     * 
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token  (optional)
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postJobBuild(name: kotlin.String, json: kotlin.String, token: kotlin.String? = null, jenkinsCrumb: kotlin.String? = null) : Unit {
        val localVarResponse = postJobBuildWithHttpInfo(name = name, json = json, token = token, jenkinsCrumb = jenkinsCrumb)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /job/{name}/build
     * 
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token  (optional)
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postJobBuildWithHttpInfo(name: kotlin.String, json: kotlin.String, token: kotlin.String?, jenkinsCrumb: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postJobBuildRequestConfig(name = name, json = json, token = token, jenkinsCrumb = jenkinsCrumb)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postJobBuild
     *
     * @param name Name of the job
     * @param json 
     * @param token  (optional)
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return RequestConfig
     */
    fun postJobBuildRequestConfig(name: kotlin.String, json: kotlin.String, token: kotlin.String?, jenkinsCrumb: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("json", listOf(json.toString()))
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/job/{name}/build".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /job/{name}/config.xml
     * 
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postJobConfig(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String? = null) : Unit {
        val localVarResponse = postJobConfigWithHttpInfo(name = name, body = body, jenkinsCrumb = jenkinsCrumb)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /job/{name}/config.xml
     * 
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postJobConfigWithHttpInfo(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postJobConfigRequestConfig(name = name, body = body, jenkinsCrumb = jenkinsCrumb)

        return request<kotlin.String, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postJobConfig
     *
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return RequestConfig
     */
    fun postJobConfigRequestConfig(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/job/{name}/config.xml".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /job/{name}/doDelete
     * 
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postJobDelete(name: kotlin.String, jenkinsCrumb: kotlin.String? = null) : Unit {
        val localVarResponse = postJobDeleteWithHttpInfo(name = name, jenkinsCrumb = jenkinsCrumb)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /job/{name}/doDelete
     * 
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postJobDeleteWithHttpInfo(name: kotlin.String, jenkinsCrumb: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postJobDeleteRequestConfig(name = name, jenkinsCrumb = jenkinsCrumb)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postJobDelete
     *
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return RequestConfig
     */
    fun postJobDeleteRequestConfig(name: kotlin.String, jenkinsCrumb: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/job/{name}/doDelete".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /job/{name}/disable
     * 
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postJobDisable(name: kotlin.String, jenkinsCrumb: kotlin.String? = null) : Unit {
        val localVarResponse = postJobDisableWithHttpInfo(name = name, jenkinsCrumb = jenkinsCrumb)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /job/{name}/disable
     * 
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postJobDisableWithHttpInfo(name: kotlin.String, jenkinsCrumb: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postJobDisableRequestConfig(name = name, jenkinsCrumb = jenkinsCrumb)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postJobDisable
     *
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return RequestConfig
     */
    fun postJobDisableRequestConfig(name: kotlin.String, jenkinsCrumb: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/job/{name}/disable".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /job/{name}/enable
     * 
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postJobEnable(name: kotlin.String, jenkinsCrumb: kotlin.String? = null) : Unit {
        val localVarResponse = postJobEnableWithHttpInfo(name = name, jenkinsCrumb = jenkinsCrumb)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /job/{name}/enable
     * 
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postJobEnableWithHttpInfo(name: kotlin.String, jenkinsCrumb: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postJobEnableRequestConfig(name = name, jenkinsCrumb = jenkinsCrumb)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postJobEnable
     *
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return RequestConfig
     */
    fun postJobEnableRequestConfig(name: kotlin.String, jenkinsCrumb: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/job/{name}/enable".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /job/{name}/lastBuild/stop
     * 
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postJobLastBuildStop(name: kotlin.String, jenkinsCrumb: kotlin.String? = null) : Unit {
        val localVarResponse = postJobLastBuildStopWithHttpInfo(name = name, jenkinsCrumb = jenkinsCrumb)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /job/{name}/lastBuild/stop
     * 
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postJobLastBuildStopWithHttpInfo(name: kotlin.String, jenkinsCrumb: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postJobLastBuildStopRequestConfig(name = name, jenkinsCrumb = jenkinsCrumb)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postJobLastBuildStop
     *
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return RequestConfig
     */
    fun postJobLastBuildStopRequestConfig(name: kotlin.String, jenkinsCrumb: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/job/{name}/lastBuild/stop".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /view/{name}/config.xml
     * 
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postViewConfig(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String? = null) : Unit {
        val localVarResponse = postViewConfigWithHttpInfo(name = name, body = body, jenkinsCrumb = jenkinsCrumb)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /view/{name}/config.xml
     * 
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postViewConfigWithHttpInfo(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = postViewConfigRequestConfig(name = name, body = body, jenkinsCrumb = jenkinsCrumb)

        return request<kotlin.String, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postViewConfig
     *
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token (optional)
     * @return RequestConfig
     */
    fun postViewConfigRequestConfig(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String?) : RequestConfig<kotlin.String> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        jenkinsCrumb?.apply { localVariableHeaders["Jenkins-Crumb"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/view/{name}/config.xml".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
