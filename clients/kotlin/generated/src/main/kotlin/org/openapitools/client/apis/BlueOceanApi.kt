/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.BranchImpl
import org.openapitools.client.models.FavoriteImpl
import org.openapitools.client.models.GithubOrganization
import org.openapitools.client.models.GithubScm
import org.openapitools.client.models.MultibranchPipeline
import org.openapitools.client.models.Organisation
import org.openapitools.client.models.Pipeline
import org.openapitools.client.models.PipelineActivity
import org.openapitools.client.models.PipelineFolderImpl
import org.openapitools.client.models.PipelineImpl
import org.openapitools.client.models.PipelineRun
import org.openapitools.client.models.PipelineRunNode
import org.openapitools.client.models.PipelineStepImpl
import org.openapitools.client.models.QueueItemImpl
import org.openapitools.client.models.User

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class BlueOceanApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * 
     * Delete queue item from an organization pipeline queue
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param queue Name of the queue item
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePipelineQueueItem(organization: kotlin.String, pipeline: kotlin.String, queue: kotlin.String) : Unit {
        val localVarResponse = deletePipelineQueueItemWithHttpInfo(organization = organization, pipeline = pipeline, queue = queue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Delete queue item from an organization pipeline queue
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param queue Name of the queue item
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePipelineQueueItemWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, queue: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deletePipelineQueueItemRequestConfig(organization = organization, pipeline = pipeline, queue = queue)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePipelineQueueItem
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param queue Name of the queue item
     * @return RequestConfig
     */
    fun deletePipelineQueueItemRequestConfig(organization: kotlin.String, pipeline: kotlin.String, queue: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"queue"+"}", encodeURIComponent(queue.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve authenticated user details for an organization
     * @param organization Name of the organization
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAuthenticatedUser(organization: kotlin.String) : User {
        val localVarResponse = getAuthenticatedUserWithHttpInfo(organization = organization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve authenticated user details for an organization
     * @param organization Name of the organization
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAuthenticatedUserWithHttpInfo(organization: kotlin.String) : ApiResponse<User?> {
        val localVariableConfig = getAuthenticatedUserRequestConfig(organization = organization)

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAuthenticatedUser
     *
     * @param organization Name of the organization
     * @return RequestConfig
     */
    fun getAuthenticatedUserRequestConfig(organization: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/user/".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get a list of class names supported by a given class
     * @param propertyClass Name of the class
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getClasses(propertyClass: kotlin.String) : kotlin.String {
        val localVarResponse = getClassesWithHttpInfo(propertyClass = propertyClass)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get a list of class names supported by a given class
     * @param propertyClass Name of the class
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getClassesWithHttpInfo(propertyClass: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getClassesRequestConfig(propertyClass = propertyClass)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getClasses
     *
     * @param propertyClass Name of the class
     * @return RequestConfig
     */
    fun getClassesRequestConfig(propertyClass: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/classes/{class}".replace("{"+"class"+"}", encodeURIComponent(propertyClass.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve JSON Web Key
     * @param key Key ID received as part of JWT header field kid
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJsonWebKey(key: kotlin.Int) : kotlin.String {
        val localVarResponse = getJsonWebKeyWithHttpInfo(key = key)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve JSON Web Key
     * @param key Key ID received as part of JWT header field kid
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getJsonWebKeyWithHttpInfo(key: kotlin.Int) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getJsonWebKeyRequestConfig(key = key)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getJsonWebKey
     *
     * @param key Key ID received as part of JWT header field kid
     * @return RequestConfig
     */
    fun getJsonWebKeyRequestConfig(key: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/jwt-auth/jwks/{key}".replace("{"+"key"+"}", encodeURIComponent(key.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve JSON Web Token
     * @param expiryTimeInMins Token expiry time in minutes, default: 30 minutes (optional)
     * @param maxExpiryTimeInMins Maximum token expiry time in minutes, default: 480 minutes (optional)
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJsonWebToken(expiryTimeInMins: kotlin.Int? = null, maxExpiryTimeInMins: kotlin.Int? = null) : kotlin.String {
        val localVarResponse = getJsonWebTokenWithHttpInfo(expiryTimeInMins = expiryTimeInMins, maxExpiryTimeInMins = maxExpiryTimeInMins)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve JSON Web Token
     * @param expiryTimeInMins Token expiry time in minutes, default: 30 minutes (optional)
     * @param maxExpiryTimeInMins Maximum token expiry time in minutes, default: 480 minutes (optional)
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getJsonWebTokenWithHttpInfo(expiryTimeInMins: kotlin.Int?, maxExpiryTimeInMins: kotlin.Int?) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getJsonWebTokenRequestConfig(expiryTimeInMins = expiryTimeInMins, maxExpiryTimeInMins = maxExpiryTimeInMins)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getJsonWebToken
     *
     * @param expiryTimeInMins Token expiry time in minutes, default: 30 minutes (optional)
     * @param maxExpiryTimeInMins Maximum token expiry time in minutes, default: 480 minutes (optional)
     * @return RequestConfig
     */
    fun getJsonWebTokenRequestConfig(expiryTimeInMins: kotlin.Int?, maxExpiryTimeInMins: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expiryTimeInMins != null) {
                    put("expiryTimeInMins", listOf(expiryTimeInMins.toString()))
                }
                if (maxExpiryTimeInMins != null) {
                    put("maxExpiryTimeInMins", listOf(maxExpiryTimeInMins.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/jwt-auth/token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve organization details
     * @param organization Name of the organization
     * @return Organisation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOrganisation(organization: kotlin.String) : Organisation {
        val localVarResponse = getOrganisationWithHttpInfo(organization = organization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Organisation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve organization details
     * @param organization Name of the organization
     * @return ApiResponse<Organisation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOrganisationWithHttpInfo(organization: kotlin.String) : ApiResponse<Organisation?> {
        val localVariableConfig = getOrganisationRequestConfig(organization = organization)

        return request<Unit, Organisation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOrganisation
     *
     * @param organization Name of the organization
     * @return RequestConfig
     */
    fun getOrganisationRequestConfig(organization: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve all organizations details
     * @return kotlin.collections.List<Organisation>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOrganisations() : kotlin.collections.List<Organisation> {
        val localVarResponse = getOrganisationsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Organisation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve all organizations details
     * @return ApiResponse<kotlin.collections.List<Organisation>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOrganisationsWithHttpInfo() : ApiResponse<kotlin.collections.List<Organisation>?> {
        val localVariableConfig = getOrganisationsRequestConfig()

        return request<Unit, kotlin.collections.List<Organisation>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOrganisations
     *
     * @return RequestConfig
     */
    fun getOrganisationsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve pipeline details for an organization
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return Pipeline
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipeline(organization: kotlin.String, pipeline: kotlin.String) : Pipeline {
        val localVarResponse = getPipelineWithHttpInfo(organization = organization, pipeline = pipeline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Pipeline
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve pipeline details for an organization
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return ApiResponse<Pipeline?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String) : ApiResponse<Pipeline?> {
        val localVariableConfig = getPipelineRequestConfig(organization = organization, pipeline = pipeline)

        return request<Unit, Pipeline>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipeline
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return RequestConfig
     */
    fun getPipelineRequestConfig(organization: kotlin.String, pipeline: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve all activities details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return kotlin.collections.List<PipelineActivity>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineActivities(organization: kotlin.String, pipeline: kotlin.String) : kotlin.collections.List<PipelineActivity> {
        val localVarResponse = getPipelineActivitiesWithHttpInfo(organization = organization, pipeline = pipeline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PipelineActivity>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve all activities details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return ApiResponse<kotlin.collections.List<PipelineActivity>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineActivitiesWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String) : ApiResponse<kotlin.collections.List<PipelineActivity>?> {
        val localVariableConfig = getPipelineActivitiesRequestConfig(organization = organization, pipeline = pipeline)

        return request<Unit, kotlin.collections.List<PipelineActivity>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineActivities
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return RequestConfig
     */
    fun getPipelineActivitiesRequestConfig(organization: kotlin.String, pipeline: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve branch details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @return BranchImpl
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineBranch(organization: kotlin.String, pipeline: kotlin.String, branch: kotlin.String) : BranchImpl {
        val localVarResponse = getPipelineBranchWithHttpInfo(organization = organization, pipeline = pipeline, branch = branch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BranchImpl
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve branch details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @return ApiResponse<BranchImpl?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineBranchWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, branch: kotlin.String) : ApiResponse<BranchImpl?> {
        val localVariableConfig = getPipelineBranchRequestConfig(organization = organization, pipeline = pipeline, branch = branch)

        return request<Unit, BranchImpl>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineBranch
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @return RequestConfig
     */
    fun getPipelineBranchRequestConfig(organization: kotlin.String, pipeline: kotlin.String, branch: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"branch"+"}", encodeURIComponent(branch.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve branch run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @param run Name of the run
     * @return PipelineRun
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineBranchRun(organization: kotlin.String, pipeline: kotlin.String, branch: kotlin.String, run: kotlin.String) : PipelineRun {
        val localVarResponse = getPipelineBranchRunWithHttpInfo(organization = organization, pipeline = pipeline, branch = branch, run = run)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineRun
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve branch run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @param run Name of the run
     * @return ApiResponse<PipelineRun?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineBranchRunWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, branch: kotlin.String, run: kotlin.String) : ApiResponse<PipelineRun?> {
        val localVariableConfig = getPipelineBranchRunRequestConfig(organization = organization, pipeline = pipeline, branch = branch, run = run)

        return request<Unit, PipelineRun>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineBranchRun
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @param run Name of the run
     * @return RequestConfig
     */
    fun getPipelineBranchRunRequestConfig(organization: kotlin.String, pipeline: kotlin.String, branch: kotlin.String, run: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"branch"+"}", encodeURIComponent(branch.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve all branches details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return MultibranchPipeline
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineBranches(organization: kotlin.String, pipeline: kotlin.String) : MultibranchPipeline {
        val localVarResponse = getPipelineBranchesWithHttpInfo(organization = organization, pipeline = pipeline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MultibranchPipeline
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve all branches details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return ApiResponse<MultibranchPipeline?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineBranchesWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String) : ApiResponse<MultibranchPipeline?> {
        val localVariableConfig = getPipelineBranchesRequestConfig(organization = organization, pipeline = pipeline)

        return request<Unit, MultibranchPipeline>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineBranches
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return RequestConfig
     */
    fun getPipelineBranchesRequestConfig(organization: kotlin.String, pipeline: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve pipeline folder for an organization
     * @param organization Name of the organization
     * @param folder Name of the folder
     * @return PipelineFolderImpl
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineFolder(organization: kotlin.String, folder: kotlin.String) : PipelineFolderImpl {
        val localVarResponse = getPipelineFolderWithHttpInfo(organization = organization, folder = folder)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineFolderImpl
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve pipeline folder for an organization
     * @param organization Name of the organization
     * @param folder Name of the folder
     * @return ApiResponse<PipelineFolderImpl?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineFolderWithHttpInfo(organization: kotlin.String, folder: kotlin.String) : ApiResponse<PipelineFolderImpl?> {
        val localVariableConfig = getPipelineFolderRequestConfig(organization = organization, folder = folder)

        return request<Unit, PipelineFolderImpl>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineFolder
     *
     * @param organization Name of the organization
     * @param folder Name of the folder
     * @return RequestConfig
     */
    fun getPipelineFolderRequestConfig(organization: kotlin.String, folder: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{folder}/".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"folder"+"}", encodeURIComponent(folder.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve pipeline details for an organization folder
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     * @return PipelineImpl
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineFolderPipeline(organization: kotlin.String, pipeline: kotlin.String, folder: kotlin.String) : PipelineImpl {
        val localVarResponse = getPipelineFolderPipelineWithHttpInfo(organization = organization, pipeline = pipeline, folder = folder)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineImpl
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve pipeline details for an organization folder
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     * @return ApiResponse<PipelineImpl?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineFolderPipelineWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, folder: kotlin.String) : ApiResponse<PipelineImpl?> {
        val localVariableConfig = getPipelineFolderPipelineRequestConfig(organization = organization, pipeline = pipeline, folder = folder)

        return request<Unit, PipelineImpl>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineFolderPipeline
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     * @return RequestConfig
     */
    fun getPipelineFolderPipelineRequestConfig(organization: kotlin.String, pipeline: kotlin.String, folder: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"folder"+"}", encodeURIComponent(folder.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve queue details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return kotlin.collections.List<QueueItemImpl>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineQueue(organization: kotlin.String, pipeline: kotlin.String) : kotlin.collections.List<QueueItemImpl> {
        val localVarResponse = getPipelineQueueWithHttpInfo(organization = organization, pipeline = pipeline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<QueueItemImpl>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve queue details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return ApiResponse<kotlin.collections.List<QueueItemImpl>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineQueueWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String) : ApiResponse<kotlin.collections.List<QueueItemImpl>?> {
        val localVariableConfig = getPipelineQueueRequestConfig(organization = organization, pipeline = pipeline)

        return request<Unit, kotlin.collections.List<QueueItemImpl>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineQueue
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return RequestConfig
     */
    fun getPipelineQueueRequestConfig(organization: kotlin.String, pipeline: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return PipelineRun
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRun(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : PipelineRun {
        val localVarResponse = getPipelineRunWithHttpInfo(organization = organization, pipeline = pipeline, run = run)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineRun
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return ApiResponse<PipelineRun?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : ApiResponse<PipelineRun?> {
        val localVariableConfig = getPipelineRunRequestConfig(organization = organization, pipeline = pipeline, run = run)

        return request<Unit, PipelineRun>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRun
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return RequestConfig
     */
    fun getPipelineRunRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get log for a pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param start Start position of the log (optional)
     * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body (optional)
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRunLog(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, start: kotlin.Int? = null, download: kotlin.Boolean? = null) : kotlin.String {
        val localVarResponse = getPipelineRunLogWithHttpInfo(organization = organization, pipeline = pipeline, run = run, start = start, download = download)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get log for a pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param start Start position of the log (optional)
     * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body (optional)
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunLogWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, start: kotlin.Int?, download: kotlin.Boolean?) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getPipelineRunLogRequestConfig(organization = organization, pipeline = pipeline, run = run, start = start, download = download)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRunLog
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param start Start position of the log (optional)
     * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body (optional)
     * @return RequestConfig
     */
    fun getPipelineRunLogRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, start: kotlin.Int?, download: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (download != null) {
                    put("download", listOf(download.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @return PipelineRunNode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRunNode(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String) : PipelineRunNode {
        val localVarResponse = getPipelineRunNodeWithHttpInfo(organization = organization, pipeline = pipeline, run = run, node = node)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineRunNode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @return ApiResponse<PipelineRunNode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunNodeWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String) : ApiResponse<PipelineRunNode?> {
        val localVariableConfig = getPipelineRunNodeRequestConfig(organization = organization, pipeline = pipeline, run = run, node = node)

        return request<Unit, PipelineRunNode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRunNode
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @return RequestConfig
     */
    fun getPipelineRunNodeRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())).replace("{"+"node"+"}", encodeURIComponent(node.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     * @return PipelineStepImpl
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRunNodeStep(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String, step: kotlin.String) : PipelineStepImpl {
        val localVarResponse = getPipelineRunNodeStepWithHttpInfo(organization = organization, pipeline = pipeline, run = run, node = node, step = step)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineStepImpl
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     * @return ApiResponse<PipelineStepImpl?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunNodeStepWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String, step: kotlin.String) : ApiResponse<PipelineStepImpl?> {
        val localVariableConfig = getPipelineRunNodeStepRequestConfig(organization = organization, pipeline = pipeline, run = run, node = node, step = step)

        return request<Unit, PipelineStepImpl>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRunNodeStep
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     * @return RequestConfig
     */
    fun getPipelineRunNodeStepRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String, step: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())).replace("{"+"node"+"}", encodeURIComponent(node.toString())).replace("{"+"step"+"}", encodeURIComponent(step.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get log for a pipeline run node step
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRunNodeStepLog(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String, step: kotlin.String) : kotlin.String {
        val localVarResponse = getPipelineRunNodeStepLogWithHttpInfo(organization = organization, pipeline = pipeline, run = run, node = node, step = step)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get log for a pipeline run node step
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunNodeStepLogWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String, step: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getPipelineRunNodeStepLogRequestConfig(organization = organization, pipeline = pipeline, run = run, node = node, step = step)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRunNodeStepLog
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     * @return RequestConfig
     */
    fun getPipelineRunNodeStepLogRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String, step: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())).replace("{"+"node"+"}", encodeURIComponent(node.toString())).replace("{"+"step"+"}", encodeURIComponent(step.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve run node steps details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @return kotlin.collections.List<PipelineStepImpl>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRunNodeSteps(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String) : kotlin.collections.List<PipelineStepImpl> {
        val localVarResponse = getPipelineRunNodeStepsWithHttpInfo(organization = organization, pipeline = pipeline, run = run, node = node)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PipelineStepImpl>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve run node steps details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @return ApiResponse<kotlin.collections.List<PipelineStepImpl>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunNodeStepsWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String) : ApiResponse<kotlin.collections.List<PipelineStepImpl>?> {
        val localVariableConfig = getPipelineRunNodeStepsRequestConfig(organization = organization, pipeline = pipeline, run = run, node = node)

        return request<Unit, kotlin.collections.List<PipelineStepImpl>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRunNodeSteps
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @return RequestConfig
     */
    fun getPipelineRunNodeStepsRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, node: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())).replace("{"+"node"+"}", encodeURIComponent(node.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve run nodes details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return kotlin.collections.List<PipelineRunNode>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRunNodes(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : kotlin.collections.List<PipelineRunNode> {
        val localVarResponse = getPipelineRunNodesWithHttpInfo(organization = organization, pipeline = pipeline, run = run)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PipelineRunNode>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve run nodes details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return ApiResponse<kotlin.collections.List<PipelineRunNode>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunNodesWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : ApiResponse<kotlin.collections.List<PipelineRunNode>?> {
        val localVariableConfig = getPipelineRunNodesRequestConfig(organization = organization, pipeline = pipeline, run = run)

        return request<Unit, kotlin.collections.List<PipelineRunNode>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRunNodes
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return RequestConfig
     */
    fun getPipelineRunNodesRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve all runs details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return kotlin.collections.List<PipelineRun>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelineRuns(organization: kotlin.String, pipeline: kotlin.String) : kotlin.collections.List<PipelineRun> {
        val localVarResponse = getPipelineRunsWithHttpInfo(organization = organization, pipeline = pipeline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PipelineRun>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve all runs details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return ApiResponse<kotlin.collections.List<PipelineRun>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelineRunsWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String) : ApiResponse<kotlin.collections.List<PipelineRun>?> {
        val localVariableConfig = getPipelineRunsRequestConfig(organization = organization, pipeline = pipeline)

        return request<Unit, kotlin.collections.List<PipelineRun>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelineRuns
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return RequestConfig
     */
    fun getPipelineRunsRequestConfig(organization: kotlin.String, pipeline: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve all pipelines details for an organization
     * @param organization Name of the organization
     * @return kotlin.collections.List<Pipeline>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPipelines(organization: kotlin.String) : kotlin.collections.List<Pipeline> {
        val localVarResponse = getPipelinesWithHttpInfo(organization = organization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Pipeline>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve all pipelines details for an organization
     * @param organization Name of the organization
     * @return ApiResponse<kotlin.collections.List<Pipeline>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPipelinesWithHttpInfo(organization: kotlin.String) : ApiResponse<kotlin.collections.List<Pipeline>?> {
        val localVariableConfig = getPipelinesRequestConfig(organization = organization)

        return request<Unit, kotlin.collections.List<Pipeline>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPipelines
     *
     * @param organization Name of the organization
     * @return RequestConfig
     */
    fun getPipelinesRequestConfig(organization: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/pipelines/".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve SCM details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @return GithubScm
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSCM(organization: kotlin.String, scm: kotlin.String) : GithubScm {
        val localVarResponse = getSCMWithHttpInfo(organization = organization, scm = scm)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GithubScm
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve SCM details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @return ApiResponse<GithubScm?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSCMWithHttpInfo(organization: kotlin.String, scm: kotlin.String) : ApiResponse<GithubScm?> {
        val localVariableConfig = getSCMRequestConfig(organization = organization, scm = scm)

        return request<Unit, GithubScm>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSCM
     *
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @return RequestConfig
     */
    fun getSCMRequestConfig(organization: kotlin.String, scm: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/scm/{scm}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"scm"+"}", encodeURIComponent(scm.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve SCM organization repositories details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param credentialId Credential ID (optional)
     * @param pageSize Number of items in a page (optional)
     * @param pageNumber Page number (optional)
     * @return kotlin.collections.List<GithubOrganization>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSCMOrganisationRepositories(organization: kotlin.String, scm: kotlin.String, scmOrganisation: kotlin.String, credentialId: kotlin.String? = null, pageSize: kotlin.Int? = null, pageNumber: kotlin.Int? = null) : kotlin.collections.List<GithubOrganization> {
        val localVarResponse = getSCMOrganisationRepositoriesWithHttpInfo(organization = organization, scm = scm, scmOrganisation = scmOrganisation, credentialId = credentialId, pageSize = pageSize, pageNumber = pageNumber)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<GithubOrganization>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve SCM organization repositories details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param credentialId Credential ID (optional)
     * @param pageSize Number of items in a page (optional)
     * @param pageNumber Page number (optional)
     * @return ApiResponse<kotlin.collections.List<GithubOrganization>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSCMOrganisationRepositoriesWithHttpInfo(organization: kotlin.String, scm: kotlin.String, scmOrganisation: kotlin.String, credentialId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?) : ApiResponse<kotlin.collections.List<GithubOrganization>?> {
        val localVariableConfig = getSCMOrganisationRepositoriesRequestConfig(organization = organization, scm = scm, scmOrganisation = scmOrganisation, credentialId = credentialId, pageSize = pageSize, pageNumber = pageNumber)

        return request<Unit, kotlin.collections.List<GithubOrganization>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSCMOrganisationRepositories
     *
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param credentialId Credential ID (optional)
     * @param pageSize Number of items in a page (optional)
     * @param pageNumber Page number (optional)
     * @return RequestConfig
     */
    fun getSCMOrganisationRepositoriesRequestConfig(organization: kotlin.String, scm: kotlin.String, scmOrganisation: kotlin.String, credentialId: kotlin.String?, pageSize: kotlin.Int?, pageNumber: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (credentialId != null) {
                    put("credentialId", listOf(credentialId.toString()))
                }
                if (pageSize != null) {
                    put("pageSize", listOf(pageSize.toString()))
                }
                if (pageNumber != null) {
                    put("pageNumber", listOf(pageNumber.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"scm"+"}", encodeURIComponent(scm.toString())).replace("{"+"scmOrganisation"+"}", encodeURIComponent(scmOrganisation.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve SCM organization repository details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param repository Name of the SCM repository
     * @param credentialId Credential ID (optional)
     * @return kotlin.collections.List<GithubOrganization>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSCMOrganisationRepository(organization: kotlin.String, scm: kotlin.String, scmOrganisation: kotlin.String, repository: kotlin.String, credentialId: kotlin.String? = null) : kotlin.collections.List<GithubOrganization> {
        val localVarResponse = getSCMOrganisationRepositoryWithHttpInfo(organization = organization, scm = scm, scmOrganisation = scmOrganisation, repository = repository, credentialId = credentialId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<GithubOrganization>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve SCM organization repository details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param repository Name of the SCM repository
     * @param credentialId Credential ID (optional)
     * @return ApiResponse<kotlin.collections.List<GithubOrganization>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSCMOrganisationRepositoryWithHttpInfo(organization: kotlin.String, scm: kotlin.String, scmOrganisation: kotlin.String, repository: kotlin.String, credentialId: kotlin.String?) : ApiResponse<kotlin.collections.List<GithubOrganization>?> {
        val localVariableConfig = getSCMOrganisationRepositoryRequestConfig(organization = organization, scm = scm, scmOrganisation = scmOrganisation, repository = repository, credentialId = credentialId)

        return request<Unit, kotlin.collections.List<GithubOrganization>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSCMOrganisationRepository
     *
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param repository Name of the SCM repository
     * @param credentialId Credential ID (optional)
     * @return RequestConfig
     */
    fun getSCMOrganisationRepositoryRequestConfig(organization: kotlin.String, scm: kotlin.String, scmOrganisation: kotlin.String, repository: kotlin.String, credentialId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (credentialId != null) {
                    put("credentialId", listOf(credentialId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"scm"+"}", encodeURIComponent(scm.toString())).replace("{"+"scmOrganisation"+"}", encodeURIComponent(scmOrganisation.toString())).replace("{"+"repository"+"}", encodeURIComponent(repository.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve SCM organizations details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param credentialId Credential ID (optional)
     * @return kotlin.collections.List<GithubOrganization>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSCMOrganisations(organization: kotlin.String, scm: kotlin.String, credentialId: kotlin.String? = null) : kotlin.collections.List<GithubOrganization> {
        val localVarResponse = getSCMOrganisationsWithHttpInfo(organization = organization, scm = scm, credentialId = credentialId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<GithubOrganization>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve SCM organizations details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param credentialId Credential ID (optional)
     * @return ApiResponse<kotlin.collections.List<GithubOrganization>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSCMOrganisationsWithHttpInfo(organization: kotlin.String, scm: kotlin.String, credentialId: kotlin.String?) : ApiResponse<kotlin.collections.List<GithubOrganization>?> {
        val localVariableConfig = getSCMOrganisationsRequestConfig(organization = organization, scm = scm, credentialId = credentialId)

        return request<Unit, kotlin.collections.List<GithubOrganization>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSCMOrganisations
     *
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param credentialId Credential ID (optional)
     * @return RequestConfig
     */
    fun getSCMOrganisationsRequestConfig(organization: kotlin.String, scm: kotlin.String, credentialId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (credentialId != null) {
                    put("credentialId", listOf(credentialId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/scm/{scm}/organizations".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"scm"+"}", encodeURIComponent(scm.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve user details for an organization
     * @param organization Name of the organization
     * @param user Name of the user
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUser(organization: kotlin.String, user: kotlin.String) : User {
        val localVarResponse = getUserWithHttpInfo(organization = organization, user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve user details for an organization
     * @param organization Name of the organization
     * @param user Name of the user
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserWithHttpInfo(organization: kotlin.String, user: kotlin.String) : ApiResponse<User?> {
        val localVariableConfig = getUserRequestConfig(organization = organization, user = user)

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUser
     *
     * @param organization Name of the organization
     * @param user Name of the user
     * @return RequestConfig
     */
    fun getUserRequestConfig(organization: kotlin.String, user: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/users/{user}".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"user"+"}", encodeURIComponent(user.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve user favorites details for an organization
     * @param user Name of the user
     * @return kotlin.collections.List<FavoriteImpl>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUserFavorites(user: kotlin.String) : kotlin.collections.List<FavoriteImpl> {
        val localVarResponse = getUserFavoritesWithHttpInfo(user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<FavoriteImpl>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve user favorites details for an organization
     * @param user Name of the user
     * @return ApiResponse<kotlin.collections.List<FavoriteImpl>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUserFavoritesWithHttpInfo(user: kotlin.String) : ApiResponse<kotlin.collections.List<FavoriteImpl>?> {
        val localVariableConfig = getUserFavoritesRequestConfig(user = user)

        return request<Unit, kotlin.collections.List<FavoriteImpl>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUserFavorites
     *
     * @param user Name of the user
     * @return RequestConfig
     */
    fun getUserFavoritesRequestConfig(user: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/users/{user}/favorites".replace("{"+"user"+"}", encodeURIComponent(user.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Retrieve users details for an organization
     * @param organization Name of the organization
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getUsers(organization: kotlin.String) : User {
        val localVarResponse = getUsersWithHttpInfo(organization = organization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Retrieve users details for an organization
     * @param organization Name of the organization
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getUsersWithHttpInfo(organization: kotlin.String) : ApiResponse<User?> {
        val localVariableConfig = getUsersRequestConfig(organization = organization)

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getUsers
     *
     * @param organization Name of the organization
     * @return RequestConfig
     */
    fun getUsersRequestConfig(organization: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/organizations/{organization}/users/".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Replay an organization pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return QueueItemImpl
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postPipelineRun(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : QueueItemImpl {
        val localVarResponse = postPipelineRunWithHttpInfo(organization = organization, pipeline = pipeline, run = run)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueItemImpl
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Replay an organization pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return ApiResponse<QueueItemImpl?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postPipelineRunWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : ApiResponse<QueueItemImpl?> {
        val localVariableConfig = postPipelineRunRequestConfig(organization = organization, pipeline = pipeline, run = run)

        return request<Unit, QueueItemImpl>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postPipelineRun
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @return RequestConfig
     */
    fun postPipelineRunRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Start a build for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return QueueItemImpl
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postPipelineRuns(organization: kotlin.String, pipeline: kotlin.String) : QueueItemImpl {
        val localVarResponse = postPipelineRunsWithHttpInfo(organization = organization, pipeline = pipeline)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueItemImpl
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Start a build for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return ApiResponse<QueueItemImpl?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postPipelineRunsWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String) : ApiResponse<QueueItemImpl?> {
        val localVariableConfig = postPipelineRunsRequestConfig(organization = organization, pipeline = pipeline)

        return request<Unit, QueueItemImpl>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postPipelineRuns
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @return RequestConfig
     */
    fun postPipelineRunsRequestConfig(organization: kotlin.String, pipeline: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Favorite/unfavorite a pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     * @return FavoriteImpl
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putPipelineFavorite(organization: kotlin.String, pipeline: kotlin.String, body: kotlin.Boolean) : FavoriteImpl {
        val localVarResponse = putPipelineFavoriteWithHttpInfo(organization = organization, pipeline = pipeline, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FavoriteImpl
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Favorite/unfavorite a pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     * @return ApiResponse<FavoriteImpl?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun putPipelineFavoriteWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, body: kotlin.Boolean) : ApiResponse<FavoriteImpl?> {
        val localVariableConfig = putPipelineFavoriteRequestConfig(organization = organization, pipeline = pipeline, body = body)

        return request<kotlin.Boolean, FavoriteImpl>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putPipelineFavorite
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     * @return RequestConfig
     */
    fun putPipelineFavoriteRequestConfig(organization: kotlin.String, pipeline: kotlin.String, body: kotlin.Boolean) : RequestConfig<kotlin.Boolean> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Stop a build of an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param blocking Set to true to make blocking stop, default: false (optional)
     * @param timeOutInSecs Timeout in seconds, default: 10 seconds (optional)
     * @return PipelineRun
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putPipelineRun(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, blocking: kotlin.String? = null, timeOutInSecs: kotlin.Int? = null) : PipelineRun {
        val localVarResponse = putPipelineRunWithHttpInfo(organization = organization, pipeline = pipeline, run = run, blocking = blocking, timeOutInSecs = timeOutInSecs)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PipelineRun
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Stop a build of an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param blocking Set to true to make blocking stop, default: false (optional)
     * @param timeOutInSecs Timeout in seconds, default: 10 seconds (optional)
     * @return ApiResponse<PipelineRun?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun putPipelineRunWithHttpInfo(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, blocking: kotlin.String?, timeOutInSecs: kotlin.Int?) : ApiResponse<PipelineRun?> {
        val localVariableConfig = putPipelineRunRequestConfig(organization = organization, pipeline = pipeline, run = run, blocking = blocking, timeOutInSecs = timeOutInSecs)

        return request<Unit, PipelineRun>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putPipelineRun
     *
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param blocking Set to true to make blocking stop, default: false (optional)
     * @param timeOutInSecs Timeout in seconds, default: 10 seconds (optional)
     * @return RequestConfig
     */
    fun putPipelineRunRequestConfig(organization: kotlin.String, pipeline: kotlin.String, run: kotlin.String, blocking: kotlin.String?, timeOutInSecs: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (blocking != null) {
                    put("blocking", listOf(blocking.toString()))
                }
                if (timeOutInSecs != null) {
                    put("timeOutInSecs", listOf(timeOutInSecs.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop".replace("{"+"organization"+"}", encodeURIComponent(organization.toString())).replace("{"+"pipeline"+"}", encodeURIComponent(pipeline.toString())).replace("{"+"run"+"}", encodeURIComponent(run.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Search for any resource details
     * @param q Query string
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun search(q: kotlin.String) : kotlin.String {
        val localVarResponse = searchWithHttpInfo(q = q)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Search for any resource details
     * @param q Query string
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchWithHttpInfo(q: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = searchRequestConfig(q = q)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation search
     *
     * @param q Query string
     * @return RequestConfig
     */
    fun searchRequestConfig(q: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("q", listOf(q.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/search/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get classes details
     * @param q Query string containing an array of class names
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchClasses(q: kotlin.String) : kotlin.String {
        val localVarResponse = searchClassesWithHttpInfo(q = q)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get classes details
     * @param q Query string containing an array of class names
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchClassesWithHttpInfo(q: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = searchClassesRequestConfig(q = q)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchClasses
     *
     * @param q Query string containing an array of class names
     * @return RequestConfig
     */
    fun searchClassesRequestConfig(q: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("q", listOf(q.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/blue/rest/classes/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
