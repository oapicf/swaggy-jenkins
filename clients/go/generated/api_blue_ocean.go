/*
Swaggy Jenkins

Jenkins API clients generated from Swagger / Open API specification

API version: 2.0.1-pre.0
Contact: blah+oapicf@cliffano.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BlueOceanAPIService BlueOceanAPI service
type BlueOceanAPIService service

type ApiDeletePipelineQueueItemRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	queue string
}

func (r ApiDeletePipelineQueueItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePipelineQueueItemExecute(r)
}

/*
DeletePipelineQueueItem Method for DeletePipelineQueueItem

Delete queue item from an organization pipeline queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param queue Name of the queue item
 @return ApiDeletePipelineQueueItemRequest
*/
func (a *BlueOceanAPIService) DeletePipelineQueueItem(ctx context.Context, organization string, pipeline string, queue string) ApiDeletePipelineQueueItemRequest {
	return ApiDeletePipelineQueueItemRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		queue: queue,
	}
}

// Execute executes the request
func (a *BlueOceanAPIService) DeletePipelineQueueItemExecute(r ApiDeletePipelineQueueItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.DeletePipelineQueueItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"queue"+"}", url.PathEscape(parameterValueToString(r.queue, "queue")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthenticatedUserRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
}

func (r ApiGetAuthenticatedUserRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.GetAuthenticatedUserExecute(r)
}

/*
GetAuthenticatedUser Method for GetAuthenticatedUser

Retrieve authenticated user details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @return ApiGetAuthenticatedUserRequest
*/
func (a *BlueOceanAPIService) GetAuthenticatedUser(ctx context.Context, organization string) ApiGetAuthenticatedUserRequest {
	return ApiGetAuthenticatedUserRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
	}
}

// Execute executes the request
//  @return User
func (a *BlueOceanAPIService) GetAuthenticatedUserExecute(r ApiGetAuthenticatedUserRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetAuthenticatedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/user/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClassesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	class string
}

func (r ApiGetClassesRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetClassesExecute(r)
}

/*
GetClasses Method for GetClasses

Get a list of class names supported by a given class

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param class Name of the class
 @return ApiGetClassesRequest
*/
func (a *BlueOceanAPIService) GetClasses(ctx context.Context, class string) ApiGetClassesRequest {
	return ApiGetClassesRequest{
		ApiService: a,
		ctx: ctx,
		class: class,
	}
}

// Execute executes the request
//  @return string
func (a *BlueOceanAPIService) GetClassesExecute(r ApiGetClassesRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/classes/{class}"
	localVarPath = strings.Replace(localVarPath, "{"+"class"+"}", url.PathEscape(parameterValueToString(r.class, "class")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJsonWebKeyRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	key int32
}

func (r ApiGetJsonWebKeyRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetJsonWebKeyExecute(r)
}

/*
GetJsonWebKey Method for GetJsonWebKey

Retrieve JSON Web Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param key Key ID received as part of JWT header field kid
 @return ApiGetJsonWebKeyRequest
*/
func (a *BlueOceanAPIService) GetJsonWebKey(ctx context.Context, key int32) ApiGetJsonWebKeyRequest {
	return ApiGetJsonWebKeyRequest{
		ApiService: a,
		ctx: ctx,
		key: key,
	}
}

// Execute executes the request
//  @return string
func (a *BlueOceanAPIService) GetJsonWebKeyExecute(r ApiGetJsonWebKeyRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetJsonWebKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jwt-auth/jwks/{key}"
	localVarPath = strings.Replace(localVarPath, "{"+"key"+"}", url.PathEscape(parameterValueToString(r.key, "key")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJsonWebTokenRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	expiryTimeInMins *int32
	maxExpiryTimeInMins *int32
}

// Token expiry time in minutes, default: 30 minutes
func (r ApiGetJsonWebTokenRequest) ExpiryTimeInMins(expiryTimeInMins int32) ApiGetJsonWebTokenRequest {
	r.expiryTimeInMins = &expiryTimeInMins
	return r
}

// Maximum token expiry time in minutes, default: 480 minutes
func (r ApiGetJsonWebTokenRequest) MaxExpiryTimeInMins(maxExpiryTimeInMins int32) ApiGetJsonWebTokenRequest {
	r.maxExpiryTimeInMins = &maxExpiryTimeInMins
	return r
}

func (r ApiGetJsonWebTokenRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetJsonWebTokenExecute(r)
}

/*
GetJsonWebToken Method for GetJsonWebToken

Retrieve JSON Web Token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetJsonWebTokenRequest
*/
func (a *BlueOceanAPIService) GetJsonWebToken(ctx context.Context) ApiGetJsonWebTokenRequest {
	return ApiGetJsonWebTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BlueOceanAPIService) GetJsonWebTokenExecute(r ApiGetJsonWebTokenRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetJsonWebToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jwt-auth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expiryTimeInMins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiryTimeInMins", r.expiryTimeInMins, "")
	}
	if r.maxExpiryTimeInMins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxExpiryTimeInMins", r.maxExpiryTimeInMins, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganisationRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
}

func (r ApiGetOrganisationRequest) Execute() (*Organisation, *http.Response, error) {
	return r.ApiService.GetOrganisationExecute(r)
}

/*
GetOrganisation Method for GetOrganisation

Retrieve organization details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @return ApiGetOrganisationRequest
*/
func (a *BlueOceanAPIService) GetOrganisation(ctx context.Context, organization string) ApiGetOrganisationRequest {
	return ApiGetOrganisationRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
	}
}

// Execute executes the request
//  @return Organisation
func (a *BlueOceanAPIService) GetOrganisationExecute(r ApiGetOrganisationRequest) (*Organisation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetOrganisation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganisationsRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
}

func (r ApiGetOrganisationsRequest) Execute() ([]Organisation, *http.Response, error) {
	return r.ApiService.GetOrganisationsExecute(r)
}

/*
GetOrganisations Method for GetOrganisations

Retrieve all organizations details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrganisationsRequest
*/
func (a *BlueOceanAPIService) GetOrganisations(ctx context.Context) ApiGetOrganisationsRequest {
	return ApiGetOrganisationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Organisation
func (a *BlueOceanAPIService) GetOrganisationsExecute(r ApiGetOrganisationsRequest) ([]Organisation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetOrganisations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
}

func (r ApiGetPipelineRequest) Execute() (*Pipeline, *http.Response, error) {
	return r.ApiService.GetPipelineExecute(r)
}

/*
GetPipeline Method for GetPipeline

Retrieve pipeline details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @return ApiGetPipelineRequest
*/
func (a *BlueOceanAPIService) GetPipeline(ctx context.Context, organization string, pipeline string) ApiGetPipelineRequest {
	return ApiGetPipelineRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return Pipeline
func (a *BlueOceanAPIService) GetPipelineExecute(r ApiGetPipelineRequest) (*Pipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineActivitiesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
}

func (r ApiGetPipelineActivitiesRequest) Execute() ([]PipelineActivity, *http.Response, error) {
	return r.ApiService.GetPipelineActivitiesExecute(r)
}

/*
GetPipelineActivities Method for GetPipelineActivities

Retrieve all activities details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @return ApiGetPipelineActivitiesRequest
*/
func (a *BlueOceanAPIService) GetPipelineActivities(ctx context.Context, organization string, pipeline string) ApiGetPipelineActivitiesRequest {
	return ApiGetPipelineActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return []PipelineActivity
func (a *BlueOceanAPIService) GetPipelineActivitiesExecute(r ApiGetPipelineActivitiesRequest) ([]PipelineActivity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PipelineActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineBranchRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	branch string
}

func (r ApiGetPipelineBranchRequest) Execute() (*BranchImpl, *http.Response, error) {
	return r.ApiService.GetPipelineBranchExecute(r)
}

/*
GetPipelineBranch Method for GetPipelineBranch

Retrieve branch details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param branch Name of the branch
 @return ApiGetPipelineBranchRequest
*/
func (a *BlueOceanAPIService) GetPipelineBranch(ctx context.Context, organization string, pipeline string, branch string) ApiGetPipelineBranchRequest {
	return ApiGetPipelineBranchRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		branch: branch,
	}
}

// Execute executes the request
//  @return BranchImpl
func (a *BlueOceanAPIService) GetPipelineBranchExecute(r ApiGetPipelineBranchRequest) (*BranchImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BranchImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineBranch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineBranchRunRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	branch string
	run string
}

func (r ApiGetPipelineBranchRunRequest) Execute() (*PipelineRun, *http.Response, error) {
	return r.ApiService.GetPipelineBranchRunExecute(r)
}

/*
GetPipelineBranchRun Method for GetPipelineBranchRun

Retrieve branch run details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param branch Name of the branch
 @param run Name of the run
 @return ApiGetPipelineBranchRunRequest
*/
func (a *BlueOceanAPIService) GetPipelineBranchRun(ctx context.Context, organization string, pipeline string, branch string, run string) ApiGetPipelineBranchRunRequest {
	return ApiGetPipelineBranchRunRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		branch: branch,
		run: run,
	}
}

// Execute executes the request
//  @return PipelineRun
func (a *BlueOceanAPIService) GetPipelineBranchRunExecute(r ApiGetPipelineBranchRunRequest) (*PipelineRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineBranchRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"branch"+"}", url.PathEscape(parameterValueToString(r.branch, "branch")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineBranchesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
}

func (r ApiGetPipelineBranchesRequest) Execute() (*MultibranchPipeline, *http.Response, error) {
	return r.ApiService.GetPipelineBranchesExecute(r)
}

/*
GetPipelineBranches Method for GetPipelineBranches

Retrieve all branches details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @return ApiGetPipelineBranchesRequest
*/
func (a *BlueOceanAPIService) GetPipelineBranches(ctx context.Context, organization string, pipeline string) ApiGetPipelineBranchesRequest {
	return ApiGetPipelineBranchesRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return MultibranchPipeline
func (a *BlueOceanAPIService) GetPipelineBranchesExecute(r ApiGetPipelineBranchesRequest) (*MultibranchPipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultibranchPipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineBranches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineFolderRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	folder string
}

func (r ApiGetPipelineFolderRequest) Execute() (*PipelineFolderImpl, *http.Response, error) {
	return r.ApiService.GetPipelineFolderExecute(r)
}

/*
GetPipelineFolder Method for GetPipelineFolder

Retrieve pipeline folder for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param folder Name of the folder
 @return ApiGetPipelineFolderRequest
*/
func (a *BlueOceanAPIService) GetPipelineFolder(ctx context.Context, organization string, folder string) ApiGetPipelineFolderRequest {
	return ApiGetPipelineFolderRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		folder: folder,
	}
}

// Execute executes the request
//  @return PipelineFolderImpl
func (a *BlueOceanAPIService) GetPipelineFolderExecute(r ApiGetPipelineFolderRequest) (*PipelineFolderImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineFolderImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{folder}/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folder"+"}", url.PathEscape(parameterValueToString(r.folder, "folder")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineFolderPipelineRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	folder string
}

func (r ApiGetPipelineFolderPipelineRequest) Execute() (*PipelineImpl, *http.Response, error) {
	return r.ApiService.GetPipelineFolderPipelineExecute(r)
}

/*
GetPipelineFolderPipeline Method for GetPipelineFolderPipeline

Retrieve pipeline details for an organization folder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param folder Name of the folder
 @return ApiGetPipelineFolderPipelineRequest
*/
func (a *BlueOceanAPIService) GetPipelineFolderPipeline(ctx context.Context, organization string, pipeline string, folder string) ApiGetPipelineFolderPipelineRequest {
	return ApiGetPipelineFolderPipelineRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		folder: folder,
	}
}

// Execute executes the request
//  @return PipelineImpl
func (a *BlueOceanAPIService) GetPipelineFolderPipelineExecute(r ApiGetPipelineFolderPipelineRequest) (*PipelineImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineFolderPipeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folder"+"}", url.PathEscape(parameterValueToString(r.folder, "folder")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineQueueRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
}

func (r ApiGetPipelineQueueRequest) Execute() ([]QueueItemImpl, *http.Response, error) {
	return r.ApiService.GetPipelineQueueExecute(r)
}

/*
GetPipelineQueue Method for GetPipelineQueue

Retrieve queue details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @return ApiGetPipelineQueueRequest
*/
func (a *BlueOceanAPIService) GetPipelineQueue(ctx context.Context, organization string, pipeline string) ApiGetPipelineQueueRequest {
	return ApiGetPipelineQueueRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return []QueueItemImpl
func (a *BlueOceanAPIService) GetPipelineQueueExecute(r ApiGetPipelineQueueRequest) ([]QueueItemImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []QueueItemImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
}

func (r ApiGetPipelineRunRequest) Execute() (*PipelineRun, *http.Response, error) {
	return r.ApiService.GetPipelineRunExecute(r)
}

/*
GetPipelineRun Method for GetPipelineRun

Retrieve run details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @return ApiGetPipelineRunRequest
*/
func (a *BlueOceanAPIService) GetPipelineRun(ctx context.Context, organization string, pipeline string, run string) ApiGetPipelineRunRequest {
	return ApiGetPipelineRunRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return PipelineRun
func (a *BlueOceanAPIService) GetPipelineRunExecute(r ApiGetPipelineRunRequest) (*PipelineRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunLogRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
	start *int32
	download *bool
}

// Start position of the log
func (r ApiGetPipelineRunLogRequest) Start(start int32) ApiGetPipelineRunLogRequest {
	r.start = &start
	return r
}

// Set to true in order to download the file, otherwise it&#39;s passed as a response body
func (r ApiGetPipelineRunLogRequest) Download(download bool) ApiGetPipelineRunLogRequest {
	r.download = &download
	return r
}

func (r ApiGetPipelineRunLogRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetPipelineRunLogExecute(r)
}

/*
GetPipelineRunLog Method for GetPipelineRunLog

Get log for a pipeline run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @return ApiGetPipelineRunLogRequest
*/
func (a *BlueOceanAPIService) GetPipelineRunLog(ctx context.Context, organization string, pipeline string, run string) ApiGetPipelineRunLogRequest {
	return ApiGetPipelineRunLogRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return string
func (a *BlueOceanAPIService) GetPipelineRunLogExecute(r ApiGetPipelineRunLogRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRunLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.download != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "download", r.download, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunNodeRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
	node string
}

func (r ApiGetPipelineRunNodeRequest) Execute() (*PipelineRunNode, *http.Response, error) {
	return r.ApiService.GetPipelineRunNodeExecute(r)
}

/*
GetPipelineRunNode Method for GetPipelineRunNode

Retrieve run node details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @param node Name of the node
 @return ApiGetPipelineRunNodeRequest
*/
func (a *BlueOceanAPIService) GetPipelineRunNode(ctx context.Context, organization string, pipeline string, run string, node string) ApiGetPipelineRunNodeRequest {
	return ApiGetPipelineRunNodeRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
		node: node,
	}
}

// Execute executes the request
//  @return PipelineRunNode
func (a *BlueOceanAPIService) GetPipelineRunNodeExecute(r ApiGetPipelineRunNodeRequest) (*PipelineRunNode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineRunNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRunNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunNodeStepRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
	node string
	step string
}

func (r ApiGetPipelineRunNodeStepRequest) Execute() (*PipelineStepImpl, *http.Response, error) {
	return r.ApiService.GetPipelineRunNodeStepExecute(r)
}

/*
GetPipelineRunNodeStep Method for GetPipelineRunNodeStep

Retrieve run node details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @param node Name of the node
 @param step Name of the step
 @return ApiGetPipelineRunNodeStepRequest
*/
func (a *BlueOceanAPIService) GetPipelineRunNodeStep(ctx context.Context, organization string, pipeline string, run string, node string, step string) ApiGetPipelineRunNodeStepRequest {
	return ApiGetPipelineRunNodeStepRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
		node: node,
		step: step,
	}
}

// Execute executes the request
//  @return PipelineStepImpl
func (a *BlueOceanAPIService) GetPipelineRunNodeStepExecute(r ApiGetPipelineRunNodeStepRequest) (*PipelineStepImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineStepImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRunNodeStep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step"+"}", url.PathEscape(parameterValueToString(r.step, "step")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunNodeStepLogRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
	node string
	step string
}

func (r ApiGetPipelineRunNodeStepLogRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetPipelineRunNodeStepLogExecute(r)
}

/*
GetPipelineRunNodeStepLog Method for GetPipelineRunNodeStepLog

Get log for a pipeline run node step

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @param node Name of the node
 @param step Name of the step
 @return ApiGetPipelineRunNodeStepLogRequest
*/
func (a *BlueOceanAPIService) GetPipelineRunNodeStepLog(ctx context.Context, organization string, pipeline string, run string, node string, step string) ApiGetPipelineRunNodeStepLogRequest {
	return ApiGetPipelineRunNodeStepLogRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
		node: node,
		step: step,
	}
}

// Execute executes the request
//  @return string
func (a *BlueOceanAPIService) GetPipelineRunNodeStepLogExecute(r ApiGetPipelineRunNodeStepLogRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRunNodeStepLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step"+"}", url.PathEscape(parameterValueToString(r.step, "step")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunNodeStepsRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
	node string
}

func (r ApiGetPipelineRunNodeStepsRequest) Execute() ([]PipelineStepImpl, *http.Response, error) {
	return r.ApiService.GetPipelineRunNodeStepsExecute(r)
}

/*
GetPipelineRunNodeSteps Method for GetPipelineRunNodeSteps

Retrieve run node steps details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @param node Name of the node
 @return ApiGetPipelineRunNodeStepsRequest
*/
func (a *BlueOceanAPIService) GetPipelineRunNodeSteps(ctx context.Context, organization string, pipeline string, run string, node string) ApiGetPipelineRunNodeStepsRequest {
	return ApiGetPipelineRunNodeStepsRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
		node: node,
	}
}

// Execute executes the request
//  @return []PipelineStepImpl
func (a *BlueOceanAPIService) GetPipelineRunNodeStepsExecute(r ApiGetPipelineRunNodeStepsRequest) ([]PipelineStepImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PipelineStepImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRunNodeSteps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node"+"}", url.PathEscape(parameterValueToString(r.node, "node")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunNodesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
}

func (r ApiGetPipelineRunNodesRequest) Execute() ([]PipelineRunNode, *http.Response, error) {
	return r.ApiService.GetPipelineRunNodesExecute(r)
}

/*
GetPipelineRunNodes Method for GetPipelineRunNodes

Retrieve run nodes details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @return ApiGetPipelineRunNodesRequest
*/
func (a *BlueOceanAPIService) GetPipelineRunNodes(ctx context.Context, organization string, pipeline string, run string) ApiGetPipelineRunNodesRequest {
	return ApiGetPipelineRunNodesRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return []PipelineRunNode
func (a *BlueOceanAPIService) GetPipelineRunNodesExecute(r ApiGetPipelineRunNodesRequest) ([]PipelineRunNode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PipelineRunNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRunNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelineRunsRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
}

func (r ApiGetPipelineRunsRequest) Execute() ([]PipelineRun, *http.Response, error) {
	return r.ApiService.GetPipelineRunsExecute(r)
}

/*
GetPipelineRuns Method for GetPipelineRuns

Retrieve all runs details for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @return ApiGetPipelineRunsRequest
*/
func (a *BlueOceanAPIService) GetPipelineRuns(ctx context.Context, organization string, pipeline string) ApiGetPipelineRunsRequest {
	return ApiGetPipelineRunsRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return []PipelineRun
func (a *BlueOceanAPIService) GetPipelineRunsExecute(r ApiGetPipelineRunsRequest) ([]PipelineRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PipelineRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelineRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPipelinesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
}

func (r ApiGetPipelinesRequest) Execute() ([]Pipeline, *http.Response, error) {
	return r.ApiService.GetPipelinesExecute(r)
}

/*
GetPipelines Method for GetPipelines

Retrieve all pipelines details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @return ApiGetPipelinesRequest
*/
func (a *BlueOceanAPIService) GetPipelines(ctx context.Context, organization string) ApiGetPipelinesRequest {
	return ApiGetPipelinesRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
	}
}

// Execute executes the request
//  @return []Pipeline
func (a *BlueOceanAPIService) GetPipelinesExecute(r ApiGetPipelinesRequest) ([]Pipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Pipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetPipelines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSCMRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	scm string
}

func (r ApiGetSCMRequest) Execute() (*GithubScm, *http.Response, error) {
	return r.ApiService.GetSCMExecute(r)
}

/*
GetSCM Method for GetSCM

Retrieve SCM details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param scm Name of SCM
 @return ApiGetSCMRequest
*/
func (a *BlueOceanAPIService) GetSCM(ctx context.Context, organization string, scm string) ApiGetSCMRequest {
	return ApiGetSCMRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		scm: scm,
	}
}

// Execute executes the request
//  @return GithubScm
func (a *BlueOceanAPIService) GetSCMExecute(r ApiGetSCMRequest) (*GithubScm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GithubScm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetSCM")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/scm/{scm}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scm"+"}", url.PathEscape(parameterValueToString(r.scm, "scm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSCMOrganisationRepositoriesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	scm string
	scmOrganisation string
	credentialId *string
	pageSize *int32
	pageNumber *int32
}

// Credential ID
func (r ApiGetSCMOrganisationRepositoriesRequest) CredentialId(credentialId string) ApiGetSCMOrganisationRepositoriesRequest {
	r.credentialId = &credentialId
	return r
}

// Number of items in a page
func (r ApiGetSCMOrganisationRepositoriesRequest) PageSize(pageSize int32) ApiGetSCMOrganisationRepositoriesRequest {
	r.pageSize = &pageSize
	return r
}

// Page number
func (r ApiGetSCMOrganisationRepositoriesRequest) PageNumber(pageNumber int32) ApiGetSCMOrganisationRepositoriesRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiGetSCMOrganisationRepositoriesRequest) Execute() ([]GithubOrganization, *http.Response, error) {
	return r.ApiService.GetSCMOrganisationRepositoriesExecute(r)
}

/*
GetSCMOrganisationRepositories Method for GetSCMOrganisationRepositories

Retrieve SCM organization repositories details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param scm Name of SCM
 @param scmOrganisation Name of the SCM organization
 @return ApiGetSCMOrganisationRepositoriesRequest
*/
func (a *BlueOceanAPIService) GetSCMOrganisationRepositories(ctx context.Context, organization string, scm string, scmOrganisation string) ApiGetSCMOrganisationRepositoriesRequest {
	return ApiGetSCMOrganisationRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		scm: scm,
		scmOrganisation: scmOrganisation,
	}
}

// Execute executes the request
//  @return []GithubOrganization
func (a *BlueOceanAPIService) GetSCMOrganisationRepositoriesExecute(r ApiGetSCMOrganisationRepositoriesRequest) ([]GithubOrganization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GithubOrganization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetSCMOrganisationRepositories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scm"+"}", url.PathEscape(parameterValueToString(r.scm, "scm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scmOrganisation"+"}", url.PathEscape(parameterValueToString(r.scmOrganisation, "scmOrganisation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.credentialId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "credentialId", r.credentialId, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSCMOrganisationRepositoryRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	scm string
	scmOrganisation string
	repository string
	credentialId *string
}

// Credential ID
func (r ApiGetSCMOrganisationRepositoryRequest) CredentialId(credentialId string) ApiGetSCMOrganisationRepositoryRequest {
	r.credentialId = &credentialId
	return r
}

func (r ApiGetSCMOrganisationRepositoryRequest) Execute() ([]GithubOrganization, *http.Response, error) {
	return r.ApiService.GetSCMOrganisationRepositoryExecute(r)
}

/*
GetSCMOrganisationRepository Method for GetSCMOrganisationRepository

Retrieve SCM organization repository details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param scm Name of SCM
 @param scmOrganisation Name of the SCM organization
 @param repository Name of the SCM repository
 @return ApiGetSCMOrganisationRepositoryRequest
*/
func (a *BlueOceanAPIService) GetSCMOrganisationRepository(ctx context.Context, organization string, scm string, scmOrganisation string, repository string) ApiGetSCMOrganisationRepositoryRequest {
	return ApiGetSCMOrganisationRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		scm: scm,
		scmOrganisation: scmOrganisation,
		repository: repository,
	}
}

// Execute executes the request
//  @return []GithubOrganization
func (a *BlueOceanAPIService) GetSCMOrganisationRepositoryExecute(r ApiGetSCMOrganisationRepositoryRequest) ([]GithubOrganization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GithubOrganization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetSCMOrganisationRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scm"+"}", url.PathEscape(parameterValueToString(r.scm, "scm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scmOrganisation"+"}", url.PathEscape(parameterValueToString(r.scmOrganisation, "scmOrganisation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", url.PathEscape(parameterValueToString(r.repository, "repository")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.credentialId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "credentialId", r.credentialId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSCMOrganisationsRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	scm string
	credentialId *string
}

// Credential ID
func (r ApiGetSCMOrganisationsRequest) CredentialId(credentialId string) ApiGetSCMOrganisationsRequest {
	r.credentialId = &credentialId
	return r
}

func (r ApiGetSCMOrganisationsRequest) Execute() ([]GithubOrganization, *http.Response, error) {
	return r.ApiService.GetSCMOrganisationsExecute(r)
}

/*
GetSCMOrganisations Method for GetSCMOrganisations

Retrieve SCM organizations details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param scm Name of SCM
 @return ApiGetSCMOrganisationsRequest
*/
func (a *BlueOceanAPIService) GetSCMOrganisations(ctx context.Context, organization string, scm string) ApiGetSCMOrganisationsRequest {
	return ApiGetSCMOrganisationsRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		scm: scm,
	}
}

// Execute executes the request
//  @return []GithubOrganization
func (a *BlueOceanAPIService) GetSCMOrganisationsExecute(r ApiGetSCMOrganisationsRequest) ([]GithubOrganization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GithubOrganization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetSCMOrganisations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/scm/{scm}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scm"+"}", url.PathEscape(parameterValueToString(r.scm, "scm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.credentialId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "credentialId", r.credentialId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	user string
}

func (r ApiGetUserRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
GetUser Method for GetUser

Retrieve user details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param user Name of the user
 @return ApiGetUserRequest
*/
func (a *BlueOceanAPIService) GetUser(ctx context.Context, organization string, user string) ApiGetUserRequest {
	return ApiGetUserRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		user: user,
	}
}

// Execute executes the request
//  @return User
func (a *BlueOceanAPIService) GetUserExecute(r ApiGetUserRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/users/{user}"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user"+"}", url.PathEscape(parameterValueToString(r.user, "user")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserFavoritesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	user string
}

func (r ApiGetUserFavoritesRequest) Execute() ([]FavoriteImpl, *http.Response, error) {
	return r.ApiService.GetUserFavoritesExecute(r)
}

/*
GetUserFavorites Method for GetUserFavorites

Retrieve user favorites details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param user Name of the user
 @return ApiGetUserFavoritesRequest
*/
func (a *BlueOceanAPIService) GetUserFavorites(ctx context.Context, user string) ApiGetUserFavoritesRequest {
	return ApiGetUserFavoritesRequest{
		ApiService: a,
		ctx: ctx,
		user: user,
	}
}

// Execute executes the request
//  @return []FavoriteImpl
func (a *BlueOceanAPIService) GetUserFavoritesExecute(r ApiGetUserFavoritesRequest) ([]FavoriteImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FavoriteImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetUserFavorites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/users/{user}/favorites"
	localVarPath = strings.Replace(localVarPath, "{"+"user"+"}", url.PathEscape(parameterValueToString(r.user, "user")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
}

func (r ApiGetUsersRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers Method for GetUsers

Retrieve users details for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @return ApiGetUsersRequest
*/
func (a *BlueOceanAPIService) GetUsers(ctx context.Context, organization string) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
	}
}

// Execute executes the request
//  @return User
func (a *BlueOceanAPIService) GetUsersExecute(r ApiGetUsersRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/users/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPipelineRunRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
}

func (r ApiPostPipelineRunRequest) Execute() (*QueueItemImpl, *http.Response, error) {
	return r.ApiService.PostPipelineRunExecute(r)
}

/*
PostPipelineRun Method for PostPipelineRun

Replay an organization pipeline run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @return ApiPostPipelineRunRequest
*/
func (a *BlueOceanAPIService) PostPipelineRun(ctx context.Context, organization string, pipeline string, run string) ApiPostPipelineRunRequest {
	return ApiPostPipelineRunRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return QueueItemImpl
func (a *BlueOceanAPIService) PostPipelineRunExecute(r ApiPostPipelineRunRequest) (*QueueItemImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueItemImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.PostPipelineRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPipelineRunsRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
}

func (r ApiPostPipelineRunsRequest) Execute() (*QueueItemImpl, *http.Response, error) {
	return r.ApiService.PostPipelineRunsExecute(r)
}

/*
PostPipelineRuns Method for PostPipelineRuns

Start a build for an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @return ApiPostPipelineRunsRequest
*/
func (a *BlueOceanAPIService) PostPipelineRuns(ctx context.Context, organization string, pipeline string) ApiPostPipelineRunsRequest {
	return ApiPostPipelineRunsRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return QueueItemImpl
func (a *BlueOceanAPIService) PostPipelineRunsExecute(r ApiPostPipelineRunsRequest) (*QueueItemImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueItemImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.PostPipelineRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutPipelineFavoriteRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	body *bool
}

// Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
func (r ApiPutPipelineFavoriteRequest) Body(body bool) ApiPutPipelineFavoriteRequest {
	r.body = &body
	return r
}

func (r ApiPutPipelineFavoriteRequest) Execute() (*FavoriteImpl, *http.Response, error) {
	return r.ApiService.PutPipelineFavoriteExecute(r)
}

/*
PutPipelineFavorite Method for PutPipelineFavorite

Favorite/unfavorite a pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @return ApiPutPipelineFavoriteRequest
*/
func (a *BlueOceanAPIService) PutPipelineFavorite(ctx context.Context, organization string, pipeline string) ApiPutPipelineFavoriteRequest {
	return ApiPutPipelineFavoriteRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
	}
}

// Execute executes the request
//  @return FavoriteImpl
func (a *BlueOceanAPIService) PutPipelineFavoriteExecute(r ApiPutPipelineFavoriteRequest) (*FavoriteImpl, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FavoriteImpl
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.PutPipelineFavorite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutPipelineRunRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	organization string
	pipeline string
	run string
	blocking *string
	timeOutInSecs *int32
}

// Set to true to make blocking stop, default: false
func (r ApiPutPipelineRunRequest) Blocking(blocking string) ApiPutPipelineRunRequest {
	r.blocking = &blocking
	return r
}

// Timeout in seconds, default: 10 seconds
func (r ApiPutPipelineRunRequest) TimeOutInSecs(timeOutInSecs int32) ApiPutPipelineRunRequest {
	r.timeOutInSecs = &timeOutInSecs
	return r
}

func (r ApiPutPipelineRunRequest) Execute() (*PipelineRun, *http.Response, error) {
	return r.ApiService.PutPipelineRunExecute(r)
}

/*
PutPipelineRun Method for PutPipelineRun

Stop a build of an organization pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organization Name of the organization
 @param pipeline Name of the pipeline
 @param run Name of the run
 @return ApiPutPipelineRunRequest
*/
func (a *BlueOceanAPIService) PutPipelineRun(ctx context.Context, organization string, pipeline string, run string) ApiPutPipelineRunRequest {
	return ApiPutPipelineRunRequest{
		ApiService: a,
		ctx: ctx,
		organization: organization,
		pipeline: pipeline,
		run: run,
	}
}

// Execute executes the request
//  @return PipelineRun
func (a *BlueOceanAPIService) PutPipelineRunExecute(r ApiPutPipelineRunRequest) (*PipelineRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.PutPipelineRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"organization"+"}", url.PathEscape(parameterValueToString(r.organization, "organization")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline"+"}", url.PathEscape(parameterValueToString(r.pipeline, "pipeline")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"run"+"}", url.PathEscape(parameterValueToString(r.run, "run")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blocking != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blocking", r.blocking, "")
	}
	if r.timeOutInSecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timeOutInSecs", r.timeOutInSecs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	q *string
}

// Query string
func (r ApiSearchRequest) Q(q string) ApiSearchRequest {
	r.q = &q
	return r
}

func (r ApiSearchRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SearchExecute(r)
}

/*
Search Method for Search

Search for any resource details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRequest
*/
func (a *BlueOceanAPIService) Search(ctx context.Context) ApiSearchRequest {
	return ApiSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BlueOceanAPIService) SearchExecute(r ApiSearchRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.Search")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/search/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchClassesRequest struct {
	ctx context.Context
	ApiService *BlueOceanAPIService
	q *string
}

// Query string containing an array of class names
func (r ApiSearchClassesRequest) Q(q string) ApiSearchClassesRequest {
	r.q = &q
	return r
}

func (r ApiSearchClassesRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SearchClassesExecute(r)
}

/*
SearchClasses Method for SearchClasses

Get classes details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchClassesRequest
*/
func (a *BlueOceanAPIService) SearchClasses(ctx context.Context) ApiSearchClassesRequest {
	return ApiSearchClassesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BlueOceanAPIService) SearchClassesExecute(r ApiSearchClassesRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlueOceanAPIService.SearchClasses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blue/rest/classes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
