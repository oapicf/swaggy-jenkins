note
 description:"[
		Swaggy Jenkins
 		Jenkins API clients generated from Swagger / Open API specification
  		The version of the OpenAPI document: 1.1.2-pre.0
 	    Contact: blah@cliffano.com

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	BLUEOCEAN_API

inherit

    API_I


feature -- API Access


	authenticated_user (organization: STRING_32): detachable USER
			-- 
			-- Retrieve authenticated user details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- 
			-- Result USER
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/user/"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { USER } l_response.data ({ USER }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	classes (var_class: STRING_32): detachable STRING_32
			-- 
			-- Get a list of class names supported by a given class
			-- 
			-- argument: var_class Name of the class (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/classes/{class}"
			l_path.replace_substring_all ("{"+"class"+"}", api_client.url_encode (var_class.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	delete_pipeline_queue_item (organization: STRING_32; pipeline: STRING_32; queue: STRING_32)
			-- 
			-- Delete queue item from an organization pipeline queue
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: queue Name of the queue item (required)
			-- 
			-- 
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"queue"+"}", api_client.url_encode (queue.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<>>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, agent serializer, Void)
			if l_response.has_error then
				last_error := l_response.error
			end
		end

	json_web_key (key: INTEGER_32): detachable STRING_32
			-- 
			-- Retrieve JSON Web Key
			-- 
			-- argument: key Key ID received as part of JWT header field kid (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/jwt-auth/jwks/{key}"
			l_path.replace_substring_all ("{"+"key"+"}", api_client.url_encode (key.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	json_web_token (expiry_time_in_mins: INTEGER_32; max_expiry_time_in_mins: INTEGER_32): detachable STRING_32
			-- 
			-- Retrieve JSON Web Token
			-- 
			-- argument: expiry_time_in_mins Token expiry time in minutes, default: 30 minutes (optional, default to null)
			-- 
			-- argument: max_expiry_time_in_mins Maximum token expiry time in minutes, default: 480 minutes (optional, default to null)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/jwt-auth/token"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "expiryTimeInMins", expiry_time_in_mins));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "maxExpiryTimeInMins", max_expiry_time_in_mins));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	organisation (organization: STRING_32): detachable ORGANISATION
			-- 
			-- Retrieve organization details
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- 
			-- Result ORGANISATION
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ORGANISATION } l_response.data ({ ORGANISATION }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	organisations : detachable LIST [ORGANISATION]
			-- 
			-- Retrieve all organizations details
			-- 
			-- 
			-- Result LIST [ORGANISATION]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [ORGANISATION] } l_response.data ({ LIST [ORGANISATION] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline (organization: STRING_32; pipeline: STRING_32): detachable PIPELINE
			-- 
			-- Retrieve pipeline details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- 
			-- Result PIPELINE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE } l_response.data ({ PIPELINE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_activities (organization: STRING_32; pipeline: STRING_32): detachable LIST [PIPELINE_ACTIVITY]
			-- 
			-- Retrieve all activities details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- 
			-- Result LIST [PIPELINE_ACTIVITY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [PIPELINE_ACTIVITY] } l_response.data ({ LIST [PIPELINE_ACTIVITY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_branch (organization: STRING_32; pipeline: STRING_32; branch: STRING_32): detachable BRANCH_IMPL
			-- 
			-- Retrieve branch details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: branch Name of the branch (required)
			-- 
			-- 
			-- Result BRANCH_IMPL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"branch"+"}", api_client.url_encode (branch.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { BRANCH_IMPL } l_response.data ({ BRANCH_IMPL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_branch_run (organization: STRING_32; pipeline: STRING_32; branch: STRING_32; run: STRING_32): detachable PIPELINE_RUN
			-- 
			-- Retrieve branch run details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: branch Name of the branch (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- 
			-- Result PIPELINE_RUN
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"branch"+"}", api_client.url_encode (branch.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_RUN } l_response.data ({ PIPELINE_RUN }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_branches (organization: STRING_32; pipeline: STRING_32): detachable MULTIBRANCH_PIPELINE
			-- 
			-- Retrieve all branches details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- 
			-- Result MULTIBRANCH_PIPELINE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { MULTIBRANCH_PIPELINE } l_response.data ({ MULTIBRANCH_PIPELINE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_folder (organization: STRING_32; folder: STRING_32): detachable PIPELINE_FOLDER_IMPL
			-- 
			-- Retrieve pipeline folder for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: folder Name of the folder (required)
			-- 
			-- 
			-- Result PIPELINE_FOLDER_IMPL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{folder}/"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"folder"+"}", api_client.url_encode (folder.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_FOLDER_IMPL } l_response.data ({ PIPELINE_FOLDER_IMPL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_folder_pipeline (organization: STRING_32; pipeline: STRING_32; folder: STRING_32): detachable PIPELINE_IMPL
			-- 
			-- Retrieve pipeline details for an organization folder
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: folder Name of the folder (required)
			-- 
			-- 
			-- Result PIPELINE_IMPL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"folder"+"}", api_client.url_encode (folder.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_IMPL } l_response.data ({ PIPELINE_IMPL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_queue (organization: STRING_32; pipeline: STRING_32): detachable LIST [QUEUE_ITEM_IMPL]
			-- 
			-- Retrieve queue details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- 
			-- Result LIST [QUEUE_ITEM_IMPL]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [QUEUE_ITEM_IMPL] } l_response.data ({ LIST [QUEUE_ITEM_IMPL] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_run (organization: STRING_32; pipeline: STRING_32; run: STRING_32): detachable PIPELINE_RUN
			-- 
			-- Retrieve run details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- 
			-- Result PIPELINE_RUN
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_RUN } l_response.data ({ PIPELINE_RUN }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_run_log (organization: STRING_32; pipeline: STRING_32; run: STRING_32; start: INTEGER_32; download: BOOLEAN): detachable STRING_32
			-- 
			-- Get log for a pipeline run
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- argument: start Start position of the log (optional, default to null)
			-- 
			-- argument: download Set to true in order to download the file, otherwise it&#39;s passed as a response body (optional, default to null)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "start", start));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "download", download));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_run_node (organization: STRING_32; pipeline: STRING_32; run: STRING_32; node: STRING_32): detachable PIPELINE_RUN_NODE
			-- 
			-- Retrieve run node details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- argument: node Name of the node (required)
			-- 
			-- 
			-- Result PIPELINE_RUN_NODE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))
			l_path.replace_substring_all ("{"+"node"+"}", api_client.url_encode (node.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_RUN_NODE } l_response.data ({ PIPELINE_RUN_NODE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_run_node_step (organization: STRING_32; pipeline: STRING_32; run: STRING_32; node: STRING_32; step: STRING_32): detachable PIPELINE_STEP_IMPL
			-- 
			-- Retrieve run node details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- argument: node Name of the node (required)
			-- 
			-- argument: step Name of the step (required)
			-- 
			-- 
			-- Result PIPELINE_STEP_IMPL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))
			l_path.replace_substring_all ("{"+"node"+"}", api_client.url_encode (node.out))
			l_path.replace_substring_all ("{"+"step"+"}", api_client.url_encode (step.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_STEP_IMPL } l_response.data ({ PIPELINE_STEP_IMPL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_run_node_step_log (organization: STRING_32; pipeline: STRING_32; run: STRING_32; node: STRING_32; step: STRING_32): detachable STRING_32
			-- 
			-- Get log for a pipeline run node step
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- argument: node Name of the node (required)
			-- 
			-- argument: step Name of the step (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))
			l_path.replace_substring_all ("{"+"node"+"}", api_client.url_encode (node.out))
			l_path.replace_substring_all ("{"+"step"+"}", api_client.url_encode (step.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_run_node_steps (organization: STRING_32; pipeline: STRING_32; run: STRING_32; node: STRING_32): detachable LIST [PIPELINE_STEP_IMPL]
			-- 
			-- Retrieve run node steps details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- argument: node Name of the node (required)
			-- 
			-- 
			-- Result LIST [PIPELINE_STEP_IMPL]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))
			l_path.replace_substring_all ("{"+"node"+"}", api_client.url_encode (node.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [PIPELINE_STEP_IMPL] } l_response.data ({ LIST [PIPELINE_STEP_IMPL] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_run_nodes (organization: STRING_32; pipeline: STRING_32; run: STRING_32): detachable LIST [PIPELINE_RUN_NODE]
			-- 
			-- Retrieve run nodes details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- 
			-- Result LIST [PIPELINE_RUN_NODE]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [PIPELINE_RUN_NODE] } l_response.data ({ LIST [PIPELINE_RUN_NODE] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipeline_runs (organization: STRING_32; pipeline: STRING_32): detachable LIST [PIPELINE_RUN]
			-- 
			-- Retrieve all runs details for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- 
			-- Result LIST [PIPELINE_RUN]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [PIPELINE_RUN] } l_response.data ({ LIST [PIPELINE_RUN] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	pipelines (organization: STRING_32): detachable LIST [PIPELINE]
			-- 
			-- Retrieve all pipelines details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- 
			-- Result LIST [PIPELINE]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [PIPELINE] } l_response.data ({ LIST [PIPELINE] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	post_pipeline_run (organization: STRING_32; pipeline: STRING_32; run: STRING_32): detachable QUEUE_ITEM_IMPL
			-- 
			-- Replay an organization pipeline run
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- 
			-- Result QUEUE_ITEM_IMPL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { QUEUE_ITEM_IMPL } l_response.data ({ QUEUE_ITEM_IMPL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	post_pipeline_runs (organization: STRING_32; pipeline: STRING_32): detachable QUEUE_ITEM_IMPL
			-- 
			-- Start a build for an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- 
			-- Result QUEUE_ITEM_IMPL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { QUEUE_ITEM_IMPL } l_response.data ({ QUEUE_ITEM_IMPL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	put_pipeline_favorite (organization: STRING_32; pipeline: STRING_32; unknown_base_type: UNKNOWN_BASE_TYPE): detachable FAVORITE_IMPL
			-- 
			-- Favorite/unfavorite a pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: unknown_base_type Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite (required)
			-- 
			-- 
			-- Result FAVORITE_IMPL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(unknown_base_type)
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Put", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { FAVORITE_IMPL } l_response.data ({ FAVORITE_IMPL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	put_pipeline_run (organization: STRING_32; pipeline: STRING_32; run: STRING_32; blocking: STRING_32; time_out_in_secs: INTEGER_32): detachable PIPELINE_RUN
			-- 
			-- Stop a build of an organization pipeline
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: pipeline Name of the pipeline (required)
			-- 
			-- argument: run Name of the run (required)
			-- 
			-- argument: blocking Set to true to make blocking stop, default: false (optional, default to null)
			-- 
			-- argument: time_out_in_secs Timeout in seconds, default: 10 seconds (optional, default to null)
			-- 
			-- 
			-- Result PIPELINE_RUN
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"pipeline"+"}", api_client.url_encode (pipeline.out))
			l_path.replace_substring_all ("{"+"run"+"}", api_client.url_encode (run.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "blocking", blocking));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "timeOutInSecs", time_out_in_secs));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Put", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { PIPELINE_RUN } l_response.data ({ PIPELINE_RUN }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	sc_m (organization: STRING_32; scm: STRING_32): detachable GITHUB_SCM
			-- 
			-- Retrieve SCM details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: scm Name of SCM (required)
			-- 
			-- 
			-- Result GITHUB_SCM
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/scm/{scm}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"scm"+"}", api_client.url_encode (scm.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { GITHUB_SCM } l_response.data ({ GITHUB_SCM }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	sc_morganisation_repositories (organization: STRING_32; scm: STRING_32; scm_organisation: STRING_32; credential_id: STRING_32; page_size: INTEGER_32; page_number: INTEGER_32): detachable LIST [GITHUB_ORGANIZATION]
			-- 
			-- Retrieve SCM organization repositories details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: scm Name of SCM (required)
			-- 
			-- argument: scm_organisation Name of the SCM organization (required)
			-- 
			-- argument: credential_id Credential ID (optional, default to null)
			-- 
			-- argument: page_size Number of items in a page (optional, default to null)
			-- 
			-- argument: page_number Page number (optional, default to null)
			-- 
			-- 
			-- Result LIST [GITHUB_ORGANIZATION]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"scm"+"}", api_client.url_encode (scm.out))
			l_path.replace_substring_all ("{"+"scmOrganisation"+"}", api_client.url_encode (scm_organisation.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "credentialId", credential_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pageSize", page_size));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "pageNumber", page_number));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [GITHUB_ORGANIZATION] } l_response.data ({ LIST [GITHUB_ORGANIZATION] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	sc_morganisation_repository (organization: STRING_32; scm: STRING_32; scm_organisation: STRING_32; repository: STRING_32; credential_id: STRING_32): detachable LIST [GITHUB_ORGANIZATION]
			-- 
			-- Retrieve SCM organization repository details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: scm Name of SCM (required)
			-- 
			-- argument: scm_organisation Name of the SCM organization (required)
			-- 
			-- argument: repository Name of the SCM repository (required)
			-- 
			-- argument: credential_id Credential ID (optional, default to null)
			-- 
			-- 
			-- Result LIST [GITHUB_ORGANIZATION]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"scm"+"}", api_client.url_encode (scm.out))
			l_path.replace_substring_all ("{"+"scmOrganisation"+"}", api_client.url_encode (scm_organisation.out))
			l_path.replace_substring_all ("{"+"repository"+"}", api_client.url_encode (repository.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "credentialId", credential_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [GITHUB_ORGANIZATION] } l_response.data ({ LIST [GITHUB_ORGANIZATION] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	sc_morganisations (organization: STRING_32; scm: STRING_32; credential_id: STRING_32): detachable LIST [GITHUB_ORGANIZATION]
			-- 
			-- Retrieve SCM organizations details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: scm Name of SCM (required)
			-- 
			-- argument: credential_id Credential ID (optional, default to null)
			-- 
			-- 
			-- Result LIST [GITHUB_ORGANIZATION]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/scm/{scm}/organizations"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"scm"+"}", api_client.url_encode (scm.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "credentialId", credential_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [GITHUB_ORGANIZATION] } l_response.data ({ LIST [GITHUB_ORGANIZATION] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	search (q: STRING_32): detachable STRING_32
			-- 
			-- Search for any resource details
			-- 
			-- argument: q Query string (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/search/"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "q", q));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	search_classes (q: STRING_32): detachable STRING_32
			-- 
			-- Get classes details
			-- 
			-- argument: q Query string containing an array of class names (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/classes/"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "q", q));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	user (organization: STRING_32; user: STRING_32): detachable USER
			-- 
			-- Retrieve user details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- argument: user Name of the user (required)
			-- 
			-- 
			-- Result USER
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/users/{user}"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))
			l_path.replace_substring_all ("{"+"user"+"}", api_client.url_encode (user.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { USER } l_response.data ({ USER }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	user_favorites (user: STRING_32): detachable LIST [FAVORITE_IMPL]
			-- 
			-- Retrieve user favorites details for an organization
			-- 
			-- argument: user Name of the user (required)
			-- 
			-- 
			-- Result LIST [FAVORITE_IMPL]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/users/{user}/favorites"
			l_path.replace_substring_all ("{"+"user"+"}", api_client.url_encode (user.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST [FAVORITE_IMPL] } l_response.data ({ LIST [FAVORITE_IMPL] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	users (organization: STRING_32): detachable USER
			-- 
			-- Retrieve users details for an organization
			-- 
			-- argument: organization Name of the organization (required)
			-- 
			-- 
			-- Result USER
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/blue/rest/organizations/{organization}/users/"
			l_path.replace_substring_all ("{"+"organization"+"}", api_client.url_encode (organization.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"jenkins_auth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { USER } l_response.data ({ USER }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end


end
