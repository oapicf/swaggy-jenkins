{-
   Swaggy Jenkins

   Jenkins API clients generated from Swagger / Open API specification

   OpenAPI Version: 3.0.0
   Swaggy Jenkins API version: 3.0.2-pre.0
   Contact: blah+oapicf@cliffano.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : SwaggyJenkins.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module SwaggyJenkins.Model where

import SwaggyJenkins.Core
import SwaggyJenkins.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Blocking
newtype Blocking = Blocking { unBlocking :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** BodyBool
newtype BodyBool = BodyBool { unBodyBool :: Bool } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Branch
newtype Branch = Branch { unBranch :: Text } deriving (P.Eq, P.Show)

-- ** CredentialId
newtype CredentialId = CredentialId { unCredentialId :: Text } deriving (P.Eq, P.Show)

-- ** Depth
newtype Depth = Depth { unDepth :: Int } deriving (P.Eq, P.Show)

-- ** Download
newtype Download = Download { unDownload :: Bool } deriving (P.Eq, P.Show)

-- ** ExpiryTimeInMins
newtype ExpiryTimeInMins = ExpiryTimeInMins { unExpiryTimeInMins :: Int } deriving (P.Eq, P.Show)

-- ** Folder
newtype Folder = Folder { unFolder :: Text } deriving (P.Eq, P.Show)

-- ** From
newtype From = From { unFrom :: Text } deriving (P.Eq, P.Show)

-- ** JenkinsCrumb
newtype JenkinsCrumb = JenkinsCrumb { unJenkinsCrumb :: Text } deriving (P.Eq, P.Show)

-- ** Json
newtype Json = Json { unJson :: Text } deriving (P.Eq, P.Show)

-- ** Key
newtype Key = Key { unKey :: Int } deriving (P.Eq, P.Show)

-- ** MaxExpiryTimeInMins
newtype MaxExpiryTimeInMins = MaxExpiryTimeInMins { unMaxExpiryTimeInMins :: Int } deriving (P.Eq, P.Show)

-- ** Mode
newtype Mode = Mode { unMode :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Node
newtype Node = Node { unNode :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Text } deriving (P.Eq, P.Show)

-- ** Organization
newtype Organization = Organization { unOrganization :: Text } deriving (P.Eq, P.Show)

-- ** PageNumber
newtype PageNumber = PageNumber { unPageNumber :: Int } deriving (P.Eq, P.Show)

-- ** PageSize
newtype PageSize = PageSize { unPageSize :: Int } deriving (P.Eq, P.Show)

-- ** ParamClass
newtype ParamClass = ParamClass { unParamClass :: Text } deriving (P.Eq, P.Show)

-- ** ParamContentType
newtype ParamContentType = ParamContentType { unParamContentType :: Text } deriving (P.Eq, P.Show)

-- ** Pipeline2
newtype Pipeline2 = Pipeline2 { unPipeline2 :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Text } deriving (P.Eq, P.Show)

-- ** Queue2
newtype Queue2 = Queue2 { unQueue2 :: Text } deriving (P.Eq, P.Show)

-- ** Repository
newtype Repository = Repository { unRepository :: Text } deriving (P.Eq, P.Show)

-- ** Run
newtype Run = Run { unRun :: Text } deriving (P.Eq, P.Show)

-- ** Scm
newtype Scm = Scm { unScm :: Text } deriving (P.Eq, P.Show)

-- ** ScmOrganisation
newtype ScmOrganisation = ScmOrganisation { unScmOrganisation :: Text } deriving (P.Eq, P.Show)

-- ** Start
newtype Start = Start { unStart :: Text } deriving (P.Eq, P.Show)

-- ** StartInt
newtype StartInt = StartInt { unStartInt :: Int } deriving (P.Eq, P.Show)

-- ** Step
newtype Step = Step { unStep :: Text } deriving (P.Eq, P.Show)

-- ** TimeOutInSecs
newtype TimeOutInSecs = TimeOutInSecs { unTimeOutInSecs :: Int } deriving (P.Eq, P.Show)

-- ** Token
newtype Token = Token { unToken :: Text } deriving (P.Eq, P.Show)

-- ** User2
newtype User2 = User2 { unUser2 :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AllView
-- | AllView
data AllView = AllView
  { allViewClass :: !(Maybe Text) -- ^ "_class"
  , allViewName :: !(Maybe Text) -- ^ "name"
  , allViewUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AllView
instance A.FromJSON AllView where
  parseJSON = A.withObject "AllView" $ \o ->
    AllView
      <$> (o .:? "_class")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON AllView
instance A.ToJSON AllView where
  toJSON AllView {..} =
   _omitNulls
      [ "_class" .= allViewClass
      , "name" .= allViewName
      , "url" .= allViewUrl
      ]


-- | Construct a value of type 'AllView' (by applying it's required fields, if any)
mkAllView
  :: AllView
mkAllView =
  AllView
  { allViewClass = Nothing
  , allViewName = Nothing
  , allViewUrl = Nothing
  }

-- ** BranchImpl
-- | BranchImpl
data BranchImpl = BranchImpl
  { branchImplClass :: !(Maybe Text) -- ^ "_class"
  , branchImplDisplayName :: !(Maybe Text) -- ^ "displayName"
  , branchImplEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , branchImplFullDisplayName :: !(Maybe Text) -- ^ "fullDisplayName"
  , branchImplFullName :: !(Maybe Text) -- ^ "fullName"
  , branchImplName :: !(Maybe Text) -- ^ "name"
  , branchImplOrganization :: !(Maybe Text) -- ^ "organization"
  , branchImplParameters :: !(Maybe [StringParameterDefinition]) -- ^ "parameters"
  , branchImplPermissions :: !(Maybe BranchImplpermissions) -- ^ "permissions"
  , branchImplWeatherScore :: !(Maybe Int) -- ^ "weatherScore"
  , branchImplPullRequest :: !(Maybe Text) -- ^ "pullRequest"
  , branchImplLinks :: !(Maybe BranchImpllinks) -- ^ "_links"
  , branchImplLatestRun :: !(Maybe PipelineRunImpl) -- ^ "latestRun"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BranchImpl
instance A.FromJSON BranchImpl where
  parseJSON = A.withObject "BranchImpl" $ \o ->
    BranchImpl
      <$> (o .:? "_class")
      <*> (o .:? "displayName")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "fullDisplayName")
      <*> (o .:? "fullName")
      <*> (o .:? "name")
      <*> (o .:? "organization")
      <*> (o .:? "parameters")
      <*> (o .:? "permissions")
      <*> (o .:? "weatherScore")
      <*> (o .:? "pullRequest")
      <*> (o .:? "_links")
      <*> (o .:? "latestRun")

-- | ToJSON BranchImpl
instance A.ToJSON BranchImpl where
  toJSON BranchImpl {..} =
   _omitNulls
      [ "_class" .= branchImplClass
      , "displayName" .= branchImplDisplayName
      , "estimatedDurationInMillis" .= branchImplEstimatedDurationInMillis
      , "fullDisplayName" .= branchImplFullDisplayName
      , "fullName" .= branchImplFullName
      , "name" .= branchImplName
      , "organization" .= branchImplOrganization
      , "parameters" .= branchImplParameters
      , "permissions" .= branchImplPermissions
      , "weatherScore" .= branchImplWeatherScore
      , "pullRequest" .= branchImplPullRequest
      , "_links" .= branchImplLinks
      , "latestRun" .= branchImplLatestRun
      ]


-- | Construct a value of type 'BranchImpl' (by applying it's required fields, if any)
mkBranchImpl
  :: BranchImpl
mkBranchImpl =
  BranchImpl
  { branchImplClass = Nothing
  , branchImplDisplayName = Nothing
  , branchImplEstimatedDurationInMillis = Nothing
  , branchImplFullDisplayName = Nothing
  , branchImplFullName = Nothing
  , branchImplName = Nothing
  , branchImplOrganization = Nothing
  , branchImplParameters = Nothing
  , branchImplPermissions = Nothing
  , branchImplWeatherScore = Nothing
  , branchImplPullRequest = Nothing
  , branchImplLinks = Nothing
  , branchImplLatestRun = Nothing
  }

-- ** BranchImpllinks
-- | BranchImpllinks
data BranchImpllinks = BranchImpllinks
  { branchImpllinksSelf :: !(Maybe Link) -- ^ "self"
  , branchImpllinksActions :: !(Maybe Link) -- ^ "actions"
  , branchImpllinksRuns :: !(Maybe Link) -- ^ "runs"
  , branchImpllinksQueue :: !(Maybe Link) -- ^ "queue"
  , branchImpllinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BranchImpllinks
instance A.FromJSON BranchImpllinks where
  parseJSON = A.withObject "BranchImpllinks" $ \o ->
    BranchImpllinks
      <$> (o .:? "self")
      <*> (o .:? "actions")
      <*> (o .:? "runs")
      <*> (o .:? "queue")
      <*> (o .:? "_class")

-- | ToJSON BranchImpllinks
instance A.ToJSON BranchImpllinks where
  toJSON BranchImpllinks {..} =
   _omitNulls
      [ "self" .= branchImpllinksSelf
      , "actions" .= branchImpllinksActions
      , "runs" .= branchImpllinksRuns
      , "queue" .= branchImpllinksQueue
      , "_class" .= branchImpllinksClass
      ]


-- | Construct a value of type 'BranchImpllinks' (by applying it's required fields, if any)
mkBranchImpllinks
  :: BranchImpllinks
mkBranchImpllinks =
  BranchImpllinks
  { branchImpllinksSelf = Nothing
  , branchImpllinksActions = Nothing
  , branchImpllinksRuns = Nothing
  , branchImpllinksQueue = Nothing
  , branchImpllinksClass = Nothing
  }

-- ** BranchImplpermissions
-- | BranchImplpermissions
data BranchImplpermissions = BranchImplpermissions
  { branchImplpermissionsCreate :: !(Maybe Bool) -- ^ "create"
  , branchImplpermissionsRead :: !(Maybe Bool) -- ^ "read"
  , branchImplpermissionsStart :: !(Maybe Bool) -- ^ "start"
  , branchImplpermissionsStop :: !(Maybe Bool) -- ^ "stop"
  , branchImplpermissionsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BranchImplpermissions
instance A.FromJSON BranchImplpermissions where
  parseJSON = A.withObject "BranchImplpermissions" $ \o ->
    BranchImplpermissions
      <$> (o .:? "create")
      <*> (o .:? "read")
      <*> (o .:? "start")
      <*> (o .:? "stop")
      <*> (o .:? "_class")

-- | ToJSON BranchImplpermissions
instance A.ToJSON BranchImplpermissions where
  toJSON BranchImplpermissions {..} =
   _omitNulls
      [ "create" .= branchImplpermissionsCreate
      , "read" .= branchImplpermissionsRead
      , "start" .= branchImplpermissionsStart
      , "stop" .= branchImplpermissionsStop
      , "_class" .= branchImplpermissionsClass
      ]


-- | Construct a value of type 'BranchImplpermissions' (by applying it's required fields, if any)
mkBranchImplpermissions
  :: BranchImplpermissions
mkBranchImplpermissions =
  BranchImplpermissions
  { branchImplpermissionsCreate = Nothing
  , branchImplpermissionsRead = Nothing
  , branchImplpermissionsStart = Nothing
  , branchImplpermissionsStop = Nothing
  , branchImplpermissionsClass = Nothing
  }

-- ** CauseAction
-- | CauseAction
data CauseAction = CauseAction
  { causeActionClass :: !(Maybe Text) -- ^ "_class"
  , causeActionCauses :: !(Maybe [CauseUserIdCause]) -- ^ "causes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CauseAction
instance A.FromJSON CauseAction where
  parseJSON = A.withObject "CauseAction" $ \o ->
    CauseAction
      <$> (o .:? "_class")
      <*> (o .:? "causes")

-- | ToJSON CauseAction
instance A.ToJSON CauseAction where
  toJSON CauseAction {..} =
   _omitNulls
      [ "_class" .= causeActionClass
      , "causes" .= causeActionCauses
      ]


-- | Construct a value of type 'CauseAction' (by applying it's required fields, if any)
mkCauseAction
  :: CauseAction
mkCauseAction =
  CauseAction
  { causeActionClass = Nothing
  , causeActionCauses = Nothing
  }

-- ** CauseUserIdCause
-- | CauseUserIdCause
data CauseUserIdCause = CauseUserIdCause
  { causeUserIdCauseClass :: !(Maybe Text) -- ^ "_class"
  , causeUserIdCauseShortDescription :: !(Maybe Text) -- ^ "shortDescription"
  , causeUserIdCauseUserId :: !(Maybe Text) -- ^ "userId"
  , causeUserIdCauseUserName :: !(Maybe Text) -- ^ "userName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CauseUserIdCause
instance A.FromJSON CauseUserIdCause where
  parseJSON = A.withObject "CauseUserIdCause" $ \o ->
    CauseUserIdCause
      <$> (o .:? "_class")
      <*> (o .:? "shortDescription")
      <*> (o .:? "userId")
      <*> (o .:? "userName")

-- | ToJSON CauseUserIdCause
instance A.ToJSON CauseUserIdCause where
  toJSON CauseUserIdCause {..} =
   _omitNulls
      [ "_class" .= causeUserIdCauseClass
      , "shortDescription" .= causeUserIdCauseShortDescription
      , "userId" .= causeUserIdCauseUserId
      , "userName" .= causeUserIdCauseUserName
      ]


-- | Construct a value of type 'CauseUserIdCause' (by applying it's required fields, if any)
mkCauseUserIdCause
  :: CauseUserIdCause
mkCauseUserIdCause =
  CauseUserIdCause
  { causeUserIdCauseClass = Nothing
  , causeUserIdCauseShortDescription = Nothing
  , causeUserIdCauseUserId = Nothing
  , causeUserIdCauseUserName = Nothing
  }

-- ** ClassesByClass
-- | ClassesByClass
data ClassesByClass = ClassesByClass
  { classesByClassClasses :: !(Maybe [Text]) -- ^ "classes"
  , classesByClassClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClassesByClass
instance A.FromJSON ClassesByClass where
  parseJSON = A.withObject "ClassesByClass" $ \o ->
    ClassesByClass
      <$> (o .:? "classes")
      <*> (o .:? "_class")

-- | ToJSON ClassesByClass
instance A.ToJSON ClassesByClass where
  toJSON ClassesByClass {..} =
   _omitNulls
      [ "classes" .= classesByClassClasses
      , "_class" .= classesByClassClass
      ]


-- | Construct a value of type 'ClassesByClass' (by applying it's required fields, if any)
mkClassesByClass
  :: ClassesByClass
mkClassesByClass =
  ClassesByClass
  { classesByClassClasses = Nothing
  , classesByClassClass = Nothing
  }

-- ** ClockDifference
-- | ClockDifference
data ClockDifference = ClockDifference
  { clockDifferenceClass :: !(Maybe Text) -- ^ "_class"
  , clockDifferenceDiff :: !(Maybe Int) -- ^ "diff"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClockDifference
instance A.FromJSON ClockDifference where
  parseJSON = A.withObject "ClockDifference" $ \o ->
    ClockDifference
      <$> (o .:? "_class")
      <*> (o .:? "diff")

-- | ToJSON ClockDifference
instance A.ToJSON ClockDifference where
  toJSON ClockDifference {..} =
   _omitNulls
      [ "_class" .= clockDifferenceClass
      , "diff" .= clockDifferenceDiff
      ]


-- | Construct a value of type 'ClockDifference' (by applying it's required fields, if any)
mkClockDifference
  :: ClockDifference
mkClockDifference =
  ClockDifference
  { clockDifferenceClass = Nothing
  , clockDifferenceDiff = Nothing
  }

-- ** ComputerSet
-- | ComputerSet
data ComputerSet = ComputerSet
  { computerSetClass :: !(Maybe Text) -- ^ "_class"
  , computerSetBusyExecutors :: !(Maybe Int) -- ^ "busyExecutors"
  , computerSetComputer :: !(Maybe [HudsonMasterComputer]) -- ^ "computer"
  , computerSetDisplayName :: !(Maybe Text) -- ^ "displayName"
  , computerSetTotalExecutors :: !(Maybe Int) -- ^ "totalExecutors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ComputerSet
instance A.FromJSON ComputerSet where
  parseJSON = A.withObject "ComputerSet" $ \o ->
    ComputerSet
      <$> (o .:? "_class")
      <*> (o .:? "busyExecutors")
      <*> (o .:? "computer")
      <*> (o .:? "displayName")
      <*> (o .:? "totalExecutors")

-- | ToJSON ComputerSet
instance A.ToJSON ComputerSet where
  toJSON ComputerSet {..} =
   _omitNulls
      [ "_class" .= computerSetClass
      , "busyExecutors" .= computerSetBusyExecutors
      , "computer" .= computerSetComputer
      , "displayName" .= computerSetDisplayName
      , "totalExecutors" .= computerSetTotalExecutors
      ]


-- | Construct a value of type 'ComputerSet' (by applying it's required fields, if any)
mkComputerSet
  :: ComputerSet
mkComputerSet =
  ComputerSet
  { computerSetClass = Nothing
  , computerSetBusyExecutors = Nothing
  , computerSetComputer = Nothing
  , computerSetDisplayName = Nothing
  , computerSetTotalExecutors = Nothing
  }

-- ** DefaultCrumbIssuer
-- | DefaultCrumbIssuer
data DefaultCrumbIssuer = DefaultCrumbIssuer
  { defaultCrumbIssuerClass :: !(Maybe Text) -- ^ "_class"
  , defaultCrumbIssuerCrumb :: !(Maybe Text) -- ^ "crumb"
  , defaultCrumbIssuerCrumbRequestField :: !(Maybe Text) -- ^ "crumbRequestField"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DefaultCrumbIssuer
instance A.FromJSON DefaultCrumbIssuer where
  parseJSON = A.withObject "DefaultCrumbIssuer" $ \o ->
    DefaultCrumbIssuer
      <$> (o .:? "_class")
      <*> (o .:? "crumb")
      <*> (o .:? "crumbRequestField")

-- | ToJSON DefaultCrumbIssuer
instance A.ToJSON DefaultCrumbIssuer where
  toJSON DefaultCrumbIssuer {..} =
   _omitNulls
      [ "_class" .= defaultCrumbIssuerClass
      , "crumb" .= defaultCrumbIssuerCrumb
      , "crumbRequestField" .= defaultCrumbIssuerCrumbRequestField
      ]


-- | Construct a value of type 'DefaultCrumbIssuer' (by applying it's required fields, if any)
mkDefaultCrumbIssuer
  :: DefaultCrumbIssuer
mkDefaultCrumbIssuer =
  DefaultCrumbIssuer
  { defaultCrumbIssuerClass = Nothing
  , defaultCrumbIssuerCrumb = Nothing
  , defaultCrumbIssuerCrumbRequestField = Nothing
  }

-- ** DiskSpaceMonitorDescriptorDiskSpace
-- | DiskSpaceMonitorDescriptorDiskSpace
data DiskSpaceMonitorDescriptorDiskSpace = DiskSpaceMonitorDescriptorDiskSpace
  { diskSpaceMonitorDescriptorDiskSpaceClass :: !(Maybe Text) -- ^ "_class"
  , diskSpaceMonitorDescriptorDiskSpaceTimestamp :: !(Maybe Int) -- ^ "timestamp"
  , diskSpaceMonitorDescriptorDiskSpacePath :: !(Maybe Text) -- ^ "path"
  , diskSpaceMonitorDescriptorDiskSpaceSize :: !(Maybe Int) -- ^ "size"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DiskSpaceMonitorDescriptorDiskSpace
instance A.FromJSON DiskSpaceMonitorDescriptorDiskSpace where
  parseJSON = A.withObject "DiskSpaceMonitorDescriptorDiskSpace" $ \o ->
    DiskSpaceMonitorDescriptorDiskSpace
      <$> (o .:? "_class")
      <*> (o .:? "timestamp")
      <*> (o .:? "path")
      <*> (o .:? "size")

-- | ToJSON DiskSpaceMonitorDescriptorDiskSpace
instance A.ToJSON DiskSpaceMonitorDescriptorDiskSpace where
  toJSON DiskSpaceMonitorDescriptorDiskSpace {..} =
   _omitNulls
      [ "_class" .= diskSpaceMonitorDescriptorDiskSpaceClass
      , "timestamp" .= diskSpaceMonitorDescriptorDiskSpaceTimestamp
      , "path" .= diskSpaceMonitorDescriptorDiskSpacePath
      , "size" .= diskSpaceMonitorDescriptorDiskSpaceSize
      ]


-- | Construct a value of type 'DiskSpaceMonitorDescriptorDiskSpace' (by applying it's required fields, if any)
mkDiskSpaceMonitorDescriptorDiskSpace
  :: DiskSpaceMonitorDescriptorDiskSpace
mkDiskSpaceMonitorDescriptorDiskSpace =
  DiskSpaceMonitorDescriptorDiskSpace
  { diskSpaceMonitorDescriptorDiskSpaceClass = Nothing
  , diskSpaceMonitorDescriptorDiskSpaceTimestamp = Nothing
  , diskSpaceMonitorDescriptorDiskSpacePath = Nothing
  , diskSpaceMonitorDescriptorDiskSpaceSize = Nothing
  }

-- ** EmptyChangeLogSet
-- | EmptyChangeLogSet
data EmptyChangeLogSet = EmptyChangeLogSet
  { emptyChangeLogSetClass :: !(Maybe Text) -- ^ "_class"
  , emptyChangeLogSetKind :: !(Maybe Text) -- ^ "kind"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmptyChangeLogSet
instance A.FromJSON EmptyChangeLogSet where
  parseJSON = A.withObject "EmptyChangeLogSet" $ \o ->
    EmptyChangeLogSet
      <$> (o .:? "_class")
      <*> (o .:? "kind")

-- | ToJSON EmptyChangeLogSet
instance A.ToJSON EmptyChangeLogSet where
  toJSON EmptyChangeLogSet {..} =
   _omitNulls
      [ "_class" .= emptyChangeLogSetClass
      , "kind" .= emptyChangeLogSetKind
      ]


-- | Construct a value of type 'EmptyChangeLogSet' (by applying it's required fields, if any)
mkEmptyChangeLogSet
  :: EmptyChangeLogSet
mkEmptyChangeLogSet =
  EmptyChangeLogSet
  { emptyChangeLogSetClass = Nothing
  , emptyChangeLogSetKind = Nothing
  }

-- ** ExtensionClassContainerImpl1
-- | ExtensionClassContainerImpl1
data ExtensionClassContainerImpl1 = ExtensionClassContainerImpl1
  { extensionClassContainerImpl1Class :: !(Maybe Text) -- ^ "_class"
  , extensionClassContainerImpl1Links :: !(Maybe ExtensionClassContainerImpl1links) -- ^ "_links"
  , extensionClassContainerImpl1Map :: !(Maybe ExtensionClassContainerImpl1map) -- ^ "map"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtensionClassContainerImpl1
instance A.FromJSON ExtensionClassContainerImpl1 where
  parseJSON = A.withObject "ExtensionClassContainerImpl1" $ \o ->
    ExtensionClassContainerImpl1
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "map")

-- | ToJSON ExtensionClassContainerImpl1
instance A.ToJSON ExtensionClassContainerImpl1 where
  toJSON ExtensionClassContainerImpl1 {..} =
   _omitNulls
      [ "_class" .= extensionClassContainerImpl1Class
      , "_links" .= extensionClassContainerImpl1Links
      , "map" .= extensionClassContainerImpl1Map
      ]


-- | Construct a value of type 'ExtensionClassContainerImpl1' (by applying it's required fields, if any)
mkExtensionClassContainerImpl1
  :: ExtensionClassContainerImpl1
mkExtensionClassContainerImpl1 =
  ExtensionClassContainerImpl1
  { extensionClassContainerImpl1Class = Nothing
  , extensionClassContainerImpl1Links = Nothing
  , extensionClassContainerImpl1Map = Nothing
  }

-- ** ExtensionClassContainerImpl1links
-- | ExtensionClassContainerImpl1links
data ExtensionClassContainerImpl1links = ExtensionClassContainerImpl1links
  { extensionClassContainerImpl1linksSelf :: !(Maybe Link) -- ^ "self"
  , extensionClassContainerImpl1linksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtensionClassContainerImpl1links
instance A.FromJSON ExtensionClassContainerImpl1links where
  parseJSON = A.withObject "ExtensionClassContainerImpl1links" $ \o ->
    ExtensionClassContainerImpl1links
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON ExtensionClassContainerImpl1links
instance A.ToJSON ExtensionClassContainerImpl1links where
  toJSON ExtensionClassContainerImpl1links {..} =
   _omitNulls
      [ "self" .= extensionClassContainerImpl1linksSelf
      , "_class" .= extensionClassContainerImpl1linksClass
      ]


-- | Construct a value of type 'ExtensionClassContainerImpl1links' (by applying it's required fields, if any)
mkExtensionClassContainerImpl1links
  :: ExtensionClassContainerImpl1links
mkExtensionClassContainerImpl1links =
  ExtensionClassContainerImpl1links
  { extensionClassContainerImpl1linksSelf = Nothing
  , extensionClassContainerImpl1linksClass = Nothing
  }

-- ** ExtensionClassContainerImpl1map
-- | ExtensionClassContainerImpl1map
data ExtensionClassContainerImpl1map = ExtensionClassContainerImpl1map
  { extensionClassContainerImpl1mapIoJenkinsBlueoceanServiceEmbeddedRestPipelineImpl :: !(Maybe ExtensionClassImpl) -- ^ "io.jenkins.blueocean.service.embedded.rest.PipelineImpl"
  , extensionClassContainerImpl1mapIoJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl :: !(Maybe ExtensionClassImpl) -- ^ "io.jenkins.blueocean.service.embedded.rest.MultiBranchPipelineImpl"
  , extensionClassContainerImpl1mapClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtensionClassContainerImpl1map
instance A.FromJSON ExtensionClassContainerImpl1map where
  parseJSON = A.withObject "ExtensionClassContainerImpl1map" $ \o ->
    ExtensionClassContainerImpl1map
      <$> (o .:? "io.jenkins.blueocean.service.embedded.rest.PipelineImpl")
      <*> (o .:? "io.jenkins.blueocean.service.embedded.rest.MultiBranchPipelineImpl")
      <*> (o .:? "_class")

-- | ToJSON ExtensionClassContainerImpl1map
instance A.ToJSON ExtensionClassContainerImpl1map where
  toJSON ExtensionClassContainerImpl1map {..} =
   _omitNulls
      [ "io.jenkins.blueocean.service.embedded.rest.PipelineImpl" .= extensionClassContainerImpl1mapIoJenkinsBlueoceanServiceEmbeddedRestPipelineImpl
      , "io.jenkins.blueocean.service.embedded.rest.MultiBranchPipelineImpl" .= extensionClassContainerImpl1mapIoJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl
      , "_class" .= extensionClassContainerImpl1mapClass
      ]


-- | Construct a value of type 'ExtensionClassContainerImpl1map' (by applying it's required fields, if any)
mkExtensionClassContainerImpl1map
  :: ExtensionClassContainerImpl1map
mkExtensionClassContainerImpl1map =
  ExtensionClassContainerImpl1map
  { extensionClassContainerImpl1mapIoJenkinsBlueoceanServiceEmbeddedRestPipelineImpl = Nothing
  , extensionClassContainerImpl1mapIoJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl = Nothing
  , extensionClassContainerImpl1mapClass = Nothing
  }

-- ** ExtensionClassImpl
-- | ExtensionClassImpl
data ExtensionClassImpl = ExtensionClassImpl
  { extensionClassImplClass :: !(Maybe Text) -- ^ "_class"
  , extensionClassImplLinks :: !(Maybe ExtensionClassImpllinks) -- ^ "_links"
  , extensionClassImplClasses :: !(Maybe [Text]) -- ^ "classes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtensionClassImpl
instance A.FromJSON ExtensionClassImpl where
  parseJSON = A.withObject "ExtensionClassImpl" $ \o ->
    ExtensionClassImpl
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "classes")

-- | ToJSON ExtensionClassImpl
instance A.ToJSON ExtensionClassImpl where
  toJSON ExtensionClassImpl {..} =
   _omitNulls
      [ "_class" .= extensionClassImplClass
      , "_links" .= extensionClassImplLinks
      , "classes" .= extensionClassImplClasses
      ]


-- | Construct a value of type 'ExtensionClassImpl' (by applying it's required fields, if any)
mkExtensionClassImpl
  :: ExtensionClassImpl
mkExtensionClassImpl =
  ExtensionClassImpl
  { extensionClassImplClass = Nothing
  , extensionClassImplLinks = Nothing
  , extensionClassImplClasses = Nothing
  }

-- ** ExtensionClassImpllinks
-- | ExtensionClassImpllinks
data ExtensionClassImpllinks = ExtensionClassImpllinks
  { extensionClassImpllinksSelf :: !(Maybe Link) -- ^ "self"
  , extensionClassImpllinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtensionClassImpllinks
instance A.FromJSON ExtensionClassImpllinks where
  parseJSON = A.withObject "ExtensionClassImpllinks" $ \o ->
    ExtensionClassImpllinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON ExtensionClassImpllinks
instance A.ToJSON ExtensionClassImpllinks where
  toJSON ExtensionClassImpllinks {..} =
   _omitNulls
      [ "self" .= extensionClassImpllinksSelf
      , "_class" .= extensionClassImpllinksClass
      ]


-- | Construct a value of type 'ExtensionClassImpllinks' (by applying it's required fields, if any)
mkExtensionClassImpllinks
  :: ExtensionClassImpllinks
mkExtensionClassImpllinks =
  ExtensionClassImpllinks
  { extensionClassImpllinksSelf = Nothing
  , extensionClassImpllinksClass = Nothing
  }

-- ** FavoriteImpl
-- | FavoriteImpl
data FavoriteImpl = FavoriteImpl
  { favoriteImplClass :: !(Maybe Text) -- ^ "_class"
  , favoriteImplLinks :: !(Maybe FavoriteImpllinks) -- ^ "_links"
  , favoriteImplItem :: !(Maybe PipelineImpl) -- ^ "item"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FavoriteImpl
instance A.FromJSON FavoriteImpl where
  parseJSON = A.withObject "FavoriteImpl" $ \o ->
    FavoriteImpl
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "item")

-- | ToJSON FavoriteImpl
instance A.ToJSON FavoriteImpl where
  toJSON FavoriteImpl {..} =
   _omitNulls
      [ "_class" .= favoriteImplClass
      , "_links" .= favoriteImplLinks
      , "item" .= favoriteImplItem
      ]


-- | Construct a value of type 'FavoriteImpl' (by applying it's required fields, if any)
mkFavoriteImpl
  :: FavoriteImpl
mkFavoriteImpl =
  FavoriteImpl
  { favoriteImplClass = Nothing
  , favoriteImplLinks = Nothing
  , favoriteImplItem = Nothing
  }

-- ** FavoriteImpllinks
-- | FavoriteImpllinks
data FavoriteImpllinks = FavoriteImpllinks
  { favoriteImpllinksSelf :: !(Maybe Link) -- ^ "self"
  , favoriteImpllinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FavoriteImpllinks
instance A.FromJSON FavoriteImpllinks where
  parseJSON = A.withObject "FavoriteImpllinks" $ \o ->
    FavoriteImpllinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON FavoriteImpllinks
instance A.ToJSON FavoriteImpllinks where
  toJSON FavoriteImpllinks {..} =
   _omitNulls
      [ "self" .= favoriteImpllinksSelf
      , "_class" .= favoriteImpllinksClass
      ]


-- | Construct a value of type 'FavoriteImpllinks' (by applying it's required fields, if any)
mkFavoriteImpllinks
  :: FavoriteImpllinks
mkFavoriteImpllinks =
  FavoriteImpllinks
  { favoriteImpllinksSelf = Nothing
  , favoriteImpllinksClass = Nothing
  }

-- ** FreeStyleBuild
-- | FreeStyleBuild
data FreeStyleBuild = FreeStyleBuild
  { freeStyleBuildClass :: !(Maybe Text) -- ^ "_class"
  , freeStyleBuildNumber :: !(Maybe Int) -- ^ "number"
  , freeStyleBuildUrl :: !(Maybe Text) -- ^ "url"
  , freeStyleBuildActions :: !(Maybe [CauseAction]) -- ^ "actions"
  , freeStyleBuildBuilding :: !(Maybe Bool) -- ^ "building"
  , freeStyleBuildDescription :: !(Maybe Text) -- ^ "description"
  , freeStyleBuildDisplayName :: !(Maybe Text) -- ^ "displayName"
  , freeStyleBuildDuration :: !(Maybe Int) -- ^ "duration"
  , freeStyleBuildEstimatedDuration :: !(Maybe Int) -- ^ "estimatedDuration"
  , freeStyleBuildExecutor :: !(Maybe Text) -- ^ "executor"
  , freeStyleBuildFullDisplayName :: !(Maybe Text) -- ^ "fullDisplayName"
  , freeStyleBuildId :: !(Maybe Text) -- ^ "id"
  , freeStyleBuildKeepLog :: !(Maybe Bool) -- ^ "keepLog"
  , freeStyleBuildQueueId :: !(Maybe Int) -- ^ "queueId"
  , freeStyleBuildResult :: !(Maybe Text) -- ^ "result"
  , freeStyleBuildTimestamp :: !(Maybe Int) -- ^ "timestamp"
  , freeStyleBuildBuiltOn :: !(Maybe Text) -- ^ "builtOn"
  , freeStyleBuildChangeSet :: !(Maybe EmptyChangeLogSet) -- ^ "changeSet"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FreeStyleBuild
instance A.FromJSON FreeStyleBuild where
  parseJSON = A.withObject "FreeStyleBuild" $ \o ->
    FreeStyleBuild
      <$> (o .:? "_class")
      <*> (o .:? "number")
      <*> (o .:? "url")
      <*> (o .:? "actions")
      <*> (o .:? "building")
      <*> (o .:? "description")
      <*> (o .:? "displayName")
      <*> (o .:? "duration")
      <*> (o .:? "estimatedDuration")
      <*> (o .:? "executor")
      <*> (o .:? "fullDisplayName")
      <*> (o .:? "id")
      <*> (o .:? "keepLog")
      <*> (o .:? "queueId")
      <*> (o .:? "result")
      <*> (o .:? "timestamp")
      <*> (o .:? "builtOn")
      <*> (o .:? "changeSet")

-- | ToJSON FreeStyleBuild
instance A.ToJSON FreeStyleBuild where
  toJSON FreeStyleBuild {..} =
   _omitNulls
      [ "_class" .= freeStyleBuildClass
      , "number" .= freeStyleBuildNumber
      , "url" .= freeStyleBuildUrl
      , "actions" .= freeStyleBuildActions
      , "building" .= freeStyleBuildBuilding
      , "description" .= freeStyleBuildDescription
      , "displayName" .= freeStyleBuildDisplayName
      , "duration" .= freeStyleBuildDuration
      , "estimatedDuration" .= freeStyleBuildEstimatedDuration
      , "executor" .= freeStyleBuildExecutor
      , "fullDisplayName" .= freeStyleBuildFullDisplayName
      , "id" .= freeStyleBuildId
      , "keepLog" .= freeStyleBuildKeepLog
      , "queueId" .= freeStyleBuildQueueId
      , "result" .= freeStyleBuildResult
      , "timestamp" .= freeStyleBuildTimestamp
      , "builtOn" .= freeStyleBuildBuiltOn
      , "changeSet" .= freeStyleBuildChangeSet
      ]


-- | Construct a value of type 'FreeStyleBuild' (by applying it's required fields, if any)
mkFreeStyleBuild
  :: FreeStyleBuild
mkFreeStyleBuild =
  FreeStyleBuild
  { freeStyleBuildClass = Nothing
  , freeStyleBuildNumber = Nothing
  , freeStyleBuildUrl = Nothing
  , freeStyleBuildActions = Nothing
  , freeStyleBuildBuilding = Nothing
  , freeStyleBuildDescription = Nothing
  , freeStyleBuildDisplayName = Nothing
  , freeStyleBuildDuration = Nothing
  , freeStyleBuildEstimatedDuration = Nothing
  , freeStyleBuildExecutor = Nothing
  , freeStyleBuildFullDisplayName = Nothing
  , freeStyleBuildId = Nothing
  , freeStyleBuildKeepLog = Nothing
  , freeStyleBuildQueueId = Nothing
  , freeStyleBuildResult = Nothing
  , freeStyleBuildTimestamp = Nothing
  , freeStyleBuildBuiltOn = Nothing
  , freeStyleBuildChangeSet = Nothing
  }

-- ** FreeStyleProject
-- | FreeStyleProject
data FreeStyleProject = FreeStyleProject
  { freeStyleProjectClass :: !(Maybe Text) -- ^ "_class"
  , freeStyleProjectName :: !(Maybe Text) -- ^ "name"
  , freeStyleProjectUrl :: !(Maybe Text) -- ^ "url"
  , freeStyleProjectColor :: !(Maybe Text) -- ^ "color"
  , freeStyleProjectActions :: !(Maybe [FreeStyleProjectactions]) -- ^ "actions"
  , freeStyleProjectDescription :: !(Maybe Text) -- ^ "description"
  , freeStyleProjectDisplayName :: !(Maybe Text) -- ^ "displayName"
  , freeStyleProjectDisplayNameOrNull :: !(Maybe Text) -- ^ "displayNameOrNull"
  , freeStyleProjectFullDisplayName :: !(Maybe Text) -- ^ "fullDisplayName"
  , freeStyleProjectFullName :: !(Maybe Text) -- ^ "fullName"
  , freeStyleProjectBuildable :: !(Maybe Bool) -- ^ "buildable"
  , freeStyleProjectBuilds :: !(Maybe [FreeStyleBuild]) -- ^ "builds"
  , freeStyleProjectFirstBuild :: !(Maybe FreeStyleBuild) -- ^ "firstBuild"
  , freeStyleProjectHealthReport :: !(Maybe [FreeStyleProjecthealthReport]) -- ^ "healthReport"
  , freeStyleProjectInQueue :: !(Maybe Bool) -- ^ "inQueue"
  , freeStyleProjectKeepDependencies :: !(Maybe Bool) -- ^ "keepDependencies"
  , freeStyleProjectLastBuild :: !(Maybe FreeStyleBuild) -- ^ "lastBuild"
  , freeStyleProjectLastCompletedBuild :: !(Maybe FreeStyleBuild) -- ^ "lastCompletedBuild"
  , freeStyleProjectLastFailedBuild :: !(Maybe Text) -- ^ "lastFailedBuild"
  , freeStyleProjectLastStableBuild :: !(Maybe FreeStyleBuild) -- ^ "lastStableBuild"
  , freeStyleProjectLastSuccessfulBuild :: !(Maybe FreeStyleBuild) -- ^ "lastSuccessfulBuild"
  , freeStyleProjectLastUnstableBuild :: !(Maybe Text) -- ^ "lastUnstableBuild"
  , freeStyleProjectLastUnsuccessfulBuild :: !(Maybe Text) -- ^ "lastUnsuccessfulBuild"
  , freeStyleProjectNextBuildNumber :: !(Maybe Int) -- ^ "nextBuildNumber"
  , freeStyleProjectQueueItem :: !(Maybe Text) -- ^ "queueItem"
  , freeStyleProjectConcurrentBuild :: !(Maybe Bool) -- ^ "concurrentBuild"
  , freeStyleProjectScm :: !(Maybe NullSCM) -- ^ "scm"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FreeStyleProject
instance A.FromJSON FreeStyleProject where
  parseJSON = A.withObject "FreeStyleProject" $ \o ->
    FreeStyleProject
      <$> (o .:? "_class")
      <*> (o .:? "name")
      <*> (o .:? "url")
      <*> (o .:? "color")
      <*> (o .:? "actions")
      <*> (o .:? "description")
      <*> (o .:? "displayName")
      <*> (o .:? "displayNameOrNull")
      <*> (o .:? "fullDisplayName")
      <*> (o .:? "fullName")
      <*> (o .:? "buildable")
      <*> (o .:? "builds")
      <*> (o .:? "firstBuild")
      <*> (o .:? "healthReport")
      <*> (o .:? "inQueue")
      <*> (o .:? "keepDependencies")
      <*> (o .:? "lastBuild")
      <*> (o .:? "lastCompletedBuild")
      <*> (o .:? "lastFailedBuild")
      <*> (o .:? "lastStableBuild")
      <*> (o .:? "lastSuccessfulBuild")
      <*> (o .:? "lastUnstableBuild")
      <*> (o .:? "lastUnsuccessfulBuild")
      <*> (o .:? "nextBuildNumber")
      <*> (o .:? "queueItem")
      <*> (o .:? "concurrentBuild")
      <*> (o .:? "scm")

-- | ToJSON FreeStyleProject
instance A.ToJSON FreeStyleProject where
  toJSON FreeStyleProject {..} =
   _omitNulls
      [ "_class" .= freeStyleProjectClass
      , "name" .= freeStyleProjectName
      , "url" .= freeStyleProjectUrl
      , "color" .= freeStyleProjectColor
      , "actions" .= freeStyleProjectActions
      , "description" .= freeStyleProjectDescription
      , "displayName" .= freeStyleProjectDisplayName
      , "displayNameOrNull" .= freeStyleProjectDisplayNameOrNull
      , "fullDisplayName" .= freeStyleProjectFullDisplayName
      , "fullName" .= freeStyleProjectFullName
      , "buildable" .= freeStyleProjectBuildable
      , "builds" .= freeStyleProjectBuilds
      , "firstBuild" .= freeStyleProjectFirstBuild
      , "healthReport" .= freeStyleProjectHealthReport
      , "inQueue" .= freeStyleProjectInQueue
      , "keepDependencies" .= freeStyleProjectKeepDependencies
      , "lastBuild" .= freeStyleProjectLastBuild
      , "lastCompletedBuild" .= freeStyleProjectLastCompletedBuild
      , "lastFailedBuild" .= freeStyleProjectLastFailedBuild
      , "lastStableBuild" .= freeStyleProjectLastStableBuild
      , "lastSuccessfulBuild" .= freeStyleProjectLastSuccessfulBuild
      , "lastUnstableBuild" .= freeStyleProjectLastUnstableBuild
      , "lastUnsuccessfulBuild" .= freeStyleProjectLastUnsuccessfulBuild
      , "nextBuildNumber" .= freeStyleProjectNextBuildNumber
      , "queueItem" .= freeStyleProjectQueueItem
      , "concurrentBuild" .= freeStyleProjectConcurrentBuild
      , "scm" .= freeStyleProjectScm
      ]


-- | Construct a value of type 'FreeStyleProject' (by applying it's required fields, if any)
mkFreeStyleProject
  :: FreeStyleProject
mkFreeStyleProject =
  FreeStyleProject
  { freeStyleProjectClass = Nothing
  , freeStyleProjectName = Nothing
  , freeStyleProjectUrl = Nothing
  , freeStyleProjectColor = Nothing
  , freeStyleProjectActions = Nothing
  , freeStyleProjectDescription = Nothing
  , freeStyleProjectDisplayName = Nothing
  , freeStyleProjectDisplayNameOrNull = Nothing
  , freeStyleProjectFullDisplayName = Nothing
  , freeStyleProjectFullName = Nothing
  , freeStyleProjectBuildable = Nothing
  , freeStyleProjectBuilds = Nothing
  , freeStyleProjectFirstBuild = Nothing
  , freeStyleProjectHealthReport = Nothing
  , freeStyleProjectInQueue = Nothing
  , freeStyleProjectKeepDependencies = Nothing
  , freeStyleProjectLastBuild = Nothing
  , freeStyleProjectLastCompletedBuild = Nothing
  , freeStyleProjectLastFailedBuild = Nothing
  , freeStyleProjectLastStableBuild = Nothing
  , freeStyleProjectLastSuccessfulBuild = Nothing
  , freeStyleProjectLastUnstableBuild = Nothing
  , freeStyleProjectLastUnsuccessfulBuild = Nothing
  , freeStyleProjectNextBuildNumber = Nothing
  , freeStyleProjectQueueItem = Nothing
  , freeStyleProjectConcurrentBuild = Nothing
  , freeStyleProjectScm = Nothing
  }

-- ** FreeStyleProjectactions
-- | FreeStyleProjectactions
data FreeStyleProjectactions = FreeStyleProjectactions
  { freeStyleProjectactionsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FreeStyleProjectactions
instance A.FromJSON FreeStyleProjectactions where
  parseJSON = A.withObject "FreeStyleProjectactions" $ \o ->
    FreeStyleProjectactions
      <$> (o .:? "_class")

-- | ToJSON FreeStyleProjectactions
instance A.ToJSON FreeStyleProjectactions where
  toJSON FreeStyleProjectactions {..} =
   _omitNulls
      [ "_class" .= freeStyleProjectactionsClass
      ]


-- | Construct a value of type 'FreeStyleProjectactions' (by applying it's required fields, if any)
mkFreeStyleProjectactions
  :: FreeStyleProjectactions
mkFreeStyleProjectactions =
  FreeStyleProjectactions
  { freeStyleProjectactionsClass = Nothing
  }

-- ** FreeStyleProjecthealthReport
-- | FreeStyleProjecthealthReport
data FreeStyleProjecthealthReport = FreeStyleProjecthealthReport
  { freeStyleProjecthealthReportDescription :: !(Maybe Text) -- ^ "description"
  , freeStyleProjecthealthReportIconClassName :: !(Maybe Text) -- ^ "iconClassName"
  , freeStyleProjecthealthReportIconUrl :: !(Maybe Text) -- ^ "iconUrl"
  , freeStyleProjecthealthReportScore :: !(Maybe Int) -- ^ "score"
  , freeStyleProjecthealthReportClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FreeStyleProjecthealthReport
instance A.FromJSON FreeStyleProjecthealthReport where
  parseJSON = A.withObject "FreeStyleProjecthealthReport" $ \o ->
    FreeStyleProjecthealthReport
      <$> (o .:? "description")
      <*> (o .:? "iconClassName")
      <*> (o .:? "iconUrl")
      <*> (o .:? "score")
      <*> (o .:? "_class")

-- | ToJSON FreeStyleProjecthealthReport
instance A.ToJSON FreeStyleProjecthealthReport where
  toJSON FreeStyleProjecthealthReport {..} =
   _omitNulls
      [ "description" .= freeStyleProjecthealthReportDescription
      , "iconClassName" .= freeStyleProjecthealthReportIconClassName
      , "iconUrl" .= freeStyleProjecthealthReportIconUrl
      , "score" .= freeStyleProjecthealthReportScore
      , "_class" .= freeStyleProjecthealthReportClass
      ]


-- | Construct a value of type 'FreeStyleProjecthealthReport' (by applying it's required fields, if any)
mkFreeStyleProjecthealthReport
  :: FreeStyleProjecthealthReport
mkFreeStyleProjecthealthReport =
  FreeStyleProjecthealthReport
  { freeStyleProjecthealthReportDescription = Nothing
  , freeStyleProjecthealthReportIconClassName = Nothing
  , freeStyleProjecthealthReportIconUrl = Nothing
  , freeStyleProjecthealthReportScore = Nothing
  , freeStyleProjecthealthReportClass = Nothing
  }

-- ** GenericResource
-- | GenericResource
data GenericResource = GenericResource
  { genericResourceClass :: !(Maybe Text) -- ^ "_class"
  , genericResourceDisplayName :: !(Maybe Text) -- ^ "displayName"
  , genericResourceDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , genericResourceId :: !(Maybe Text) -- ^ "id"
  , genericResourceResult :: !(Maybe Text) -- ^ "result"
  , genericResourceStartTime :: !(Maybe Text) -- ^ "startTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GenericResource
instance A.FromJSON GenericResource where
  parseJSON = A.withObject "GenericResource" $ \o ->
    GenericResource
      <$> (o .:? "_class")
      <*> (o .:? "displayName")
      <*> (o .:? "durationInMillis")
      <*> (o .:? "id")
      <*> (o .:? "result")
      <*> (o .:? "startTime")

-- | ToJSON GenericResource
instance A.ToJSON GenericResource where
  toJSON GenericResource {..} =
   _omitNulls
      [ "_class" .= genericResourceClass
      , "displayName" .= genericResourceDisplayName
      , "durationInMillis" .= genericResourceDurationInMillis
      , "id" .= genericResourceId
      , "result" .= genericResourceResult
      , "startTime" .= genericResourceStartTime
      ]


-- | Construct a value of type 'GenericResource' (by applying it's required fields, if any)
mkGenericResource
  :: GenericResource
mkGenericResource =
  GenericResource
  { genericResourceClass = Nothing
  , genericResourceDisplayName = Nothing
  , genericResourceDurationInMillis = Nothing
  , genericResourceId = Nothing
  , genericResourceResult = Nothing
  , genericResourceStartTime = Nothing
  }

-- ** GithubContent
-- | GithubContent
data GithubContent = GithubContent
  { githubContentName :: !(Maybe Text) -- ^ "name"
  , githubContentSha :: !(Maybe Text) -- ^ "sha"
  , githubContentClass :: !(Maybe Text) -- ^ "_class"
  , githubContentRepo :: !(Maybe Text) -- ^ "repo"
  , githubContentSize :: !(Maybe Int) -- ^ "size"
  , githubContentOwner :: !(Maybe Text) -- ^ "owner"
  , githubContentPath :: !(Maybe Text) -- ^ "path"
  , githubContentBase64Data :: !(Maybe Text) -- ^ "base64Data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubContent
instance A.FromJSON GithubContent where
  parseJSON = A.withObject "GithubContent" $ \o ->
    GithubContent
      <$> (o .:? "name")
      <*> (o .:? "sha")
      <*> (o .:? "_class")
      <*> (o .:? "repo")
      <*> (o .:? "size")
      <*> (o .:? "owner")
      <*> (o .:? "path")
      <*> (o .:? "base64Data")

-- | ToJSON GithubContent
instance A.ToJSON GithubContent where
  toJSON GithubContent {..} =
   _omitNulls
      [ "name" .= githubContentName
      , "sha" .= githubContentSha
      , "_class" .= githubContentClass
      , "repo" .= githubContentRepo
      , "size" .= githubContentSize
      , "owner" .= githubContentOwner
      , "path" .= githubContentPath
      , "base64Data" .= githubContentBase64Data
      ]


-- | Construct a value of type 'GithubContent' (by applying it's required fields, if any)
mkGithubContent
  :: GithubContent
mkGithubContent =
  GithubContent
  { githubContentName = Nothing
  , githubContentSha = Nothing
  , githubContentClass = Nothing
  , githubContentRepo = Nothing
  , githubContentSize = Nothing
  , githubContentOwner = Nothing
  , githubContentPath = Nothing
  , githubContentBase64Data = Nothing
  }

-- ** GithubFile
-- | GithubFile
data GithubFile = GithubFile
  { githubFileContent :: !(Maybe GithubContent) -- ^ "content"
  , githubFileClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubFile
instance A.FromJSON GithubFile where
  parseJSON = A.withObject "GithubFile" $ \o ->
    GithubFile
      <$> (o .:? "content")
      <*> (o .:? "_class")

-- | ToJSON GithubFile
instance A.ToJSON GithubFile where
  toJSON GithubFile {..} =
   _omitNulls
      [ "content" .= githubFileContent
      , "_class" .= githubFileClass
      ]


-- | Construct a value of type 'GithubFile' (by applying it's required fields, if any)
mkGithubFile
  :: GithubFile
mkGithubFile =
  GithubFile
  { githubFileContent = Nothing
  , githubFileClass = Nothing
  }

-- ** GithubOrganization
-- | GithubOrganization
data GithubOrganization = GithubOrganization
  { githubOrganizationClass :: !(Maybe Text) -- ^ "_class"
  , githubOrganizationLinks :: !(Maybe GithubOrganizationlinks) -- ^ "_links"
  , githubOrganizationJenkinsOrganizationPipeline :: !(Maybe Bool) -- ^ "jenkinsOrganizationPipeline"
  , githubOrganizationName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubOrganization
instance A.FromJSON GithubOrganization where
  parseJSON = A.withObject "GithubOrganization" $ \o ->
    GithubOrganization
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "jenkinsOrganizationPipeline")
      <*> (o .:? "name")

-- | ToJSON GithubOrganization
instance A.ToJSON GithubOrganization where
  toJSON GithubOrganization {..} =
   _omitNulls
      [ "_class" .= githubOrganizationClass
      , "_links" .= githubOrganizationLinks
      , "jenkinsOrganizationPipeline" .= githubOrganizationJenkinsOrganizationPipeline
      , "name" .= githubOrganizationName
      ]


-- | Construct a value of type 'GithubOrganization' (by applying it's required fields, if any)
mkGithubOrganization
  :: GithubOrganization
mkGithubOrganization =
  GithubOrganization
  { githubOrganizationClass = Nothing
  , githubOrganizationLinks = Nothing
  , githubOrganizationJenkinsOrganizationPipeline = Nothing
  , githubOrganizationName = Nothing
  }

-- ** GithubOrganizationlinks
-- | GithubOrganizationlinks
data GithubOrganizationlinks = GithubOrganizationlinks
  { githubOrganizationlinksRepositories :: !(Maybe Link) -- ^ "repositories"
  , githubOrganizationlinksSelf :: !(Maybe Link) -- ^ "self"
  , githubOrganizationlinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubOrganizationlinks
instance A.FromJSON GithubOrganizationlinks where
  parseJSON = A.withObject "GithubOrganizationlinks" $ \o ->
    GithubOrganizationlinks
      <$> (o .:? "repositories")
      <*> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON GithubOrganizationlinks
instance A.ToJSON GithubOrganizationlinks where
  toJSON GithubOrganizationlinks {..} =
   _omitNulls
      [ "repositories" .= githubOrganizationlinksRepositories
      , "self" .= githubOrganizationlinksSelf
      , "_class" .= githubOrganizationlinksClass
      ]


-- | Construct a value of type 'GithubOrganizationlinks' (by applying it's required fields, if any)
mkGithubOrganizationlinks
  :: GithubOrganizationlinks
mkGithubOrganizationlinks =
  GithubOrganizationlinks
  { githubOrganizationlinksRepositories = Nothing
  , githubOrganizationlinksSelf = Nothing
  , githubOrganizationlinksClass = Nothing
  }

-- ** GithubRepositories
-- | GithubRepositories
data GithubRepositories = GithubRepositories
  { githubRepositoriesClass :: !(Maybe Text) -- ^ "_class"
  , githubRepositoriesLinks :: !(Maybe GithubRepositorieslinks) -- ^ "_links"
  , githubRepositoriesItems :: !(Maybe [GithubRepository]) -- ^ "items"
  , githubRepositoriesLastPage :: !(Maybe Int) -- ^ "lastPage"
  , githubRepositoriesNextPage :: !(Maybe Int) -- ^ "nextPage"
  , githubRepositoriesPageSize :: !(Maybe Int) -- ^ "pageSize"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubRepositories
instance A.FromJSON GithubRepositories where
  parseJSON = A.withObject "GithubRepositories" $ \o ->
    GithubRepositories
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "items")
      <*> (o .:? "lastPage")
      <*> (o .:? "nextPage")
      <*> (o .:? "pageSize")

-- | ToJSON GithubRepositories
instance A.ToJSON GithubRepositories where
  toJSON GithubRepositories {..} =
   _omitNulls
      [ "_class" .= githubRepositoriesClass
      , "_links" .= githubRepositoriesLinks
      , "items" .= githubRepositoriesItems
      , "lastPage" .= githubRepositoriesLastPage
      , "nextPage" .= githubRepositoriesNextPage
      , "pageSize" .= githubRepositoriesPageSize
      ]


-- | Construct a value of type 'GithubRepositories' (by applying it's required fields, if any)
mkGithubRepositories
  :: GithubRepositories
mkGithubRepositories =
  GithubRepositories
  { githubRepositoriesClass = Nothing
  , githubRepositoriesLinks = Nothing
  , githubRepositoriesItems = Nothing
  , githubRepositoriesLastPage = Nothing
  , githubRepositoriesNextPage = Nothing
  , githubRepositoriesPageSize = Nothing
  }

-- ** GithubRepositorieslinks
-- | GithubRepositorieslinks
data GithubRepositorieslinks = GithubRepositorieslinks
  { githubRepositorieslinksSelf :: !(Maybe Link) -- ^ "self"
  , githubRepositorieslinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubRepositorieslinks
instance A.FromJSON GithubRepositorieslinks where
  parseJSON = A.withObject "GithubRepositorieslinks" $ \o ->
    GithubRepositorieslinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON GithubRepositorieslinks
instance A.ToJSON GithubRepositorieslinks where
  toJSON GithubRepositorieslinks {..} =
   _omitNulls
      [ "self" .= githubRepositorieslinksSelf
      , "_class" .= githubRepositorieslinksClass
      ]


-- | Construct a value of type 'GithubRepositorieslinks' (by applying it's required fields, if any)
mkGithubRepositorieslinks
  :: GithubRepositorieslinks
mkGithubRepositorieslinks =
  GithubRepositorieslinks
  { githubRepositorieslinksSelf = Nothing
  , githubRepositorieslinksClass = Nothing
  }

-- ** GithubRepository
-- | GithubRepository
data GithubRepository = GithubRepository
  { githubRepositoryClass :: !(Maybe Text) -- ^ "_class"
  , githubRepositoryLinks :: !(Maybe GithubRepositorylinks) -- ^ "_links"
  , githubRepositoryDefaultBranch :: !(Maybe Text) -- ^ "defaultBranch"
  , githubRepositoryDescription :: !(Maybe Text) -- ^ "description"
  , githubRepositoryName :: !(Maybe Text) -- ^ "name"
  , githubRepositoryPermissions :: !(Maybe GithubRepositorypermissions) -- ^ "permissions"
  , githubRepositoryPrivate :: !(Maybe Bool) -- ^ "private"
  , githubRepositoryFullName :: !(Maybe Text) -- ^ "fullName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubRepository
instance A.FromJSON GithubRepository where
  parseJSON = A.withObject "GithubRepository" $ \o ->
    GithubRepository
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "defaultBranch")
      <*> (o .:? "description")
      <*> (o .:? "name")
      <*> (o .:? "permissions")
      <*> (o .:? "private")
      <*> (o .:? "fullName")

-- | ToJSON GithubRepository
instance A.ToJSON GithubRepository where
  toJSON GithubRepository {..} =
   _omitNulls
      [ "_class" .= githubRepositoryClass
      , "_links" .= githubRepositoryLinks
      , "defaultBranch" .= githubRepositoryDefaultBranch
      , "description" .= githubRepositoryDescription
      , "name" .= githubRepositoryName
      , "permissions" .= githubRepositoryPermissions
      , "private" .= githubRepositoryPrivate
      , "fullName" .= githubRepositoryFullName
      ]


-- | Construct a value of type 'GithubRepository' (by applying it's required fields, if any)
mkGithubRepository
  :: GithubRepository
mkGithubRepository =
  GithubRepository
  { githubRepositoryClass = Nothing
  , githubRepositoryLinks = Nothing
  , githubRepositoryDefaultBranch = Nothing
  , githubRepositoryDescription = Nothing
  , githubRepositoryName = Nothing
  , githubRepositoryPermissions = Nothing
  , githubRepositoryPrivate = Nothing
  , githubRepositoryFullName = Nothing
  }

-- ** GithubRepositorylinks
-- | GithubRepositorylinks
data GithubRepositorylinks = GithubRepositorylinks
  { githubRepositorylinksSelf :: !(Maybe Link) -- ^ "self"
  , githubRepositorylinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubRepositorylinks
instance A.FromJSON GithubRepositorylinks where
  parseJSON = A.withObject "GithubRepositorylinks" $ \o ->
    GithubRepositorylinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON GithubRepositorylinks
instance A.ToJSON GithubRepositorylinks where
  toJSON GithubRepositorylinks {..} =
   _omitNulls
      [ "self" .= githubRepositorylinksSelf
      , "_class" .= githubRepositorylinksClass
      ]


-- | Construct a value of type 'GithubRepositorylinks' (by applying it's required fields, if any)
mkGithubRepositorylinks
  :: GithubRepositorylinks
mkGithubRepositorylinks =
  GithubRepositorylinks
  { githubRepositorylinksSelf = Nothing
  , githubRepositorylinksClass = Nothing
  }

-- ** GithubRepositorypermissions
-- | GithubRepositorypermissions
data GithubRepositorypermissions = GithubRepositorypermissions
  { githubRepositorypermissionsAdmin :: !(Maybe Bool) -- ^ "admin"
  , githubRepositorypermissionsPush :: !(Maybe Bool) -- ^ "push"
  , githubRepositorypermissionsPull :: !(Maybe Bool) -- ^ "pull"
  , githubRepositorypermissionsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubRepositorypermissions
instance A.FromJSON GithubRepositorypermissions where
  parseJSON = A.withObject "GithubRepositorypermissions" $ \o ->
    GithubRepositorypermissions
      <$> (o .:? "admin")
      <*> (o .:? "push")
      <*> (o .:? "pull")
      <*> (o .:? "_class")

-- | ToJSON GithubRepositorypermissions
instance A.ToJSON GithubRepositorypermissions where
  toJSON GithubRepositorypermissions {..} =
   _omitNulls
      [ "admin" .= githubRepositorypermissionsAdmin
      , "push" .= githubRepositorypermissionsPush
      , "pull" .= githubRepositorypermissionsPull
      , "_class" .= githubRepositorypermissionsClass
      ]


-- | Construct a value of type 'GithubRepositorypermissions' (by applying it's required fields, if any)
mkGithubRepositorypermissions
  :: GithubRepositorypermissions
mkGithubRepositorypermissions =
  GithubRepositorypermissions
  { githubRepositorypermissionsAdmin = Nothing
  , githubRepositorypermissionsPush = Nothing
  , githubRepositorypermissionsPull = Nothing
  , githubRepositorypermissionsClass = Nothing
  }

-- ** GithubRespositoryContainer
-- | GithubRespositoryContainer
data GithubRespositoryContainer = GithubRespositoryContainer
  { githubRespositoryContainerClass :: !(Maybe Text) -- ^ "_class"
  , githubRespositoryContainerLinks :: !(Maybe GithubRespositoryContainerlinks) -- ^ "_links"
  , githubRespositoryContainerRepositories :: !(Maybe GithubRepositories) -- ^ "repositories"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubRespositoryContainer
instance A.FromJSON GithubRespositoryContainer where
  parseJSON = A.withObject "GithubRespositoryContainer" $ \o ->
    GithubRespositoryContainer
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "repositories")

-- | ToJSON GithubRespositoryContainer
instance A.ToJSON GithubRespositoryContainer where
  toJSON GithubRespositoryContainer {..} =
   _omitNulls
      [ "_class" .= githubRespositoryContainerClass
      , "_links" .= githubRespositoryContainerLinks
      , "repositories" .= githubRespositoryContainerRepositories
      ]


-- | Construct a value of type 'GithubRespositoryContainer' (by applying it's required fields, if any)
mkGithubRespositoryContainer
  :: GithubRespositoryContainer
mkGithubRespositoryContainer =
  GithubRespositoryContainer
  { githubRespositoryContainerClass = Nothing
  , githubRespositoryContainerLinks = Nothing
  , githubRespositoryContainerRepositories = Nothing
  }

-- ** GithubRespositoryContainerlinks
-- | GithubRespositoryContainerlinks
data GithubRespositoryContainerlinks = GithubRespositoryContainerlinks
  { githubRespositoryContainerlinksSelf :: !(Maybe Link) -- ^ "self"
  , githubRespositoryContainerlinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubRespositoryContainerlinks
instance A.FromJSON GithubRespositoryContainerlinks where
  parseJSON = A.withObject "GithubRespositoryContainerlinks" $ \o ->
    GithubRespositoryContainerlinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON GithubRespositoryContainerlinks
instance A.ToJSON GithubRespositoryContainerlinks where
  toJSON GithubRespositoryContainerlinks {..} =
   _omitNulls
      [ "self" .= githubRespositoryContainerlinksSelf
      , "_class" .= githubRespositoryContainerlinksClass
      ]


-- | Construct a value of type 'GithubRespositoryContainerlinks' (by applying it's required fields, if any)
mkGithubRespositoryContainerlinks
  :: GithubRespositoryContainerlinks
mkGithubRespositoryContainerlinks =
  GithubRespositoryContainerlinks
  { githubRespositoryContainerlinksSelf = Nothing
  , githubRespositoryContainerlinksClass = Nothing
  }

-- ** GithubScm
-- | GithubScm
data GithubScm = GithubScm
  { githubScmClass :: !(Maybe Text) -- ^ "_class"
  , githubScmLinks :: !(Maybe GithubScmlinks) -- ^ "_links"
  , githubScmCredentialId :: !(Maybe Text) -- ^ "credentialId"
  , githubScmId :: !(Maybe Text) -- ^ "id"
  , githubScmUri :: !(Maybe Text) -- ^ "uri"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubScm
instance A.FromJSON GithubScm where
  parseJSON = A.withObject "GithubScm" $ \o ->
    GithubScm
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "credentialId")
      <*> (o .:? "id")
      <*> (o .:? "uri")

-- | ToJSON GithubScm
instance A.ToJSON GithubScm where
  toJSON GithubScm {..} =
   _omitNulls
      [ "_class" .= githubScmClass
      , "_links" .= githubScmLinks
      , "credentialId" .= githubScmCredentialId
      , "id" .= githubScmId
      , "uri" .= githubScmUri
      ]


-- | Construct a value of type 'GithubScm' (by applying it's required fields, if any)
mkGithubScm
  :: GithubScm
mkGithubScm =
  GithubScm
  { githubScmClass = Nothing
  , githubScmLinks = Nothing
  , githubScmCredentialId = Nothing
  , githubScmId = Nothing
  , githubScmUri = Nothing
  }

-- ** GithubScmlinks
-- | GithubScmlinks
data GithubScmlinks = GithubScmlinks
  { githubScmlinksSelf :: !(Maybe Link) -- ^ "self"
  , githubScmlinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GithubScmlinks
instance A.FromJSON GithubScmlinks where
  parseJSON = A.withObject "GithubScmlinks" $ \o ->
    GithubScmlinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON GithubScmlinks
instance A.ToJSON GithubScmlinks where
  toJSON GithubScmlinks {..} =
   _omitNulls
      [ "self" .= githubScmlinksSelf
      , "_class" .= githubScmlinksClass
      ]


-- | Construct a value of type 'GithubScmlinks' (by applying it's required fields, if any)
mkGithubScmlinks
  :: GithubScmlinks
mkGithubScmlinks =
  GithubScmlinks
  { githubScmlinksSelf = Nothing
  , githubScmlinksClass = Nothing
  }

-- ** Hudson
-- | Hudson
data Hudson = Hudson
  { hudsonClass :: !(Maybe Text) -- ^ "_class"
  , hudsonAssignedLabels :: !(Maybe [HudsonassignedLabels]) -- ^ "assignedLabels"
  , hudsonMode :: !(Maybe Text) -- ^ "mode"
  , hudsonNodeDescription :: !(Maybe Text) -- ^ "nodeDescription"
  , hudsonNodeName :: !(Maybe Text) -- ^ "nodeName"
  , hudsonNumExecutors :: !(Maybe Int) -- ^ "numExecutors"
  , hudsonDescription :: !(Maybe Text) -- ^ "description"
  , hudsonJobs :: !(Maybe [FreeStyleProject]) -- ^ "jobs"
  , hudsonPrimaryView :: !(Maybe AllView) -- ^ "primaryView"
  , hudsonQuietingDown :: !(Maybe Bool) -- ^ "quietingDown"
  , hudsonSlaveAgentPort :: !(Maybe Int) -- ^ "slaveAgentPort"
  , hudsonUnlabeledLoad :: !(Maybe UnlabeledLoadStatistics) -- ^ "unlabeledLoad"
  , hudsonUseCrumbs :: !(Maybe Bool) -- ^ "useCrumbs"
  , hudsonUseSecurity :: !(Maybe Bool) -- ^ "useSecurity"
  , hudsonViews :: !(Maybe [AllView]) -- ^ "views"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Hudson
instance A.FromJSON Hudson where
  parseJSON = A.withObject "Hudson" $ \o ->
    Hudson
      <$> (o .:? "_class")
      <*> (o .:? "assignedLabels")
      <*> (o .:? "mode")
      <*> (o .:? "nodeDescription")
      <*> (o .:? "nodeName")
      <*> (o .:? "numExecutors")
      <*> (o .:? "description")
      <*> (o .:? "jobs")
      <*> (o .:? "primaryView")
      <*> (o .:? "quietingDown")
      <*> (o .:? "slaveAgentPort")
      <*> (o .:? "unlabeledLoad")
      <*> (o .:? "useCrumbs")
      <*> (o .:? "useSecurity")
      <*> (o .:? "views")

-- | ToJSON Hudson
instance A.ToJSON Hudson where
  toJSON Hudson {..} =
   _omitNulls
      [ "_class" .= hudsonClass
      , "assignedLabels" .= hudsonAssignedLabels
      , "mode" .= hudsonMode
      , "nodeDescription" .= hudsonNodeDescription
      , "nodeName" .= hudsonNodeName
      , "numExecutors" .= hudsonNumExecutors
      , "description" .= hudsonDescription
      , "jobs" .= hudsonJobs
      , "primaryView" .= hudsonPrimaryView
      , "quietingDown" .= hudsonQuietingDown
      , "slaveAgentPort" .= hudsonSlaveAgentPort
      , "unlabeledLoad" .= hudsonUnlabeledLoad
      , "useCrumbs" .= hudsonUseCrumbs
      , "useSecurity" .= hudsonUseSecurity
      , "views" .= hudsonViews
      ]


-- | Construct a value of type 'Hudson' (by applying it's required fields, if any)
mkHudson
  :: Hudson
mkHudson =
  Hudson
  { hudsonClass = Nothing
  , hudsonAssignedLabels = Nothing
  , hudsonMode = Nothing
  , hudsonNodeDescription = Nothing
  , hudsonNodeName = Nothing
  , hudsonNumExecutors = Nothing
  , hudsonDescription = Nothing
  , hudsonJobs = Nothing
  , hudsonPrimaryView = Nothing
  , hudsonQuietingDown = Nothing
  , hudsonSlaveAgentPort = Nothing
  , hudsonUnlabeledLoad = Nothing
  , hudsonUseCrumbs = Nothing
  , hudsonUseSecurity = Nothing
  , hudsonViews = Nothing
  }

-- ** HudsonMasterComputer
-- | HudsonMasterComputer
data HudsonMasterComputer = HudsonMasterComputer
  { hudsonMasterComputerClass :: !(Maybe Text) -- ^ "_class"
  , hudsonMasterComputerDisplayName :: !(Maybe Text) -- ^ "displayName"
  , hudsonMasterComputerExecutors :: !(Maybe [HudsonMasterComputerexecutors]) -- ^ "executors"
  , hudsonMasterComputerIcon :: !(Maybe Text) -- ^ "icon"
  , hudsonMasterComputerIconClassName :: !(Maybe Text) -- ^ "iconClassName"
  , hudsonMasterComputerIdle :: !(Maybe Bool) -- ^ "idle"
  , hudsonMasterComputerJnlpAgent :: !(Maybe Bool) -- ^ "jnlpAgent"
  , hudsonMasterComputerLaunchSupported :: !(Maybe Bool) -- ^ "launchSupported"
  , hudsonMasterComputerLoadStatistics :: !(Maybe Label1) -- ^ "loadStatistics"
  , hudsonMasterComputerManualLaunchAllowed :: !(Maybe Bool) -- ^ "manualLaunchAllowed"
  , hudsonMasterComputerMonitorData :: !(Maybe HudsonMasterComputermonitorData) -- ^ "monitorData"
  , hudsonMasterComputerNumExecutors :: !(Maybe Int) -- ^ "numExecutors"
  , hudsonMasterComputerOffline :: !(Maybe Bool) -- ^ "offline"
  , hudsonMasterComputerOfflineCause :: !(Maybe Text) -- ^ "offlineCause"
  , hudsonMasterComputerOfflineCauseReason :: !(Maybe Text) -- ^ "offlineCauseReason"
  , hudsonMasterComputerTemporarilyOffline :: !(Maybe Bool) -- ^ "temporarilyOffline"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HudsonMasterComputer
instance A.FromJSON HudsonMasterComputer where
  parseJSON = A.withObject "HudsonMasterComputer" $ \o ->
    HudsonMasterComputer
      <$> (o .:? "_class")
      <*> (o .:? "displayName")
      <*> (o .:? "executors")
      <*> (o .:? "icon")
      <*> (o .:? "iconClassName")
      <*> (o .:? "idle")
      <*> (o .:? "jnlpAgent")
      <*> (o .:? "launchSupported")
      <*> (o .:? "loadStatistics")
      <*> (o .:? "manualLaunchAllowed")
      <*> (o .:? "monitorData")
      <*> (o .:? "numExecutors")
      <*> (o .:? "offline")
      <*> (o .:? "offlineCause")
      <*> (o .:? "offlineCauseReason")
      <*> (o .:? "temporarilyOffline")

-- | ToJSON HudsonMasterComputer
instance A.ToJSON HudsonMasterComputer where
  toJSON HudsonMasterComputer {..} =
   _omitNulls
      [ "_class" .= hudsonMasterComputerClass
      , "displayName" .= hudsonMasterComputerDisplayName
      , "executors" .= hudsonMasterComputerExecutors
      , "icon" .= hudsonMasterComputerIcon
      , "iconClassName" .= hudsonMasterComputerIconClassName
      , "idle" .= hudsonMasterComputerIdle
      , "jnlpAgent" .= hudsonMasterComputerJnlpAgent
      , "launchSupported" .= hudsonMasterComputerLaunchSupported
      , "loadStatistics" .= hudsonMasterComputerLoadStatistics
      , "manualLaunchAllowed" .= hudsonMasterComputerManualLaunchAllowed
      , "monitorData" .= hudsonMasterComputerMonitorData
      , "numExecutors" .= hudsonMasterComputerNumExecutors
      , "offline" .= hudsonMasterComputerOffline
      , "offlineCause" .= hudsonMasterComputerOfflineCause
      , "offlineCauseReason" .= hudsonMasterComputerOfflineCauseReason
      , "temporarilyOffline" .= hudsonMasterComputerTemporarilyOffline
      ]


-- | Construct a value of type 'HudsonMasterComputer' (by applying it's required fields, if any)
mkHudsonMasterComputer
  :: HudsonMasterComputer
mkHudsonMasterComputer =
  HudsonMasterComputer
  { hudsonMasterComputerClass = Nothing
  , hudsonMasterComputerDisplayName = Nothing
  , hudsonMasterComputerExecutors = Nothing
  , hudsonMasterComputerIcon = Nothing
  , hudsonMasterComputerIconClassName = Nothing
  , hudsonMasterComputerIdle = Nothing
  , hudsonMasterComputerJnlpAgent = Nothing
  , hudsonMasterComputerLaunchSupported = Nothing
  , hudsonMasterComputerLoadStatistics = Nothing
  , hudsonMasterComputerManualLaunchAllowed = Nothing
  , hudsonMasterComputerMonitorData = Nothing
  , hudsonMasterComputerNumExecutors = Nothing
  , hudsonMasterComputerOffline = Nothing
  , hudsonMasterComputerOfflineCause = Nothing
  , hudsonMasterComputerOfflineCauseReason = Nothing
  , hudsonMasterComputerTemporarilyOffline = Nothing
  }

-- ** HudsonMasterComputerexecutors
-- | HudsonMasterComputerexecutors
data HudsonMasterComputerexecutors = HudsonMasterComputerexecutors
  { hudsonMasterComputerexecutorsCurrentExecutable :: !(Maybe FreeStyleBuild) -- ^ "currentExecutable"
  , hudsonMasterComputerexecutorsIdle :: !(Maybe Bool) -- ^ "idle"
  , hudsonMasterComputerexecutorsLikelyStuck :: !(Maybe Bool) -- ^ "likelyStuck"
  , hudsonMasterComputerexecutorsNumber :: !(Maybe Int) -- ^ "number"
  , hudsonMasterComputerexecutorsProgress :: !(Maybe Int) -- ^ "progress"
  , hudsonMasterComputerexecutorsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HudsonMasterComputerexecutors
instance A.FromJSON HudsonMasterComputerexecutors where
  parseJSON = A.withObject "HudsonMasterComputerexecutors" $ \o ->
    HudsonMasterComputerexecutors
      <$> (o .:? "currentExecutable")
      <*> (o .:? "idle")
      <*> (o .:? "likelyStuck")
      <*> (o .:? "number")
      <*> (o .:? "progress")
      <*> (o .:? "_class")

-- | ToJSON HudsonMasterComputerexecutors
instance A.ToJSON HudsonMasterComputerexecutors where
  toJSON HudsonMasterComputerexecutors {..} =
   _omitNulls
      [ "currentExecutable" .= hudsonMasterComputerexecutorsCurrentExecutable
      , "idle" .= hudsonMasterComputerexecutorsIdle
      , "likelyStuck" .= hudsonMasterComputerexecutorsLikelyStuck
      , "number" .= hudsonMasterComputerexecutorsNumber
      , "progress" .= hudsonMasterComputerexecutorsProgress
      , "_class" .= hudsonMasterComputerexecutorsClass
      ]


-- | Construct a value of type 'HudsonMasterComputerexecutors' (by applying it's required fields, if any)
mkHudsonMasterComputerexecutors
  :: HudsonMasterComputerexecutors
mkHudsonMasterComputerexecutors =
  HudsonMasterComputerexecutors
  { hudsonMasterComputerexecutorsCurrentExecutable = Nothing
  , hudsonMasterComputerexecutorsIdle = Nothing
  , hudsonMasterComputerexecutorsLikelyStuck = Nothing
  , hudsonMasterComputerexecutorsNumber = Nothing
  , hudsonMasterComputerexecutorsProgress = Nothing
  , hudsonMasterComputerexecutorsClass = Nothing
  }

-- ** HudsonMasterComputermonitorData
-- | HudsonMasterComputermonitorData
data HudsonMasterComputermonitorData = HudsonMasterComputermonitorData
  { hudsonMasterComputermonitorDataHudsonNodeMonitorsSwapSpaceMonitor :: !(Maybe SwapSpaceMonitorMemoryUsage2) -- ^ "hudson.node_monitors.SwapSpaceMonitor"
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsTemporarySpaceMonitor :: !(Maybe DiskSpaceMonitorDescriptorDiskSpace) -- ^ "hudson.node_monitors.TemporarySpaceMonitor"
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsDiskSpaceMonitor :: !(Maybe DiskSpaceMonitorDescriptorDiskSpace) -- ^ "hudson.node_monitors.DiskSpaceMonitor"
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsArchitectureMonitor :: !(Maybe Text) -- ^ "hudson.node_monitors.ArchitectureMonitor"
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsResponseTimeMonitor :: !(Maybe ResponseTimeMonitorData) -- ^ "hudson.node_monitors.ResponseTimeMonitor"
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsClockMonitor :: !(Maybe ClockDifference) -- ^ "hudson.node_monitors.ClockMonitor"
  , hudsonMasterComputermonitorDataClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HudsonMasterComputermonitorData
instance A.FromJSON HudsonMasterComputermonitorData where
  parseJSON = A.withObject "HudsonMasterComputermonitorData" $ \o ->
    HudsonMasterComputermonitorData
      <$> (o .:? "hudson.node_monitors.SwapSpaceMonitor")
      <*> (o .:? "hudson.node_monitors.TemporarySpaceMonitor")
      <*> (o .:? "hudson.node_monitors.DiskSpaceMonitor")
      <*> (o .:? "hudson.node_monitors.ArchitectureMonitor")
      <*> (o .:? "hudson.node_monitors.ResponseTimeMonitor")
      <*> (o .:? "hudson.node_monitors.ClockMonitor")
      <*> (o .:? "_class")

-- | ToJSON HudsonMasterComputermonitorData
instance A.ToJSON HudsonMasterComputermonitorData where
  toJSON HudsonMasterComputermonitorData {..} =
   _omitNulls
      [ "hudson.node_monitors.SwapSpaceMonitor" .= hudsonMasterComputermonitorDataHudsonNodeMonitorsSwapSpaceMonitor
      , "hudson.node_monitors.TemporarySpaceMonitor" .= hudsonMasterComputermonitorDataHudsonNodeMonitorsTemporarySpaceMonitor
      , "hudson.node_monitors.DiskSpaceMonitor" .= hudsonMasterComputermonitorDataHudsonNodeMonitorsDiskSpaceMonitor
      , "hudson.node_monitors.ArchitectureMonitor" .= hudsonMasterComputermonitorDataHudsonNodeMonitorsArchitectureMonitor
      , "hudson.node_monitors.ResponseTimeMonitor" .= hudsonMasterComputermonitorDataHudsonNodeMonitorsResponseTimeMonitor
      , "hudson.node_monitors.ClockMonitor" .= hudsonMasterComputermonitorDataHudsonNodeMonitorsClockMonitor
      , "_class" .= hudsonMasterComputermonitorDataClass
      ]


-- | Construct a value of type 'HudsonMasterComputermonitorData' (by applying it's required fields, if any)
mkHudsonMasterComputermonitorData
  :: HudsonMasterComputermonitorData
mkHudsonMasterComputermonitorData =
  HudsonMasterComputermonitorData
  { hudsonMasterComputermonitorDataHudsonNodeMonitorsSwapSpaceMonitor = Nothing
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsTemporarySpaceMonitor = Nothing
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsDiskSpaceMonitor = Nothing
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsArchitectureMonitor = Nothing
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsResponseTimeMonitor = Nothing
  , hudsonMasterComputermonitorDataHudsonNodeMonitorsClockMonitor = Nothing
  , hudsonMasterComputermonitorDataClass = Nothing
  }

-- ** HudsonassignedLabels
-- | HudsonassignedLabels
data HudsonassignedLabels = HudsonassignedLabels
  { hudsonassignedLabelsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HudsonassignedLabels
instance A.FromJSON HudsonassignedLabels where
  parseJSON = A.withObject "HudsonassignedLabels" $ \o ->
    HudsonassignedLabels
      <$> (o .:? "_class")

-- | ToJSON HudsonassignedLabels
instance A.ToJSON HudsonassignedLabels where
  toJSON HudsonassignedLabels {..} =
   _omitNulls
      [ "_class" .= hudsonassignedLabelsClass
      ]


-- | Construct a value of type 'HudsonassignedLabels' (by applying it's required fields, if any)
mkHudsonassignedLabels
  :: HudsonassignedLabels
mkHudsonassignedLabels =
  HudsonassignedLabels
  { hudsonassignedLabelsClass = Nothing
  }

-- ** InputStepImpl
-- | InputStepImpl
data InputStepImpl = InputStepImpl
  { inputStepImplClass :: !(Maybe Text) -- ^ "_class"
  , inputStepImplLinks :: !(Maybe InputStepImpllinks) -- ^ "_links"
  , inputStepImplId :: !(Maybe Text) -- ^ "id"
  , inputStepImplMessage :: !(Maybe Text) -- ^ "message"
  , inputStepImplOk :: !(Maybe Text) -- ^ "ok"
  , inputStepImplParameters :: !(Maybe [StringParameterDefinition]) -- ^ "parameters"
  , inputStepImplSubmitter :: !(Maybe Text) -- ^ "submitter"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InputStepImpl
instance A.FromJSON InputStepImpl where
  parseJSON = A.withObject "InputStepImpl" $ \o ->
    InputStepImpl
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "id")
      <*> (o .:? "message")
      <*> (o .:? "ok")
      <*> (o .:? "parameters")
      <*> (o .:? "submitter")

-- | ToJSON InputStepImpl
instance A.ToJSON InputStepImpl where
  toJSON InputStepImpl {..} =
   _omitNulls
      [ "_class" .= inputStepImplClass
      , "_links" .= inputStepImplLinks
      , "id" .= inputStepImplId
      , "message" .= inputStepImplMessage
      , "ok" .= inputStepImplOk
      , "parameters" .= inputStepImplParameters
      , "submitter" .= inputStepImplSubmitter
      ]


-- | Construct a value of type 'InputStepImpl' (by applying it's required fields, if any)
mkInputStepImpl
  :: InputStepImpl
mkInputStepImpl =
  InputStepImpl
  { inputStepImplClass = Nothing
  , inputStepImplLinks = Nothing
  , inputStepImplId = Nothing
  , inputStepImplMessage = Nothing
  , inputStepImplOk = Nothing
  , inputStepImplParameters = Nothing
  , inputStepImplSubmitter = Nothing
  }

-- ** InputStepImpllinks
-- | InputStepImpllinks
data InputStepImpllinks = InputStepImpllinks
  { inputStepImpllinksSelf :: !(Maybe Link) -- ^ "self"
  , inputStepImpllinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InputStepImpllinks
instance A.FromJSON InputStepImpllinks where
  parseJSON = A.withObject "InputStepImpllinks" $ \o ->
    InputStepImpllinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON InputStepImpllinks
instance A.ToJSON InputStepImpllinks where
  toJSON InputStepImpllinks {..} =
   _omitNulls
      [ "self" .= inputStepImpllinksSelf
      , "_class" .= inputStepImpllinksClass
      ]


-- | Construct a value of type 'InputStepImpllinks' (by applying it's required fields, if any)
mkInputStepImpllinks
  :: InputStepImpllinks
mkInputStepImpllinks =
  InputStepImpllinks
  { inputStepImpllinksSelf = Nothing
  , inputStepImpllinksClass = Nothing
  }

-- ** Label1
-- | Label1
data Label1 = Label1
  { label1Class :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Label1
instance A.FromJSON Label1 where
  parseJSON = A.withObject "Label1" $ \o ->
    Label1
      <$> (o .:? "_class")

-- | ToJSON Label1
instance A.ToJSON Label1 where
  toJSON Label1 {..} =
   _omitNulls
      [ "_class" .= label1Class
      ]


-- | Construct a value of type 'Label1' (by applying it's required fields, if any)
mkLabel1
  :: Label1
mkLabel1 =
  Label1
  { label1Class = Nothing
  }

-- ** Link
-- | Link
data Link = Link
  { linkClass :: !(Maybe Text) -- ^ "_class"
  , linkHref :: !(Maybe Text) -- ^ "href"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Link
instance A.FromJSON Link where
  parseJSON = A.withObject "Link" $ \o ->
    Link
      <$> (o .:? "_class")
      <*> (o .:? "href")

-- | ToJSON Link
instance A.ToJSON Link where
  toJSON Link {..} =
   _omitNulls
      [ "_class" .= linkClass
      , "href" .= linkHref
      ]


-- | Construct a value of type 'Link' (by applying it's required fields, if any)
mkLink
  :: Link
mkLink =
  Link
  { linkClass = Nothing
  , linkHref = Nothing
  }

-- ** ListView
-- | ListView
data ListView = ListView
  { listViewClass :: !(Maybe Text) -- ^ "_class"
  , listViewDescription :: !(Maybe Text) -- ^ "description"
  , listViewJobs :: !(Maybe [FreeStyleProject]) -- ^ "jobs"
  , listViewName :: !(Maybe Text) -- ^ "name"
  , listViewUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListView
instance A.FromJSON ListView where
  parseJSON = A.withObject "ListView" $ \o ->
    ListView
      <$> (o .:? "_class")
      <*> (o .:? "description")
      <*> (o .:? "jobs")
      <*> (o .:? "name")
      <*> (o .:? "url")

-- | ToJSON ListView
instance A.ToJSON ListView where
  toJSON ListView {..} =
   _omitNulls
      [ "_class" .= listViewClass
      , "description" .= listViewDescription
      , "jobs" .= listViewJobs
      , "name" .= listViewName
      , "url" .= listViewUrl
      ]


-- | Construct a value of type 'ListView' (by applying it's required fields, if any)
mkListView
  :: ListView
mkListView =
  ListView
  { listViewClass = Nothing
  , listViewDescription = Nothing
  , listViewJobs = Nothing
  , listViewName = Nothing
  , listViewUrl = Nothing
  }

-- ** MultibranchPipeline
-- | MultibranchPipeline
data MultibranchPipeline = MultibranchPipeline
  { multibranchPipelineDisplayName :: !(Maybe Text) -- ^ "displayName"
  , multibranchPipelineEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , multibranchPipelineLatestRun :: !(Maybe Text) -- ^ "latestRun"
  , multibranchPipelineName :: !(Maybe Text) -- ^ "name"
  , multibranchPipelineOrganization :: !(Maybe Text) -- ^ "organization"
  , multibranchPipelineWeatherScore :: !(Maybe Int) -- ^ "weatherScore"
  , multibranchPipelineBranchNames :: !(Maybe [Text]) -- ^ "branchNames"
  , multibranchPipelineNumberOfFailingBranches :: !(Maybe Int) -- ^ "numberOfFailingBranches"
  , multibranchPipelineNumberOfFailingPullRequests :: !(Maybe Int) -- ^ "numberOfFailingPullRequests"
  , multibranchPipelineNumberOfSuccessfulBranches :: !(Maybe Int) -- ^ "numberOfSuccessfulBranches"
  , multibranchPipelineNumberOfSuccessfulPullRequests :: !(Maybe Int) -- ^ "numberOfSuccessfulPullRequests"
  , multibranchPipelineTotalNumberOfBranches :: !(Maybe Int) -- ^ "totalNumberOfBranches"
  , multibranchPipelineTotalNumberOfPullRequests :: !(Maybe Int) -- ^ "totalNumberOfPullRequests"
  , multibranchPipelineClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MultibranchPipeline
instance A.FromJSON MultibranchPipeline where
  parseJSON = A.withObject "MultibranchPipeline" $ \o ->
    MultibranchPipeline
      <$> (o .:? "displayName")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "latestRun")
      <*> (o .:? "name")
      <*> (o .:? "organization")
      <*> (o .:? "weatherScore")
      <*> (o .:? "branchNames")
      <*> (o .:? "numberOfFailingBranches")
      <*> (o .:? "numberOfFailingPullRequests")
      <*> (o .:? "numberOfSuccessfulBranches")
      <*> (o .:? "numberOfSuccessfulPullRequests")
      <*> (o .:? "totalNumberOfBranches")
      <*> (o .:? "totalNumberOfPullRequests")
      <*> (o .:? "_class")

-- | ToJSON MultibranchPipeline
instance A.ToJSON MultibranchPipeline where
  toJSON MultibranchPipeline {..} =
   _omitNulls
      [ "displayName" .= multibranchPipelineDisplayName
      , "estimatedDurationInMillis" .= multibranchPipelineEstimatedDurationInMillis
      , "latestRun" .= multibranchPipelineLatestRun
      , "name" .= multibranchPipelineName
      , "organization" .= multibranchPipelineOrganization
      , "weatherScore" .= multibranchPipelineWeatherScore
      , "branchNames" .= multibranchPipelineBranchNames
      , "numberOfFailingBranches" .= multibranchPipelineNumberOfFailingBranches
      , "numberOfFailingPullRequests" .= multibranchPipelineNumberOfFailingPullRequests
      , "numberOfSuccessfulBranches" .= multibranchPipelineNumberOfSuccessfulBranches
      , "numberOfSuccessfulPullRequests" .= multibranchPipelineNumberOfSuccessfulPullRequests
      , "totalNumberOfBranches" .= multibranchPipelineTotalNumberOfBranches
      , "totalNumberOfPullRequests" .= multibranchPipelineTotalNumberOfPullRequests
      , "_class" .= multibranchPipelineClass
      ]


-- | Construct a value of type 'MultibranchPipeline' (by applying it's required fields, if any)
mkMultibranchPipeline
  :: MultibranchPipeline
mkMultibranchPipeline =
  MultibranchPipeline
  { multibranchPipelineDisplayName = Nothing
  , multibranchPipelineEstimatedDurationInMillis = Nothing
  , multibranchPipelineLatestRun = Nothing
  , multibranchPipelineName = Nothing
  , multibranchPipelineOrganization = Nothing
  , multibranchPipelineWeatherScore = Nothing
  , multibranchPipelineBranchNames = Nothing
  , multibranchPipelineNumberOfFailingBranches = Nothing
  , multibranchPipelineNumberOfFailingPullRequests = Nothing
  , multibranchPipelineNumberOfSuccessfulBranches = Nothing
  , multibranchPipelineNumberOfSuccessfulPullRequests = Nothing
  , multibranchPipelineTotalNumberOfBranches = Nothing
  , multibranchPipelineTotalNumberOfPullRequests = Nothing
  , multibranchPipelineClass = Nothing
  }

-- ** NullSCM
-- | NullSCM
data NullSCM = NullSCM
  { nullSCMClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullSCM
instance A.FromJSON NullSCM where
  parseJSON = A.withObject "NullSCM" $ \o ->
    NullSCM
      <$> (o .:? "_class")

-- | ToJSON NullSCM
instance A.ToJSON NullSCM where
  toJSON NullSCM {..} =
   _omitNulls
      [ "_class" .= nullSCMClass
      ]


-- | Construct a value of type 'NullSCM' (by applying it's required fields, if any)
mkNullSCM
  :: NullSCM
mkNullSCM =
  NullSCM
  { nullSCMClass = Nothing
  }

-- ** Organisation
-- | Organisation
data Organisation = Organisation
  { organisationClass :: !(Maybe Text) -- ^ "_class"
  , organisationName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Organisation
instance A.FromJSON Organisation where
  parseJSON = A.withObject "Organisation" $ \o ->
    Organisation
      <$> (o .:? "_class")
      <*> (o .:? "name")

-- | ToJSON Organisation
instance A.ToJSON Organisation where
  toJSON Organisation {..} =
   _omitNulls
      [ "_class" .= organisationClass
      , "name" .= organisationName
      ]


-- | Construct a value of type 'Organisation' (by applying it's required fields, if any)
mkOrganisation
  :: Organisation
mkOrganisation =
  Organisation
  { organisationClass = Nothing
  , organisationName = Nothing
  }

-- ** Pipeline
-- | Pipeline
data Pipeline = Pipeline
  { pipelineClass :: !(Maybe Text) -- ^ "_class"
  , pipelineOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineName :: !(Maybe Text) -- ^ "name"
  , pipelineDisplayName :: !(Maybe Text) -- ^ "displayName"
  , pipelineFullName :: !(Maybe Text) -- ^ "fullName"
  , pipelineWeatherScore :: !(Maybe Int) -- ^ "weatherScore"
  , pipelineEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelineLatestRun :: !(Maybe PipelinelatestRun) -- ^ "latestRun"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Pipeline
instance A.FromJSON Pipeline where
  parseJSON = A.withObject "Pipeline" $ \o ->
    Pipeline
      <$> (o .:? "_class")
      <*> (o .:? "organization")
      <*> (o .:? "name")
      <*> (o .:? "displayName")
      <*> (o .:? "fullName")
      <*> (o .:? "weatherScore")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "latestRun")

-- | ToJSON Pipeline
instance A.ToJSON Pipeline where
  toJSON Pipeline {..} =
   _omitNulls
      [ "_class" .= pipelineClass
      , "organization" .= pipelineOrganization
      , "name" .= pipelineName
      , "displayName" .= pipelineDisplayName
      , "fullName" .= pipelineFullName
      , "weatherScore" .= pipelineWeatherScore
      , "estimatedDurationInMillis" .= pipelineEstimatedDurationInMillis
      , "latestRun" .= pipelineLatestRun
      ]


-- | Construct a value of type 'Pipeline' (by applying it's required fields, if any)
mkPipeline
  :: Pipeline
mkPipeline =
  Pipeline
  { pipelineClass = Nothing
  , pipelineOrganization = Nothing
  , pipelineName = Nothing
  , pipelineDisplayName = Nothing
  , pipelineFullName = Nothing
  , pipelineWeatherScore = Nothing
  , pipelineEstimatedDurationInMillis = Nothing
  , pipelineLatestRun = Nothing
  }

-- ** PipelineActivity
-- | PipelineActivity
data PipelineActivity = PipelineActivity
  { pipelineActivityClass :: !(Maybe Text) -- ^ "_class"
  , pipelineActivityArtifacts :: !(Maybe [PipelineActivityartifacts]) -- ^ "artifacts"
  , pipelineActivityDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , pipelineActivityEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelineActivityEnQueueTime :: !(Maybe Text) -- ^ "enQueueTime"
  , pipelineActivityEndTime :: !(Maybe Text) -- ^ "endTime"
  , pipelineActivityId :: !(Maybe Text) -- ^ "id"
  , pipelineActivityOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineActivityPipeline :: !(Maybe Text) -- ^ "pipeline"
  , pipelineActivityResult :: !(Maybe Text) -- ^ "result"
  , pipelineActivityRunSummary :: !(Maybe Text) -- ^ "runSummary"
  , pipelineActivityStartTime :: !(Maybe Text) -- ^ "startTime"
  , pipelineActivityState :: !(Maybe Text) -- ^ "state"
  , pipelineActivityType :: !(Maybe Text) -- ^ "type"
  , pipelineActivityCommitId :: !(Maybe Text) -- ^ "commitId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineActivity
instance A.FromJSON PipelineActivity where
  parseJSON = A.withObject "PipelineActivity" $ \o ->
    PipelineActivity
      <$> (o .:? "_class")
      <*> (o .:? "artifacts")
      <*> (o .:? "durationInMillis")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "enQueueTime")
      <*> (o .:? "endTime")
      <*> (o .:? "id")
      <*> (o .:? "organization")
      <*> (o .:? "pipeline")
      <*> (o .:? "result")
      <*> (o .:? "runSummary")
      <*> (o .:? "startTime")
      <*> (o .:? "state")
      <*> (o .:? "type")
      <*> (o .:? "commitId")

-- | ToJSON PipelineActivity
instance A.ToJSON PipelineActivity where
  toJSON PipelineActivity {..} =
   _omitNulls
      [ "_class" .= pipelineActivityClass
      , "artifacts" .= pipelineActivityArtifacts
      , "durationInMillis" .= pipelineActivityDurationInMillis
      , "estimatedDurationInMillis" .= pipelineActivityEstimatedDurationInMillis
      , "enQueueTime" .= pipelineActivityEnQueueTime
      , "endTime" .= pipelineActivityEndTime
      , "id" .= pipelineActivityId
      , "organization" .= pipelineActivityOrganization
      , "pipeline" .= pipelineActivityPipeline
      , "result" .= pipelineActivityResult
      , "runSummary" .= pipelineActivityRunSummary
      , "startTime" .= pipelineActivityStartTime
      , "state" .= pipelineActivityState
      , "type" .= pipelineActivityType
      , "commitId" .= pipelineActivityCommitId
      ]


-- | Construct a value of type 'PipelineActivity' (by applying it's required fields, if any)
mkPipelineActivity
  :: PipelineActivity
mkPipelineActivity =
  PipelineActivity
  { pipelineActivityClass = Nothing
  , pipelineActivityArtifacts = Nothing
  , pipelineActivityDurationInMillis = Nothing
  , pipelineActivityEstimatedDurationInMillis = Nothing
  , pipelineActivityEnQueueTime = Nothing
  , pipelineActivityEndTime = Nothing
  , pipelineActivityId = Nothing
  , pipelineActivityOrganization = Nothing
  , pipelineActivityPipeline = Nothing
  , pipelineActivityResult = Nothing
  , pipelineActivityRunSummary = Nothing
  , pipelineActivityStartTime = Nothing
  , pipelineActivityState = Nothing
  , pipelineActivityType = Nothing
  , pipelineActivityCommitId = Nothing
  }

-- ** PipelineActivityartifacts
-- | PipelineActivityartifacts
data PipelineActivityartifacts = PipelineActivityartifacts
  { pipelineActivityartifactsName :: !(Maybe Text) -- ^ "name"
  , pipelineActivityartifactsSize :: !(Maybe Int) -- ^ "size"
  , pipelineActivityartifactsUrl :: !(Maybe Text) -- ^ "url"
  , pipelineActivityartifactsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineActivityartifacts
instance A.FromJSON PipelineActivityartifacts where
  parseJSON = A.withObject "PipelineActivityartifacts" $ \o ->
    PipelineActivityartifacts
      <$> (o .:? "name")
      <*> (o .:? "size")
      <*> (o .:? "url")
      <*> (o .:? "_class")

-- | ToJSON PipelineActivityartifacts
instance A.ToJSON PipelineActivityartifacts where
  toJSON PipelineActivityartifacts {..} =
   _omitNulls
      [ "name" .= pipelineActivityartifactsName
      , "size" .= pipelineActivityartifactsSize
      , "url" .= pipelineActivityartifactsUrl
      , "_class" .= pipelineActivityartifactsClass
      ]


-- | Construct a value of type 'PipelineActivityartifacts' (by applying it's required fields, if any)
mkPipelineActivityartifacts
  :: PipelineActivityartifacts
mkPipelineActivityartifacts =
  PipelineActivityartifacts
  { pipelineActivityartifactsName = Nothing
  , pipelineActivityartifactsSize = Nothing
  , pipelineActivityartifactsUrl = Nothing
  , pipelineActivityartifactsClass = Nothing
  }

-- ** PipelineBranchesitem
-- | PipelineBranchesitem
data PipelineBranchesitem = PipelineBranchesitem
  { pipelineBranchesitemDisplayName :: !(Maybe Text) -- ^ "displayName"
  , pipelineBranchesitemEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelineBranchesitemName :: !(Maybe Text) -- ^ "name"
  , pipelineBranchesitemWeatherScore :: !(Maybe Int) -- ^ "weatherScore"
  , pipelineBranchesitemLatestRun :: !(Maybe PipelineBranchesitemlatestRun) -- ^ "latestRun"
  , pipelineBranchesitemOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineBranchesitemPullRequest :: !(Maybe PipelineBranchesitempullRequest) -- ^ "pullRequest"
  , pipelineBranchesitemTotalNumberOfPullRequests :: !(Maybe Int) -- ^ "totalNumberOfPullRequests"
  , pipelineBranchesitemClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineBranchesitem
instance A.FromJSON PipelineBranchesitem where
  parseJSON = A.withObject "PipelineBranchesitem" $ \o ->
    PipelineBranchesitem
      <$> (o .:? "displayName")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "name")
      <*> (o .:? "weatherScore")
      <*> (o .:? "latestRun")
      <*> (o .:? "organization")
      <*> (o .:? "pullRequest")
      <*> (o .:? "totalNumberOfPullRequests")
      <*> (o .:? "_class")

-- | ToJSON PipelineBranchesitem
instance A.ToJSON PipelineBranchesitem where
  toJSON PipelineBranchesitem {..} =
   _omitNulls
      [ "displayName" .= pipelineBranchesitemDisplayName
      , "estimatedDurationInMillis" .= pipelineBranchesitemEstimatedDurationInMillis
      , "name" .= pipelineBranchesitemName
      , "weatherScore" .= pipelineBranchesitemWeatherScore
      , "latestRun" .= pipelineBranchesitemLatestRun
      , "organization" .= pipelineBranchesitemOrganization
      , "pullRequest" .= pipelineBranchesitemPullRequest
      , "totalNumberOfPullRequests" .= pipelineBranchesitemTotalNumberOfPullRequests
      , "_class" .= pipelineBranchesitemClass
      ]


-- | Construct a value of type 'PipelineBranchesitem' (by applying it's required fields, if any)
mkPipelineBranchesitem
  :: PipelineBranchesitem
mkPipelineBranchesitem =
  PipelineBranchesitem
  { pipelineBranchesitemDisplayName = Nothing
  , pipelineBranchesitemEstimatedDurationInMillis = Nothing
  , pipelineBranchesitemName = Nothing
  , pipelineBranchesitemWeatherScore = Nothing
  , pipelineBranchesitemLatestRun = Nothing
  , pipelineBranchesitemOrganization = Nothing
  , pipelineBranchesitemPullRequest = Nothing
  , pipelineBranchesitemTotalNumberOfPullRequests = Nothing
  , pipelineBranchesitemClass = Nothing
  }

-- ** PipelineBranchesitemlatestRun
-- | PipelineBranchesitemlatestRun
data PipelineBranchesitemlatestRun = PipelineBranchesitemlatestRun
  { pipelineBranchesitemlatestRunDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , pipelineBranchesitemlatestRunEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelineBranchesitemlatestRunEnQueueTime :: !(Maybe Text) -- ^ "enQueueTime"
  , pipelineBranchesitemlatestRunEndTime :: !(Maybe Text) -- ^ "endTime"
  , pipelineBranchesitemlatestRunId :: !(Maybe Text) -- ^ "id"
  , pipelineBranchesitemlatestRunOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineBranchesitemlatestRunPipeline :: !(Maybe Text) -- ^ "pipeline"
  , pipelineBranchesitemlatestRunResult :: !(Maybe Text) -- ^ "result"
  , pipelineBranchesitemlatestRunRunSummary :: !(Maybe Text) -- ^ "runSummary"
  , pipelineBranchesitemlatestRunStartTime :: !(Maybe Text) -- ^ "startTime"
  , pipelineBranchesitemlatestRunState :: !(Maybe Text) -- ^ "state"
  , pipelineBranchesitemlatestRunType :: !(Maybe Text) -- ^ "type"
  , pipelineBranchesitemlatestRunCommitId :: !(Maybe Text) -- ^ "commitId"
  , pipelineBranchesitemlatestRunClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineBranchesitemlatestRun
instance A.FromJSON PipelineBranchesitemlatestRun where
  parseJSON = A.withObject "PipelineBranchesitemlatestRun" $ \o ->
    PipelineBranchesitemlatestRun
      <$> (o .:? "durationInMillis")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "enQueueTime")
      <*> (o .:? "endTime")
      <*> (o .:? "id")
      <*> (o .:? "organization")
      <*> (o .:? "pipeline")
      <*> (o .:? "result")
      <*> (o .:? "runSummary")
      <*> (o .:? "startTime")
      <*> (o .:? "state")
      <*> (o .:? "type")
      <*> (o .:? "commitId")
      <*> (o .:? "_class")

-- | ToJSON PipelineBranchesitemlatestRun
instance A.ToJSON PipelineBranchesitemlatestRun where
  toJSON PipelineBranchesitemlatestRun {..} =
   _omitNulls
      [ "durationInMillis" .= pipelineBranchesitemlatestRunDurationInMillis
      , "estimatedDurationInMillis" .= pipelineBranchesitemlatestRunEstimatedDurationInMillis
      , "enQueueTime" .= pipelineBranchesitemlatestRunEnQueueTime
      , "endTime" .= pipelineBranchesitemlatestRunEndTime
      , "id" .= pipelineBranchesitemlatestRunId
      , "organization" .= pipelineBranchesitemlatestRunOrganization
      , "pipeline" .= pipelineBranchesitemlatestRunPipeline
      , "result" .= pipelineBranchesitemlatestRunResult
      , "runSummary" .= pipelineBranchesitemlatestRunRunSummary
      , "startTime" .= pipelineBranchesitemlatestRunStartTime
      , "state" .= pipelineBranchesitemlatestRunState
      , "type" .= pipelineBranchesitemlatestRunType
      , "commitId" .= pipelineBranchesitemlatestRunCommitId
      , "_class" .= pipelineBranchesitemlatestRunClass
      ]


-- | Construct a value of type 'PipelineBranchesitemlatestRun' (by applying it's required fields, if any)
mkPipelineBranchesitemlatestRun
  :: PipelineBranchesitemlatestRun
mkPipelineBranchesitemlatestRun =
  PipelineBranchesitemlatestRun
  { pipelineBranchesitemlatestRunDurationInMillis = Nothing
  , pipelineBranchesitemlatestRunEstimatedDurationInMillis = Nothing
  , pipelineBranchesitemlatestRunEnQueueTime = Nothing
  , pipelineBranchesitemlatestRunEndTime = Nothing
  , pipelineBranchesitemlatestRunId = Nothing
  , pipelineBranchesitemlatestRunOrganization = Nothing
  , pipelineBranchesitemlatestRunPipeline = Nothing
  , pipelineBranchesitemlatestRunResult = Nothing
  , pipelineBranchesitemlatestRunRunSummary = Nothing
  , pipelineBranchesitemlatestRunStartTime = Nothing
  , pipelineBranchesitemlatestRunState = Nothing
  , pipelineBranchesitemlatestRunType = Nothing
  , pipelineBranchesitemlatestRunCommitId = Nothing
  , pipelineBranchesitemlatestRunClass = Nothing
  }

-- ** PipelineBranchesitempullRequest
-- | PipelineBranchesitempullRequest
data PipelineBranchesitempullRequest = PipelineBranchesitempullRequest
  { pipelineBranchesitempullRequestLinks :: !(Maybe PipelineBranchesitempullRequestlinks) -- ^ "_links"
  , pipelineBranchesitempullRequestAuthor :: !(Maybe Text) -- ^ "author"
  , pipelineBranchesitempullRequestId :: !(Maybe Text) -- ^ "id"
  , pipelineBranchesitempullRequestTitle :: !(Maybe Text) -- ^ "title"
  , pipelineBranchesitempullRequestUrl :: !(Maybe Text) -- ^ "url"
  , pipelineBranchesitempullRequestClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineBranchesitempullRequest
instance A.FromJSON PipelineBranchesitempullRequest where
  parseJSON = A.withObject "PipelineBranchesitempullRequest" $ \o ->
    PipelineBranchesitempullRequest
      <$> (o .:? "_links")
      <*> (o .:? "author")
      <*> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "_class")

-- | ToJSON PipelineBranchesitempullRequest
instance A.ToJSON PipelineBranchesitempullRequest where
  toJSON PipelineBranchesitempullRequest {..} =
   _omitNulls
      [ "_links" .= pipelineBranchesitempullRequestLinks
      , "author" .= pipelineBranchesitempullRequestAuthor
      , "id" .= pipelineBranchesitempullRequestId
      , "title" .= pipelineBranchesitempullRequestTitle
      , "url" .= pipelineBranchesitempullRequestUrl
      , "_class" .= pipelineBranchesitempullRequestClass
      ]


-- | Construct a value of type 'PipelineBranchesitempullRequest' (by applying it's required fields, if any)
mkPipelineBranchesitempullRequest
  :: PipelineBranchesitempullRequest
mkPipelineBranchesitempullRequest =
  PipelineBranchesitempullRequest
  { pipelineBranchesitempullRequestLinks = Nothing
  , pipelineBranchesitempullRequestAuthor = Nothing
  , pipelineBranchesitempullRequestId = Nothing
  , pipelineBranchesitempullRequestTitle = Nothing
  , pipelineBranchesitempullRequestUrl = Nothing
  , pipelineBranchesitempullRequestClass = Nothing
  }

-- ** PipelineBranchesitempullRequestlinks
-- | PipelineBranchesitempullRequestlinks
data PipelineBranchesitempullRequestlinks = PipelineBranchesitempullRequestlinks
  { pipelineBranchesitempullRequestlinksSelf :: !(Maybe Text) -- ^ "self"
  , pipelineBranchesitempullRequestlinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineBranchesitempullRequestlinks
instance A.FromJSON PipelineBranchesitempullRequestlinks where
  parseJSON = A.withObject "PipelineBranchesitempullRequestlinks" $ \o ->
    PipelineBranchesitempullRequestlinks
      <$> (o .:? "self")
      <*> (o .:? "_class")

-- | ToJSON PipelineBranchesitempullRequestlinks
instance A.ToJSON PipelineBranchesitempullRequestlinks where
  toJSON PipelineBranchesitempullRequestlinks {..} =
   _omitNulls
      [ "self" .= pipelineBranchesitempullRequestlinksSelf
      , "_class" .= pipelineBranchesitempullRequestlinksClass
      ]


-- | Construct a value of type 'PipelineBranchesitempullRequestlinks' (by applying it's required fields, if any)
mkPipelineBranchesitempullRequestlinks
  :: PipelineBranchesitempullRequestlinks
mkPipelineBranchesitempullRequestlinks =
  PipelineBranchesitempullRequestlinks
  { pipelineBranchesitempullRequestlinksSelf = Nothing
  , pipelineBranchesitempullRequestlinksClass = Nothing
  }

-- ** PipelineFolderImpl
-- | PipelineFolderImpl
data PipelineFolderImpl = PipelineFolderImpl
  { pipelineFolderImplClass :: !(Maybe Text) -- ^ "_class"
  , pipelineFolderImplDisplayName :: !(Maybe Text) -- ^ "displayName"
  , pipelineFolderImplFullName :: !(Maybe Text) -- ^ "fullName"
  , pipelineFolderImplName :: !(Maybe Text) -- ^ "name"
  , pipelineFolderImplOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineFolderImplNumberOfFolders :: !(Maybe Int) -- ^ "numberOfFolders"
  , pipelineFolderImplNumberOfPipelines :: !(Maybe Int) -- ^ "numberOfPipelines"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineFolderImpl
instance A.FromJSON PipelineFolderImpl where
  parseJSON = A.withObject "PipelineFolderImpl" $ \o ->
    PipelineFolderImpl
      <$> (o .:? "_class")
      <*> (o .:? "displayName")
      <*> (o .:? "fullName")
      <*> (o .:? "name")
      <*> (o .:? "organization")
      <*> (o .:? "numberOfFolders")
      <*> (o .:? "numberOfPipelines")

-- | ToJSON PipelineFolderImpl
instance A.ToJSON PipelineFolderImpl where
  toJSON PipelineFolderImpl {..} =
   _omitNulls
      [ "_class" .= pipelineFolderImplClass
      , "displayName" .= pipelineFolderImplDisplayName
      , "fullName" .= pipelineFolderImplFullName
      , "name" .= pipelineFolderImplName
      , "organization" .= pipelineFolderImplOrganization
      , "numberOfFolders" .= pipelineFolderImplNumberOfFolders
      , "numberOfPipelines" .= pipelineFolderImplNumberOfPipelines
      ]


-- | Construct a value of type 'PipelineFolderImpl' (by applying it's required fields, if any)
mkPipelineFolderImpl
  :: PipelineFolderImpl
mkPipelineFolderImpl =
  PipelineFolderImpl
  { pipelineFolderImplClass = Nothing
  , pipelineFolderImplDisplayName = Nothing
  , pipelineFolderImplFullName = Nothing
  , pipelineFolderImplName = Nothing
  , pipelineFolderImplOrganization = Nothing
  , pipelineFolderImplNumberOfFolders = Nothing
  , pipelineFolderImplNumberOfPipelines = Nothing
  }

-- ** PipelineImpl
-- | PipelineImpl
data PipelineImpl = PipelineImpl
  { pipelineImplClass :: !(Maybe Text) -- ^ "_class"
  , pipelineImplDisplayName :: !(Maybe Text) -- ^ "displayName"
  , pipelineImplEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelineImplFullName :: !(Maybe Text) -- ^ "fullName"
  , pipelineImplLatestRun :: !(Maybe Text) -- ^ "latestRun"
  , pipelineImplName :: !(Maybe Text) -- ^ "name"
  , pipelineImplOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineImplWeatherScore :: !(Maybe Int) -- ^ "weatherScore"
  , pipelineImplLinks :: !(Maybe PipelineImpllinks) -- ^ "_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineImpl
instance A.FromJSON PipelineImpl where
  parseJSON = A.withObject "PipelineImpl" $ \o ->
    PipelineImpl
      <$> (o .:? "_class")
      <*> (o .:? "displayName")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "fullName")
      <*> (o .:? "latestRun")
      <*> (o .:? "name")
      <*> (o .:? "organization")
      <*> (o .:? "weatherScore")
      <*> (o .:? "_links")

-- | ToJSON PipelineImpl
instance A.ToJSON PipelineImpl where
  toJSON PipelineImpl {..} =
   _omitNulls
      [ "_class" .= pipelineImplClass
      , "displayName" .= pipelineImplDisplayName
      , "estimatedDurationInMillis" .= pipelineImplEstimatedDurationInMillis
      , "fullName" .= pipelineImplFullName
      , "latestRun" .= pipelineImplLatestRun
      , "name" .= pipelineImplName
      , "organization" .= pipelineImplOrganization
      , "weatherScore" .= pipelineImplWeatherScore
      , "_links" .= pipelineImplLinks
      ]


-- | Construct a value of type 'PipelineImpl' (by applying it's required fields, if any)
mkPipelineImpl
  :: PipelineImpl
mkPipelineImpl =
  PipelineImpl
  { pipelineImplClass = Nothing
  , pipelineImplDisplayName = Nothing
  , pipelineImplEstimatedDurationInMillis = Nothing
  , pipelineImplFullName = Nothing
  , pipelineImplLatestRun = Nothing
  , pipelineImplName = Nothing
  , pipelineImplOrganization = Nothing
  , pipelineImplWeatherScore = Nothing
  , pipelineImplLinks = Nothing
  }

-- ** PipelineImpllinks
-- | PipelineImpllinks
data PipelineImpllinks = PipelineImpllinks
  { pipelineImpllinksRuns :: !(Maybe Link) -- ^ "runs"
  , pipelineImpllinksSelf :: !(Maybe Link) -- ^ "self"
  , pipelineImpllinksQueue :: !(Maybe Link) -- ^ "queue"
  , pipelineImpllinksActions :: !(Maybe Link) -- ^ "actions"
  , pipelineImpllinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineImpllinks
instance A.FromJSON PipelineImpllinks where
  parseJSON = A.withObject "PipelineImpllinks" $ \o ->
    PipelineImpllinks
      <$> (o .:? "runs")
      <*> (o .:? "self")
      <*> (o .:? "queue")
      <*> (o .:? "actions")
      <*> (o .:? "_class")

-- | ToJSON PipelineImpllinks
instance A.ToJSON PipelineImpllinks where
  toJSON PipelineImpllinks {..} =
   _omitNulls
      [ "runs" .= pipelineImpllinksRuns
      , "self" .= pipelineImpllinksSelf
      , "queue" .= pipelineImpllinksQueue
      , "actions" .= pipelineImpllinksActions
      , "_class" .= pipelineImpllinksClass
      ]


-- | Construct a value of type 'PipelineImpllinks' (by applying it's required fields, if any)
mkPipelineImpllinks
  :: PipelineImpllinks
mkPipelineImpllinks =
  PipelineImpllinks
  { pipelineImpllinksRuns = Nothing
  , pipelineImpllinksSelf = Nothing
  , pipelineImpllinksQueue = Nothing
  , pipelineImpllinksActions = Nothing
  , pipelineImpllinksClass = Nothing
  }

-- ** PipelineRun
-- | PipelineRun
data PipelineRun = PipelineRun
  { pipelineRunClass :: !(Maybe Text) -- ^ "_class"
  , pipelineRunArtifacts :: !(Maybe [PipelineRunartifacts]) -- ^ "artifacts"
  , pipelineRunDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , pipelineRunEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelineRunEnQueueTime :: !(Maybe Text) -- ^ "enQueueTime"
  , pipelineRunEndTime :: !(Maybe Text) -- ^ "endTime"
  , pipelineRunId :: !(Maybe Text) -- ^ "id"
  , pipelineRunOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineRunPipeline :: !(Maybe Text) -- ^ "pipeline"
  , pipelineRunResult :: !(Maybe Text) -- ^ "result"
  , pipelineRunRunSummary :: !(Maybe Text) -- ^ "runSummary"
  , pipelineRunStartTime :: !(Maybe Text) -- ^ "startTime"
  , pipelineRunState :: !(Maybe Text) -- ^ "state"
  , pipelineRunType :: !(Maybe Text) -- ^ "type"
  , pipelineRunCommitId :: !(Maybe Text) -- ^ "commitId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineRun
instance A.FromJSON PipelineRun where
  parseJSON = A.withObject "PipelineRun" $ \o ->
    PipelineRun
      <$> (o .:? "_class")
      <*> (o .:? "artifacts")
      <*> (o .:? "durationInMillis")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "enQueueTime")
      <*> (o .:? "endTime")
      <*> (o .:? "id")
      <*> (o .:? "organization")
      <*> (o .:? "pipeline")
      <*> (o .:? "result")
      <*> (o .:? "runSummary")
      <*> (o .:? "startTime")
      <*> (o .:? "state")
      <*> (o .:? "type")
      <*> (o .:? "commitId")

-- | ToJSON PipelineRun
instance A.ToJSON PipelineRun where
  toJSON PipelineRun {..} =
   _omitNulls
      [ "_class" .= pipelineRunClass
      , "artifacts" .= pipelineRunArtifacts
      , "durationInMillis" .= pipelineRunDurationInMillis
      , "estimatedDurationInMillis" .= pipelineRunEstimatedDurationInMillis
      , "enQueueTime" .= pipelineRunEnQueueTime
      , "endTime" .= pipelineRunEndTime
      , "id" .= pipelineRunId
      , "organization" .= pipelineRunOrganization
      , "pipeline" .= pipelineRunPipeline
      , "result" .= pipelineRunResult
      , "runSummary" .= pipelineRunRunSummary
      , "startTime" .= pipelineRunStartTime
      , "state" .= pipelineRunState
      , "type" .= pipelineRunType
      , "commitId" .= pipelineRunCommitId
      ]


-- | Construct a value of type 'PipelineRun' (by applying it's required fields, if any)
mkPipelineRun
  :: PipelineRun
mkPipelineRun =
  PipelineRun
  { pipelineRunClass = Nothing
  , pipelineRunArtifacts = Nothing
  , pipelineRunDurationInMillis = Nothing
  , pipelineRunEstimatedDurationInMillis = Nothing
  , pipelineRunEnQueueTime = Nothing
  , pipelineRunEndTime = Nothing
  , pipelineRunId = Nothing
  , pipelineRunOrganization = Nothing
  , pipelineRunPipeline = Nothing
  , pipelineRunResult = Nothing
  , pipelineRunRunSummary = Nothing
  , pipelineRunStartTime = Nothing
  , pipelineRunState = Nothing
  , pipelineRunType = Nothing
  , pipelineRunCommitId = Nothing
  }

-- ** PipelineRunImpl
-- | PipelineRunImpl
data PipelineRunImpl = PipelineRunImpl
  { pipelineRunImplClass :: !(Maybe Text) -- ^ "_class"
  , pipelineRunImplLinks :: !(Maybe PipelineRunImpllinks) -- ^ "_links"
  , pipelineRunImplDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , pipelineRunImplEnQueueTime :: !(Maybe Text) -- ^ "enQueueTime"
  , pipelineRunImplEndTime :: !(Maybe Text) -- ^ "endTime"
  , pipelineRunImplEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelineRunImplId :: !(Maybe Text) -- ^ "id"
  , pipelineRunImplOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelineRunImplPipeline :: !(Maybe Text) -- ^ "pipeline"
  , pipelineRunImplResult :: !(Maybe Text) -- ^ "result"
  , pipelineRunImplRunSummary :: !(Maybe Text) -- ^ "runSummary"
  , pipelineRunImplStartTime :: !(Maybe Text) -- ^ "startTime"
  , pipelineRunImplState :: !(Maybe Text) -- ^ "state"
  , pipelineRunImplType :: !(Maybe Text) -- ^ "type"
  , pipelineRunImplCommitId :: !(Maybe Text) -- ^ "commitId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineRunImpl
instance A.FromJSON PipelineRunImpl where
  parseJSON = A.withObject "PipelineRunImpl" $ \o ->
    PipelineRunImpl
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "durationInMillis")
      <*> (o .:? "enQueueTime")
      <*> (o .:? "endTime")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "id")
      <*> (o .:? "organization")
      <*> (o .:? "pipeline")
      <*> (o .:? "result")
      <*> (o .:? "runSummary")
      <*> (o .:? "startTime")
      <*> (o .:? "state")
      <*> (o .:? "type")
      <*> (o .:? "commitId")

-- | ToJSON PipelineRunImpl
instance A.ToJSON PipelineRunImpl where
  toJSON PipelineRunImpl {..} =
   _omitNulls
      [ "_class" .= pipelineRunImplClass
      , "_links" .= pipelineRunImplLinks
      , "durationInMillis" .= pipelineRunImplDurationInMillis
      , "enQueueTime" .= pipelineRunImplEnQueueTime
      , "endTime" .= pipelineRunImplEndTime
      , "estimatedDurationInMillis" .= pipelineRunImplEstimatedDurationInMillis
      , "id" .= pipelineRunImplId
      , "organization" .= pipelineRunImplOrganization
      , "pipeline" .= pipelineRunImplPipeline
      , "result" .= pipelineRunImplResult
      , "runSummary" .= pipelineRunImplRunSummary
      , "startTime" .= pipelineRunImplStartTime
      , "state" .= pipelineRunImplState
      , "type" .= pipelineRunImplType
      , "commitId" .= pipelineRunImplCommitId
      ]


-- | Construct a value of type 'PipelineRunImpl' (by applying it's required fields, if any)
mkPipelineRunImpl
  :: PipelineRunImpl
mkPipelineRunImpl =
  PipelineRunImpl
  { pipelineRunImplClass = Nothing
  , pipelineRunImplLinks = Nothing
  , pipelineRunImplDurationInMillis = Nothing
  , pipelineRunImplEnQueueTime = Nothing
  , pipelineRunImplEndTime = Nothing
  , pipelineRunImplEstimatedDurationInMillis = Nothing
  , pipelineRunImplId = Nothing
  , pipelineRunImplOrganization = Nothing
  , pipelineRunImplPipeline = Nothing
  , pipelineRunImplResult = Nothing
  , pipelineRunImplRunSummary = Nothing
  , pipelineRunImplStartTime = Nothing
  , pipelineRunImplState = Nothing
  , pipelineRunImplType = Nothing
  , pipelineRunImplCommitId = Nothing
  }

-- ** PipelineRunImpllinks
-- | PipelineRunImpllinks
data PipelineRunImpllinks = PipelineRunImpllinks
  { pipelineRunImpllinksNodes :: !(Maybe Link) -- ^ "nodes"
  , pipelineRunImpllinksLog :: !(Maybe Link) -- ^ "log"
  , pipelineRunImpllinksSelf :: !(Maybe Link) -- ^ "self"
  , pipelineRunImpllinksActions :: !(Maybe Link) -- ^ "actions"
  , pipelineRunImpllinksSteps :: !(Maybe Link) -- ^ "steps"
  , pipelineRunImpllinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineRunImpllinks
instance A.FromJSON PipelineRunImpllinks where
  parseJSON = A.withObject "PipelineRunImpllinks" $ \o ->
    PipelineRunImpllinks
      <$> (o .:? "nodes")
      <*> (o .:? "log")
      <*> (o .:? "self")
      <*> (o .:? "actions")
      <*> (o .:? "steps")
      <*> (o .:? "_class")

-- | ToJSON PipelineRunImpllinks
instance A.ToJSON PipelineRunImpllinks where
  toJSON PipelineRunImpllinks {..} =
   _omitNulls
      [ "nodes" .= pipelineRunImpllinksNodes
      , "log" .= pipelineRunImpllinksLog
      , "self" .= pipelineRunImpllinksSelf
      , "actions" .= pipelineRunImpllinksActions
      , "steps" .= pipelineRunImpllinksSteps
      , "_class" .= pipelineRunImpllinksClass
      ]


-- | Construct a value of type 'PipelineRunImpllinks' (by applying it's required fields, if any)
mkPipelineRunImpllinks
  :: PipelineRunImpllinks
mkPipelineRunImpllinks =
  PipelineRunImpllinks
  { pipelineRunImpllinksNodes = Nothing
  , pipelineRunImpllinksLog = Nothing
  , pipelineRunImpllinksSelf = Nothing
  , pipelineRunImpllinksActions = Nothing
  , pipelineRunImpllinksSteps = Nothing
  , pipelineRunImpllinksClass = Nothing
  }

-- ** PipelineRunNode
-- | PipelineRunNode
data PipelineRunNode = PipelineRunNode
  { pipelineRunNodeClass :: !(Maybe Text) -- ^ "_class"
  , pipelineRunNodeDisplayName :: !(Maybe Text) -- ^ "displayName"
  , pipelineRunNodeDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , pipelineRunNodeEdges :: !(Maybe [PipelineRunNodeedges]) -- ^ "edges"
  , pipelineRunNodeId :: !(Maybe Text) -- ^ "id"
  , pipelineRunNodeResult :: !(Maybe Text) -- ^ "result"
  , pipelineRunNodeStartTime :: !(Maybe Text) -- ^ "startTime"
  , pipelineRunNodeState :: !(Maybe Text) -- ^ "state"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineRunNode
instance A.FromJSON PipelineRunNode where
  parseJSON = A.withObject "PipelineRunNode" $ \o ->
    PipelineRunNode
      <$> (o .:? "_class")
      <*> (o .:? "displayName")
      <*> (o .:? "durationInMillis")
      <*> (o .:? "edges")
      <*> (o .:? "id")
      <*> (o .:? "result")
      <*> (o .:? "startTime")
      <*> (o .:? "state")

-- | ToJSON PipelineRunNode
instance A.ToJSON PipelineRunNode where
  toJSON PipelineRunNode {..} =
   _omitNulls
      [ "_class" .= pipelineRunNodeClass
      , "displayName" .= pipelineRunNodeDisplayName
      , "durationInMillis" .= pipelineRunNodeDurationInMillis
      , "edges" .= pipelineRunNodeEdges
      , "id" .= pipelineRunNodeId
      , "result" .= pipelineRunNodeResult
      , "startTime" .= pipelineRunNodeStartTime
      , "state" .= pipelineRunNodeState
      ]


-- | Construct a value of type 'PipelineRunNode' (by applying it's required fields, if any)
mkPipelineRunNode
  :: PipelineRunNode
mkPipelineRunNode =
  PipelineRunNode
  { pipelineRunNodeClass = Nothing
  , pipelineRunNodeDisplayName = Nothing
  , pipelineRunNodeDurationInMillis = Nothing
  , pipelineRunNodeEdges = Nothing
  , pipelineRunNodeId = Nothing
  , pipelineRunNodeResult = Nothing
  , pipelineRunNodeStartTime = Nothing
  , pipelineRunNodeState = Nothing
  }

-- ** PipelineRunNodeedges
-- | PipelineRunNodeedges
data PipelineRunNodeedges = PipelineRunNodeedges
  { pipelineRunNodeedgesId :: !(Maybe Text) -- ^ "id"
  , pipelineRunNodeedgesClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineRunNodeedges
instance A.FromJSON PipelineRunNodeedges where
  parseJSON = A.withObject "PipelineRunNodeedges" $ \o ->
    PipelineRunNodeedges
      <$> (o .:? "id")
      <*> (o .:? "_class")

-- | ToJSON PipelineRunNodeedges
instance A.ToJSON PipelineRunNodeedges where
  toJSON PipelineRunNodeedges {..} =
   _omitNulls
      [ "id" .= pipelineRunNodeedgesId
      , "_class" .= pipelineRunNodeedgesClass
      ]


-- | Construct a value of type 'PipelineRunNodeedges' (by applying it's required fields, if any)
mkPipelineRunNodeedges
  :: PipelineRunNodeedges
mkPipelineRunNodeedges =
  PipelineRunNodeedges
  { pipelineRunNodeedgesId = Nothing
  , pipelineRunNodeedgesClass = Nothing
  }

-- ** PipelineRunartifacts
-- | PipelineRunartifacts
data PipelineRunartifacts = PipelineRunartifacts
  { pipelineRunartifactsName :: !(Maybe Text) -- ^ "name"
  , pipelineRunartifactsSize :: !(Maybe Int) -- ^ "size"
  , pipelineRunartifactsUrl :: !(Maybe Text) -- ^ "url"
  , pipelineRunartifactsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineRunartifacts
instance A.FromJSON PipelineRunartifacts where
  parseJSON = A.withObject "PipelineRunartifacts" $ \o ->
    PipelineRunartifacts
      <$> (o .:? "name")
      <*> (o .:? "size")
      <*> (o .:? "url")
      <*> (o .:? "_class")

-- | ToJSON PipelineRunartifacts
instance A.ToJSON PipelineRunartifacts where
  toJSON PipelineRunartifacts {..} =
   _omitNulls
      [ "name" .= pipelineRunartifactsName
      , "size" .= pipelineRunartifactsSize
      , "url" .= pipelineRunartifactsUrl
      , "_class" .= pipelineRunartifactsClass
      ]


-- | Construct a value of type 'PipelineRunartifacts' (by applying it's required fields, if any)
mkPipelineRunartifacts
  :: PipelineRunartifacts
mkPipelineRunartifacts =
  PipelineRunartifacts
  { pipelineRunartifactsName = Nothing
  , pipelineRunartifactsSize = Nothing
  , pipelineRunartifactsUrl = Nothing
  , pipelineRunartifactsClass = Nothing
  }

-- ** PipelineStepImpl
-- | PipelineStepImpl
data PipelineStepImpl = PipelineStepImpl
  { pipelineStepImplClass :: !(Maybe Text) -- ^ "_class"
  , pipelineStepImplLinks :: !(Maybe PipelineStepImpllinks) -- ^ "_links"
  , pipelineStepImplDisplayName :: !(Maybe Text) -- ^ "displayName"
  , pipelineStepImplDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , pipelineStepImplId :: !(Maybe Text) -- ^ "id"
  , pipelineStepImplInput :: !(Maybe InputStepImpl) -- ^ "input"
  , pipelineStepImplResult :: !(Maybe Text) -- ^ "result"
  , pipelineStepImplStartTime :: !(Maybe Text) -- ^ "startTime"
  , pipelineStepImplState :: !(Maybe Text) -- ^ "state"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineStepImpl
instance A.FromJSON PipelineStepImpl where
  parseJSON = A.withObject "PipelineStepImpl" $ \o ->
    PipelineStepImpl
      <$> (o .:? "_class")
      <*> (o .:? "_links")
      <*> (o .:? "displayName")
      <*> (o .:? "durationInMillis")
      <*> (o .:? "id")
      <*> (o .:? "input")
      <*> (o .:? "result")
      <*> (o .:? "startTime")
      <*> (o .:? "state")

-- | ToJSON PipelineStepImpl
instance A.ToJSON PipelineStepImpl where
  toJSON PipelineStepImpl {..} =
   _omitNulls
      [ "_class" .= pipelineStepImplClass
      , "_links" .= pipelineStepImplLinks
      , "displayName" .= pipelineStepImplDisplayName
      , "durationInMillis" .= pipelineStepImplDurationInMillis
      , "id" .= pipelineStepImplId
      , "input" .= pipelineStepImplInput
      , "result" .= pipelineStepImplResult
      , "startTime" .= pipelineStepImplStartTime
      , "state" .= pipelineStepImplState
      ]


-- | Construct a value of type 'PipelineStepImpl' (by applying it's required fields, if any)
mkPipelineStepImpl
  :: PipelineStepImpl
mkPipelineStepImpl =
  PipelineStepImpl
  { pipelineStepImplClass = Nothing
  , pipelineStepImplLinks = Nothing
  , pipelineStepImplDisplayName = Nothing
  , pipelineStepImplDurationInMillis = Nothing
  , pipelineStepImplId = Nothing
  , pipelineStepImplInput = Nothing
  , pipelineStepImplResult = Nothing
  , pipelineStepImplStartTime = Nothing
  , pipelineStepImplState = Nothing
  }

-- ** PipelineStepImpllinks
-- | PipelineStepImpllinks
data PipelineStepImpllinks = PipelineStepImpllinks
  { pipelineStepImpllinksSelf :: !(Maybe Link) -- ^ "self"
  , pipelineStepImpllinksActions :: !(Maybe Link) -- ^ "actions"
  , pipelineStepImpllinksClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelineStepImpllinks
instance A.FromJSON PipelineStepImpllinks where
  parseJSON = A.withObject "PipelineStepImpllinks" $ \o ->
    PipelineStepImpllinks
      <$> (o .:? "self")
      <*> (o .:? "actions")
      <*> (o .:? "_class")

-- | ToJSON PipelineStepImpllinks
instance A.ToJSON PipelineStepImpllinks where
  toJSON PipelineStepImpllinks {..} =
   _omitNulls
      [ "self" .= pipelineStepImpllinksSelf
      , "actions" .= pipelineStepImpllinksActions
      , "_class" .= pipelineStepImpllinksClass
      ]


-- | Construct a value of type 'PipelineStepImpllinks' (by applying it's required fields, if any)
mkPipelineStepImpllinks
  :: PipelineStepImpllinks
mkPipelineStepImpllinks =
  PipelineStepImpllinks
  { pipelineStepImpllinksSelf = Nothing
  , pipelineStepImpllinksActions = Nothing
  , pipelineStepImpllinksClass = Nothing
  }

-- ** PipelinelatestRun
-- | PipelinelatestRun
data PipelinelatestRun = PipelinelatestRun
  { pipelinelatestRunArtifacts :: !(Maybe [PipelinelatestRunartifacts]) -- ^ "artifacts"
  , pipelinelatestRunDurationInMillis :: !(Maybe Int) -- ^ "durationInMillis"
  , pipelinelatestRunEstimatedDurationInMillis :: !(Maybe Int) -- ^ "estimatedDurationInMillis"
  , pipelinelatestRunEnQueueTime :: !(Maybe Text) -- ^ "enQueueTime"
  , pipelinelatestRunEndTime :: !(Maybe Text) -- ^ "endTime"
  , pipelinelatestRunId :: !(Maybe Text) -- ^ "id"
  , pipelinelatestRunOrganization :: !(Maybe Text) -- ^ "organization"
  , pipelinelatestRunPipeline :: !(Maybe Text) -- ^ "pipeline"
  , pipelinelatestRunResult :: !(Maybe Text) -- ^ "result"
  , pipelinelatestRunRunSummary :: !(Maybe Text) -- ^ "runSummary"
  , pipelinelatestRunStartTime :: !(Maybe Text) -- ^ "startTime"
  , pipelinelatestRunState :: !(Maybe Text) -- ^ "state"
  , pipelinelatestRunType :: !(Maybe Text) -- ^ "type"
  , pipelinelatestRunCommitId :: !(Maybe Text) -- ^ "commitId"
  , pipelinelatestRunClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelinelatestRun
instance A.FromJSON PipelinelatestRun where
  parseJSON = A.withObject "PipelinelatestRun" $ \o ->
    PipelinelatestRun
      <$> (o .:? "artifacts")
      <*> (o .:? "durationInMillis")
      <*> (o .:? "estimatedDurationInMillis")
      <*> (o .:? "enQueueTime")
      <*> (o .:? "endTime")
      <*> (o .:? "id")
      <*> (o .:? "organization")
      <*> (o .:? "pipeline")
      <*> (o .:? "result")
      <*> (o .:? "runSummary")
      <*> (o .:? "startTime")
      <*> (o .:? "state")
      <*> (o .:? "type")
      <*> (o .:? "commitId")
      <*> (o .:? "_class")

-- | ToJSON PipelinelatestRun
instance A.ToJSON PipelinelatestRun where
  toJSON PipelinelatestRun {..} =
   _omitNulls
      [ "artifacts" .= pipelinelatestRunArtifacts
      , "durationInMillis" .= pipelinelatestRunDurationInMillis
      , "estimatedDurationInMillis" .= pipelinelatestRunEstimatedDurationInMillis
      , "enQueueTime" .= pipelinelatestRunEnQueueTime
      , "endTime" .= pipelinelatestRunEndTime
      , "id" .= pipelinelatestRunId
      , "organization" .= pipelinelatestRunOrganization
      , "pipeline" .= pipelinelatestRunPipeline
      , "result" .= pipelinelatestRunResult
      , "runSummary" .= pipelinelatestRunRunSummary
      , "startTime" .= pipelinelatestRunStartTime
      , "state" .= pipelinelatestRunState
      , "type" .= pipelinelatestRunType
      , "commitId" .= pipelinelatestRunCommitId
      , "_class" .= pipelinelatestRunClass
      ]


-- | Construct a value of type 'PipelinelatestRun' (by applying it's required fields, if any)
mkPipelinelatestRun
  :: PipelinelatestRun
mkPipelinelatestRun =
  PipelinelatestRun
  { pipelinelatestRunArtifacts = Nothing
  , pipelinelatestRunDurationInMillis = Nothing
  , pipelinelatestRunEstimatedDurationInMillis = Nothing
  , pipelinelatestRunEnQueueTime = Nothing
  , pipelinelatestRunEndTime = Nothing
  , pipelinelatestRunId = Nothing
  , pipelinelatestRunOrganization = Nothing
  , pipelinelatestRunPipeline = Nothing
  , pipelinelatestRunResult = Nothing
  , pipelinelatestRunRunSummary = Nothing
  , pipelinelatestRunStartTime = Nothing
  , pipelinelatestRunState = Nothing
  , pipelinelatestRunType = Nothing
  , pipelinelatestRunCommitId = Nothing
  , pipelinelatestRunClass = Nothing
  }

-- ** PipelinelatestRunartifacts
-- | PipelinelatestRunartifacts
data PipelinelatestRunartifacts = PipelinelatestRunartifacts
  { pipelinelatestRunartifactsName :: !(Maybe Text) -- ^ "name"
  , pipelinelatestRunartifactsSize :: !(Maybe Int) -- ^ "size"
  , pipelinelatestRunartifactsUrl :: !(Maybe Text) -- ^ "url"
  , pipelinelatestRunartifactsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PipelinelatestRunartifacts
instance A.FromJSON PipelinelatestRunartifacts where
  parseJSON = A.withObject "PipelinelatestRunartifacts" $ \o ->
    PipelinelatestRunartifacts
      <$> (o .:? "name")
      <*> (o .:? "size")
      <*> (o .:? "url")
      <*> (o .:? "_class")

-- | ToJSON PipelinelatestRunartifacts
instance A.ToJSON PipelinelatestRunartifacts where
  toJSON PipelinelatestRunartifacts {..} =
   _omitNulls
      [ "name" .= pipelinelatestRunartifactsName
      , "size" .= pipelinelatestRunartifactsSize
      , "url" .= pipelinelatestRunartifactsUrl
      , "_class" .= pipelinelatestRunartifactsClass
      ]


-- | Construct a value of type 'PipelinelatestRunartifacts' (by applying it's required fields, if any)
mkPipelinelatestRunartifacts
  :: PipelinelatestRunartifacts
mkPipelinelatestRunartifacts =
  PipelinelatestRunartifacts
  { pipelinelatestRunartifactsName = Nothing
  , pipelinelatestRunartifactsSize = Nothing
  , pipelinelatestRunartifactsUrl = Nothing
  , pipelinelatestRunartifactsClass = Nothing
  }

-- ** Queue
-- | Queue
data Queue = Queue
  { queueClass :: !(Maybe Text) -- ^ "_class"
  , queueItems :: !(Maybe [QueueBlockedItem]) -- ^ "items"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Queue
instance A.FromJSON Queue where
  parseJSON = A.withObject "Queue" $ \o ->
    Queue
      <$> (o .:? "_class")
      <*> (o .:? "items")

-- | ToJSON Queue
instance A.ToJSON Queue where
  toJSON Queue {..} =
   _omitNulls
      [ "_class" .= queueClass
      , "items" .= queueItems
      ]


-- | Construct a value of type 'Queue' (by applying it's required fields, if any)
mkQueue
  :: Queue
mkQueue =
  Queue
  { queueClass = Nothing
  , queueItems = Nothing
  }

-- ** QueueBlockedItem
-- | QueueBlockedItem
data QueueBlockedItem = QueueBlockedItem
  { queueBlockedItemClass :: !(Maybe Text) -- ^ "_class"
  , queueBlockedItemActions :: !(Maybe [CauseAction]) -- ^ "actions"
  , queueBlockedItemBlocked :: !(Maybe Bool) -- ^ "blocked"
  , queueBlockedItemBuildable :: !(Maybe Bool) -- ^ "buildable"
  , queueBlockedItemId :: !(Maybe Int) -- ^ "id"
  , queueBlockedItemInQueueSince :: !(Maybe Int) -- ^ "inQueueSince"
  , queueBlockedItemParams :: !(Maybe Text) -- ^ "params"
  , queueBlockedItemStuck :: !(Maybe Bool) -- ^ "stuck"
  , queueBlockedItemTask :: !(Maybe FreeStyleProject) -- ^ "task"
  , queueBlockedItemUrl :: !(Maybe Text) -- ^ "url"
  , queueBlockedItemWhy :: !(Maybe Text) -- ^ "why"
  , queueBlockedItemBuildableStartMilliseconds :: !(Maybe Int) -- ^ "buildableStartMilliseconds"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueueBlockedItem
instance A.FromJSON QueueBlockedItem where
  parseJSON = A.withObject "QueueBlockedItem" $ \o ->
    QueueBlockedItem
      <$> (o .:? "_class")
      <*> (o .:? "actions")
      <*> (o .:? "blocked")
      <*> (o .:? "buildable")
      <*> (o .:? "id")
      <*> (o .:? "inQueueSince")
      <*> (o .:? "params")
      <*> (o .:? "stuck")
      <*> (o .:? "task")
      <*> (o .:? "url")
      <*> (o .:? "why")
      <*> (o .:? "buildableStartMilliseconds")

-- | ToJSON QueueBlockedItem
instance A.ToJSON QueueBlockedItem where
  toJSON QueueBlockedItem {..} =
   _omitNulls
      [ "_class" .= queueBlockedItemClass
      , "actions" .= queueBlockedItemActions
      , "blocked" .= queueBlockedItemBlocked
      , "buildable" .= queueBlockedItemBuildable
      , "id" .= queueBlockedItemId
      , "inQueueSince" .= queueBlockedItemInQueueSince
      , "params" .= queueBlockedItemParams
      , "stuck" .= queueBlockedItemStuck
      , "task" .= queueBlockedItemTask
      , "url" .= queueBlockedItemUrl
      , "why" .= queueBlockedItemWhy
      , "buildableStartMilliseconds" .= queueBlockedItemBuildableStartMilliseconds
      ]


-- | Construct a value of type 'QueueBlockedItem' (by applying it's required fields, if any)
mkQueueBlockedItem
  :: QueueBlockedItem
mkQueueBlockedItem =
  QueueBlockedItem
  { queueBlockedItemClass = Nothing
  , queueBlockedItemActions = Nothing
  , queueBlockedItemBlocked = Nothing
  , queueBlockedItemBuildable = Nothing
  , queueBlockedItemId = Nothing
  , queueBlockedItemInQueueSince = Nothing
  , queueBlockedItemParams = Nothing
  , queueBlockedItemStuck = Nothing
  , queueBlockedItemTask = Nothing
  , queueBlockedItemUrl = Nothing
  , queueBlockedItemWhy = Nothing
  , queueBlockedItemBuildableStartMilliseconds = Nothing
  }

-- ** QueueItemImpl
-- | QueueItemImpl
data QueueItemImpl = QueueItemImpl
  { queueItemImplClass :: !(Maybe Text) -- ^ "_class"
  , queueItemImplExpectedBuildNumber :: !(Maybe Int) -- ^ "expectedBuildNumber"
  , queueItemImplId :: !(Maybe Text) -- ^ "id"
  , queueItemImplPipeline :: !(Maybe Text) -- ^ "pipeline"
  , queueItemImplQueuedTime :: !(Maybe Int) -- ^ "queuedTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueueItemImpl
instance A.FromJSON QueueItemImpl where
  parseJSON = A.withObject "QueueItemImpl" $ \o ->
    QueueItemImpl
      <$> (o .:? "_class")
      <*> (o .:? "expectedBuildNumber")
      <*> (o .:? "id")
      <*> (o .:? "pipeline")
      <*> (o .:? "queuedTime")

-- | ToJSON QueueItemImpl
instance A.ToJSON QueueItemImpl where
  toJSON QueueItemImpl {..} =
   _omitNulls
      [ "_class" .= queueItemImplClass
      , "expectedBuildNumber" .= queueItemImplExpectedBuildNumber
      , "id" .= queueItemImplId
      , "pipeline" .= queueItemImplPipeline
      , "queuedTime" .= queueItemImplQueuedTime
      ]


-- | Construct a value of type 'QueueItemImpl' (by applying it's required fields, if any)
mkQueueItemImpl
  :: QueueItemImpl
mkQueueItemImpl =
  QueueItemImpl
  { queueItemImplClass = Nothing
  , queueItemImplExpectedBuildNumber = Nothing
  , queueItemImplId = Nothing
  , queueItemImplPipeline = Nothing
  , queueItemImplQueuedTime = Nothing
  }

-- ** QueueLeftItem
-- | QueueLeftItem
data QueueLeftItem = QueueLeftItem
  { queueLeftItemClass :: !(Maybe Text) -- ^ "_class"
  , queueLeftItemActions :: !(Maybe [CauseAction]) -- ^ "actions"
  , queueLeftItemBlocked :: !(Maybe Bool) -- ^ "blocked"
  , queueLeftItemBuildable :: !(Maybe Bool) -- ^ "buildable"
  , queueLeftItemId :: !(Maybe Int) -- ^ "id"
  , queueLeftItemInQueueSince :: !(Maybe Int) -- ^ "inQueueSince"
  , queueLeftItemParams :: !(Maybe Text) -- ^ "params"
  , queueLeftItemStuck :: !(Maybe Bool) -- ^ "stuck"
  , queueLeftItemTask :: !(Maybe FreeStyleProject) -- ^ "task"
  , queueLeftItemUrl :: !(Maybe Text) -- ^ "url"
  , queueLeftItemWhy :: !(Maybe Text) -- ^ "why"
  , queueLeftItemCancelled :: !(Maybe Bool) -- ^ "cancelled"
  , queueLeftItemExecutable :: !(Maybe FreeStyleBuild) -- ^ "executable"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON QueueLeftItem
instance A.FromJSON QueueLeftItem where
  parseJSON = A.withObject "QueueLeftItem" $ \o ->
    QueueLeftItem
      <$> (o .:? "_class")
      <*> (o .:? "actions")
      <*> (o .:? "blocked")
      <*> (o .:? "buildable")
      <*> (o .:? "id")
      <*> (o .:? "inQueueSince")
      <*> (o .:? "params")
      <*> (o .:? "stuck")
      <*> (o .:? "task")
      <*> (o .:? "url")
      <*> (o .:? "why")
      <*> (o .:? "cancelled")
      <*> (o .:? "executable")

-- | ToJSON QueueLeftItem
instance A.ToJSON QueueLeftItem where
  toJSON QueueLeftItem {..} =
   _omitNulls
      [ "_class" .= queueLeftItemClass
      , "actions" .= queueLeftItemActions
      , "blocked" .= queueLeftItemBlocked
      , "buildable" .= queueLeftItemBuildable
      , "id" .= queueLeftItemId
      , "inQueueSince" .= queueLeftItemInQueueSince
      , "params" .= queueLeftItemParams
      , "stuck" .= queueLeftItemStuck
      , "task" .= queueLeftItemTask
      , "url" .= queueLeftItemUrl
      , "why" .= queueLeftItemWhy
      , "cancelled" .= queueLeftItemCancelled
      , "executable" .= queueLeftItemExecutable
      ]


-- | Construct a value of type 'QueueLeftItem' (by applying it's required fields, if any)
mkQueueLeftItem
  :: QueueLeftItem
mkQueueLeftItem =
  QueueLeftItem
  { queueLeftItemClass = Nothing
  , queueLeftItemActions = Nothing
  , queueLeftItemBlocked = Nothing
  , queueLeftItemBuildable = Nothing
  , queueLeftItemId = Nothing
  , queueLeftItemInQueueSince = Nothing
  , queueLeftItemParams = Nothing
  , queueLeftItemStuck = Nothing
  , queueLeftItemTask = Nothing
  , queueLeftItemUrl = Nothing
  , queueLeftItemWhy = Nothing
  , queueLeftItemCancelled = Nothing
  , queueLeftItemExecutable = Nothing
  }

-- ** ResponseTimeMonitorData
-- | ResponseTimeMonitorData
data ResponseTimeMonitorData = ResponseTimeMonitorData
  { responseTimeMonitorDataClass :: !(Maybe Text) -- ^ "_class"
  , responseTimeMonitorDataTimestamp :: !(Maybe Int) -- ^ "timestamp"
  , responseTimeMonitorDataAverage :: !(Maybe Int) -- ^ "average"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMonitorData
instance A.FromJSON ResponseTimeMonitorData where
  parseJSON = A.withObject "ResponseTimeMonitorData" $ \o ->
    ResponseTimeMonitorData
      <$> (o .:? "_class")
      <*> (o .:? "timestamp")
      <*> (o .:? "average")

-- | ToJSON ResponseTimeMonitorData
instance A.ToJSON ResponseTimeMonitorData where
  toJSON ResponseTimeMonitorData {..} =
   _omitNulls
      [ "_class" .= responseTimeMonitorDataClass
      , "timestamp" .= responseTimeMonitorDataTimestamp
      , "average" .= responseTimeMonitorDataAverage
      ]


-- | Construct a value of type 'ResponseTimeMonitorData' (by applying it's required fields, if any)
mkResponseTimeMonitorData
  :: ResponseTimeMonitorData
mkResponseTimeMonitorData =
  ResponseTimeMonitorData
  { responseTimeMonitorDataClass = Nothing
  , responseTimeMonitorDataTimestamp = Nothing
  , responseTimeMonitorDataAverage = Nothing
  }

-- ** StringParameterDefinition
-- | StringParameterDefinition
data StringParameterDefinition = StringParameterDefinition
  { stringParameterDefinitionClass :: !(Maybe Text) -- ^ "_class"
  , stringParameterDefinitionDefaultParameterValue :: !(Maybe StringParameterValue) -- ^ "defaultParameterValue"
  , stringParameterDefinitionDescription :: !(Maybe Text) -- ^ "description"
  , stringParameterDefinitionName :: !(Maybe Text) -- ^ "name"
  , stringParameterDefinitionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringParameterDefinition
instance A.FromJSON StringParameterDefinition where
  parseJSON = A.withObject "StringParameterDefinition" $ \o ->
    StringParameterDefinition
      <$> (o .:? "_class")
      <*> (o .:? "defaultParameterValue")
      <*> (o .:? "description")
      <*> (o .:? "name")
      <*> (o .:? "type")

-- | ToJSON StringParameterDefinition
instance A.ToJSON StringParameterDefinition where
  toJSON StringParameterDefinition {..} =
   _omitNulls
      [ "_class" .= stringParameterDefinitionClass
      , "defaultParameterValue" .= stringParameterDefinitionDefaultParameterValue
      , "description" .= stringParameterDefinitionDescription
      , "name" .= stringParameterDefinitionName
      , "type" .= stringParameterDefinitionType
      ]


-- | Construct a value of type 'StringParameterDefinition' (by applying it's required fields, if any)
mkStringParameterDefinition
  :: StringParameterDefinition
mkStringParameterDefinition =
  StringParameterDefinition
  { stringParameterDefinitionClass = Nothing
  , stringParameterDefinitionDefaultParameterValue = Nothing
  , stringParameterDefinitionDescription = Nothing
  , stringParameterDefinitionName = Nothing
  , stringParameterDefinitionType = Nothing
  }

-- ** StringParameterValue
-- | StringParameterValue
data StringParameterValue = StringParameterValue
  { stringParameterValueClass :: !(Maybe Text) -- ^ "_class"
  , stringParameterValueName :: !(Maybe Text) -- ^ "name"
  , stringParameterValueValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringParameterValue
instance A.FromJSON StringParameterValue where
  parseJSON = A.withObject "StringParameterValue" $ \o ->
    StringParameterValue
      <$> (o .:? "_class")
      <*> (o .:? "name")
      <*> (o .:? "value")

-- | ToJSON StringParameterValue
instance A.ToJSON StringParameterValue where
  toJSON StringParameterValue {..} =
   _omitNulls
      [ "_class" .= stringParameterValueClass
      , "name" .= stringParameterValueName
      , "value" .= stringParameterValueValue
      ]


-- | Construct a value of type 'StringParameterValue' (by applying it's required fields, if any)
mkStringParameterValue
  :: StringParameterValue
mkStringParameterValue =
  StringParameterValue
  { stringParameterValueClass = Nothing
  , stringParameterValueName = Nothing
  , stringParameterValueValue = Nothing
  }

-- ** SwapSpaceMonitorMemoryUsage2
-- | SwapSpaceMonitorMemoryUsage2
data SwapSpaceMonitorMemoryUsage2 = SwapSpaceMonitorMemoryUsage2
  { swapSpaceMonitorMemoryUsage2Class :: !(Maybe Text) -- ^ "_class"
  , swapSpaceMonitorMemoryUsage2AvailablePhysicalMemory :: !(Maybe Int) -- ^ "availablePhysicalMemory"
  , swapSpaceMonitorMemoryUsage2AvailableSwapSpace :: !(Maybe Int) -- ^ "availableSwapSpace"
  , swapSpaceMonitorMemoryUsage2TotalPhysicalMemory :: !(Maybe Int) -- ^ "totalPhysicalMemory"
  , swapSpaceMonitorMemoryUsage2TotalSwapSpace :: !(Maybe Int) -- ^ "totalSwapSpace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwapSpaceMonitorMemoryUsage2
instance A.FromJSON SwapSpaceMonitorMemoryUsage2 where
  parseJSON = A.withObject "SwapSpaceMonitorMemoryUsage2" $ \o ->
    SwapSpaceMonitorMemoryUsage2
      <$> (o .:? "_class")
      <*> (o .:? "availablePhysicalMemory")
      <*> (o .:? "availableSwapSpace")
      <*> (o .:? "totalPhysicalMemory")
      <*> (o .:? "totalSwapSpace")

-- | ToJSON SwapSpaceMonitorMemoryUsage2
instance A.ToJSON SwapSpaceMonitorMemoryUsage2 where
  toJSON SwapSpaceMonitorMemoryUsage2 {..} =
   _omitNulls
      [ "_class" .= swapSpaceMonitorMemoryUsage2Class
      , "availablePhysicalMemory" .= swapSpaceMonitorMemoryUsage2AvailablePhysicalMemory
      , "availableSwapSpace" .= swapSpaceMonitorMemoryUsage2AvailableSwapSpace
      , "totalPhysicalMemory" .= swapSpaceMonitorMemoryUsage2TotalPhysicalMemory
      , "totalSwapSpace" .= swapSpaceMonitorMemoryUsage2TotalSwapSpace
      ]


-- | Construct a value of type 'SwapSpaceMonitorMemoryUsage2' (by applying it's required fields, if any)
mkSwapSpaceMonitorMemoryUsage2
  :: SwapSpaceMonitorMemoryUsage2
mkSwapSpaceMonitorMemoryUsage2 =
  SwapSpaceMonitorMemoryUsage2
  { swapSpaceMonitorMemoryUsage2Class = Nothing
  , swapSpaceMonitorMemoryUsage2AvailablePhysicalMemory = Nothing
  , swapSpaceMonitorMemoryUsage2AvailableSwapSpace = Nothing
  , swapSpaceMonitorMemoryUsage2TotalPhysicalMemory = Nothing
  , swapSpaceMonitorMemoryUsage2TotalSwapSpace = Nothing
  }

-- ** UnlabeledLoadStatistics
-- | UnlabeledLoadStatistics
data UnlabeledLoadStatistics = UnlabeledLoadStatistics
  { unlabeledLoadStatisticsClass :: !(Maybe Text) -- ^ "_class"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UnlabeledLoadStatistics
instance A.FromJSON UnlabeledLoadStatistics where
  parseJSON = A.withObject "UnlabeledLoadStatistics" $ \o ->
    UnlabeledLoadStatistics
      <$> (o .:? "_class")

-- | ToJSON UnlabeledLoadStatistics
instance A.ToJSON UnlabeledLoadStatistics where
  toJSON UnlabeledLoadStatistics {..} =
   _omitNulls
      [ "_class" .= unlabeledLoadStatisticsClass
      ]


-- | Construct a value of type 'UnlabeledLoadStatistics' (by applying it's required fields, if any)
mkUnlabeledLoadStatistics
  :: UnlabeledLoadStatistics
mkUnlabeledLoadStatistics =
  UnlabeledLoadStatistics
  { unlabeledLoadStatisticsClass = Nothing
  }

-- ** User
-- | User
data User = User
  { userClass :: !(Maybe Text) -- ^ "_class"
  , userId :: !(Maybe Text) -- ^ "id"
  , userFullName :: !(Maybe Text) -- ^ "fullName"
  , userEmail :: !(Maybe Text) -- ^ "email"
  , userName :: !(Maybe Text) -- ^ "name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "_class")
      <*> (o .:? "id")
      <*> (o .:? "fullName")
      <*> (o .:? "email")
      <*> (o .:? "name")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "_class" .= userClass
      , "id" .= userId
      , "fullName" .= userFullName
      , "email" .= userEmail
      , "name" .= userName
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userClass = Nothing
  , userId = Nothing
  , userFullName = Nothing
  , userEmail = Nothing
  , userName = Nothing
  }




-- * Auth Methods

-- ** AuthBasicJenkinsAuth
data AuthBasicJenkinsAuth =
  AuthBasicJenkinsAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicJenkinsAuth where
  applyAuthMethod _ a@(AuthBasicJenkinsAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])

-- ** AuthApiKeyJwtAuth
data AuthApiKeyJwtAuth =
  AuthApiKeyJwtAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyJwtAuth where
  applyAuthMethod _ a@(AuthApiKeyJwtAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


