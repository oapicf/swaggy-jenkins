#
# Swaggy Jenkins
# 
# Jenkins API clients generated from Swagger / Open API specification
# The version of the OpenAPI document: 3.0.2-pre.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_branch_impl
import ../models/model_favorite_impl
import ../models/model_github_organization
import ../models/model_github_scm
import ../models/model_multibranch_pipeline
import ../models/model_organisation
import ../models/model_pipeline
import ../models/model_pipeline_activity
import ../models/model_pipeline_folder_impl
import ../models/model_pipeline_impl
import ../models/model_pipeline_run
import ../models/model_pipeline_run_node
import ../models/model_pipeline_step_impl
import ../models/model_queue_item_impl
import ../models/model_user

const basepath = "http://localhost"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc deletePipelineQueueItem*(httpClient: HttpClient, organization: string, pipeline: string, queue: string): Response =
  ## 
  httpClient.delete(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}")


proc getAuthenticatedUser*(httpClient: HttpClient, organization: string): (Option[User], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/user/")
  constructResult[User](response)


proc getClasses*(httpClient: HttpClient, class: string): (Option[string], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/classes/{class}")
  constructResult[string](response)


proc getJsonWebKey*(httpClient: HttpClient, key: int): (Option[string], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/jwt-auth/jwks/{key}")
  constructResult[string](response)


proc getJsonWebToken*(httpClient: HttpClient, expiryTimeInMins: int, maxExpiryTimeInMins: int): (Option[string], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("expiryTimeInMins", $expiryTimeInMins), # Token expiry time in minutes, default: 30 minutes
    ("maxExpiryTimeInMins", $maxExpiryTimeInMins), # Maximum token expiry time in minutes, default: 480 minutes
  ])

  let response = httpClient.get(basepath & "/jwt-auth/token" & "?" & query_for_api_call)
  constructResult[string](response)


proc getOrganisation*(httpClient: HttpClient, organization: string): (Option[Organisation], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}")
  constructResult[Organisation](response)


proc getOrganisations*(httpClient: HttpClient): (Option[seq[Organisation]], Response) =
  ## 

  let response = httpClient.get(basepath & "/blue/rest/organizations/")
  constructResult[seq[Organisation]](response)


proc getPipeline*(httpClient: HttpClient, organization: string, pipeline: string): (Option[Pipeline], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}")
  constructResult[Pipeline](response)


proc getPipelineActivities*(httpClient: HttpClient, organization: string, pipeline: string): (Option[seq[PipelineActivity]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities")
  constructResult[seq[PipelineActivity]](response)


proc getPipelineBranch*(httpClient: HttpClient, organization: string, pipeline: string, branch: string): (Option[BranchImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/")
  constructResult[BranchImpl](response)


proc getPipelineBranchRun*(httpClient: HttpClient, organization: string, pipeline: string, branch: string, run: string): (Option[PipelineRun], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}")
  constructResult[PipelineRun](response)


proc getPipelineBranches*(httpClient: HttpClient, organization: string, pipeline: string): (Option[MultibranchPipeline], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches")
  constructResult[MultibranchPipeline](response)


proc getPipelineFolder*(httpClient: HttpClient, organization: string, folder: string): (Option[PipelineFolderImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{folder}/")
  constructResult[PipelineFolderImpl](response)


proc getPipelineFolderPipeline*(httpClient: HttpClient, organization: string, pipeline: string, folder: string): (Option[PipelineImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}")
  constructResult[PipelineImpl](response)


proc getPipelineQueue*(httpClient: HttpClient, organization: string, pipeline: string): (Option[seq[QueueItemImpl]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue")
  constructResult[seq[QueueItemImpl]](response)


proc getPipelineRun*(httpClient: HttpClient, organization: string, pipeline: string, run: string): (Option[PipelineRun], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}")
  constructResult[PipelineRun](response)


proc getPipelineRunLog*(httpClient: HttpClient, organization: string, pipeline: string, run: string, start: int, download: bool): (Option[string], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("start", $start), # Start position of the log
    ("download", $download), # Set to true in order to download the file, otherwise it's passed as a response body
  ])

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log" & "?" & query_for_api_call)
  constructResult[string](response)


proc getPipelineRunNode*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string): (Option[PipelineRunNode], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}")
  constructResult[PipelineRunNode](response)


proc getPipelineRunNodeStep*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string, step: string): (Option[PipelineStepImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}")
  constructResult[PipelineStepImpl](response)


proc getPipelineRunNodeStepLog*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string, step: string): (Option[string], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log")
  constructResult[string](response)


proc getPipelineRunNodeSteps*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string): (Option[seq[PipelineStepImpl]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps")
  constructResult[seq[PipelineStepImpl]](response)


proc getPipelineRunNodes*(httpClient: HttpClient, organization: string, pipeline: string, run: string): (Option[seq[PipelineRunNode]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes")
  constructResult[seq[PipelineRunNode]](response)


proc getPipelineRuns*(httpClient: HttpClient, organization: string, pipeline: string): (Option[seq[PipelineRun]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs")
  constructResult[seq[PipelineRun]](response)


proc getPipelines*(httpClient: HttpClient, organization: string): (Option[seq[Pipeline]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/")
  constructResult[seq[Pipeline]](response)


proc getSCM*(httpClient: HttpClient, organization: string, scm: string): (Option[GithubScm], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}")
  constructResult[GithubScm](response)


proc getSCMOrganisationRepositories*(httpClient: HttpClient, organization: string, scm: string, scmOrganisation: string, credentialId: string, pageSize: int, pageNumber: int): (Option[seq[GithubOrganization]], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("credentialId", $credentialId), # Credential ID
    ("pageSize", $pageSize), # Number of items in a page
    ("pageNumber", $pageNumber), # Page number
  ])

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories" & "?" & query_for_api_call)
  constructResult[seq[GithubOrganization]](response)


proc getSCMOrganisationRepository*(httpClient: HttpClient, organization: string, scm: string, scmOrganisation: string, repository: string, credentialId: string): (Option[seq[GithubOrganization]], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("credentialId", $credentialId), # Credential ID
  ])

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}" & "?" & query_for_api_call)
  constructResult[seq[GithubOrganization]](response)


proc getSCMOrganisations*(httpClient: HttpClient, organization: string, scm: string, credentialId: string): (Option[seq[GithubOrganization]], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("credentialId", $credentialId), # Credential ID
  ])

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}/organizations" & "?" & query_for_api_call)
  constructResult[seq[GithubOrganization]](response)


proc getUser*(httpClient: HttpClient, organization: string, user: string): (Option[User], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/users/{user}")
  constructResult[User](response)


proc getUserFavorites*(httpClient: HttpClient, user: string): (Option[seq[FavoriteImpl]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/users/{user}/favorites")
  constructResult[seq[FavoriteImpl]](response)


proc getUsers*(httpClient: HttpClient, organization: string): (Option[User], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/users/")
  constructResult[User](response)


proc postPipelineRun*(httpClient: HttpClient, organization: string, pipeline: string, run: string): (Option[QueueItemImpl], Response) =
  ## 

  let response = httpClient.post(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay")
  constructResult[QueueItemImpl](response)


proc postPipelineRuns*(httpClient: HttpClient, organization: string, pipeline: string): (Option[QueueItemImpl], Response) =
  ## 

  let response = httpClient.post(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs")
  constructResult[QueueItemImpl](response)


proc putPipelineFavorite*(httpClient: HttpClient, organization: string, pipeline: string, body: bool): (Option[FavoriteImpl], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite", $(%body))
  constructResult[FavoriteImpl](response)


proc putPipelineRun*(httpClient: HttpClient, organization: string, pipeline: string, run: string, blocking: string, timeOutInSecs: int): (Option[PipelineRun], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("blocking", $blocking), # Set to true to make blocking stop, default: false
    ("timeOutInSecs", $timeOutInSecs), # Timeout in seconds, default: 10 seconds
  ])

  let response = httpClient.put(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop" & "?" & query_for_api_call)
  constructResult[PipelineRun](response)


proc search*(httpClient: HttpClient, q: string): (Option[string], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("q", $q), # Query string
  ])

  let response = httpClient.get(basepath & "/blue/rest/search/" & "?" & query_for_api_call)
  constructResult[string](response)


proc searchClasses*(httpClient: HttpClient, q: string): (Option[string], Response) =
  ## 
  let query_for_api_call = encodeQuery([
    ("q", $q), # Query string containing an array of class names
  ])

  let response = httpClient.get(basepath & "/blue/rest/classes/" & "?" & query_for_api_call)
  constructResult[string](response)

