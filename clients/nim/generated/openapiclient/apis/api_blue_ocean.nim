#
# Swaggy Jenkins
# 
# Jenkins API clients generated from Swagger / Open API specification
# The version of the OpenAPI document: 3.2.1-pre.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_branch_impl
import ../models/model_favorite_impl
import ../models/model_github_organization
import ../models/model_github_scm
import ../models/model_multibranch_pipeline
import ../models/model_organisation
import ../models/model_pipeline
import ../models/model_pipeline_activity
import ../models/model_pipeline_folder_impl
import ../models/model_pipeline_impl
import ../models/model_pipeline_run
import ../models/model_pipeline_run_node
import ../models/model_pipeline_step_impl
import ../models/model_queue_item_impl
import ../models/model_user

const basepath = "http://localhost"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc deletePipelineQueueItem*(httpClient: HttpClient, organization: string, pipeline: string, queue: string): Response =
  ## 
  httpClient.delete(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}")



proc getAuthenticatedUser*(httpClient: HttpClient, organization: string): (Option[User], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/user/")
  constructResult[User](response)


proc getClasses*(httpClient: HttpClient, class: string): (Option[string], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/classes/{class}")
  constructResult[string](response)


proc getJsonWebKey*(httpClient: HttpClient, key: int): (Option[string], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/jwt-auth/jwks/{key}")
  constructResult[string](response)


proc getJsonWebToken*(httpClient: HttpClient, expiryTimeInMins: int, maxExpiryTimeInMins: int): (Option[string], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $expiryTimeInMins != "":
    query_params_list.add(("expiryTimeInMins", $expiryTimeInMins))
  if $maxExpiryTimeInMins != "":
    query_params_list.add(("maxExpiryTimeInMins", $maxExpiryTimeInMins))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/jwt-auth/token" & "?" & url_encoded_query_params)
  constructResult[string](response)


proc getOrganisation*(httpClient: HttpClient, organization: string): (Option[Organisation], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}")
  constructResult[Organisation](response)


proc getOrganisations*(httpClient: HttpClient): (Option[seq[Organisation]], Response) =
  ## 

  let response = httpClient.get(basepath & "/blue/rest/organizations/")
  constructResult[seq[Organisation]](response)


proc getPipeline*(httpClient: HttpClient, organization: string, pipeline: string): (Option[Pipeline], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}")
  constructResult[Pipeline](response)


proc getPipelineActivities*(httpClient: HttpClient, organization: string, pipeline: string): (Option[seq[PipelineActivity]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities")
  constructResult[seq[PipelineActivity]](response)


proc getPipelineBranch*(httpClient: HttpClient, organization: string, pipeline: string, branch: string): (Option[BranchImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/")
  constructResult[BranchImpl](response)


proc getPipelineBranchRun*(httpClient: HttpClient, organization: string, pipeline: string, branch: string, run: string): (Option[PipelineRun], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}")
  constructResult[PipelineRun](response)


proc getPipelineBranches*(httpClient: HttpClient, organization: string, pipeline: string): (Option[MultibranchPipeline], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches")
  constructResult[MultibranchPipeline](response)


proc getPipelineFolder*(httpClient: HttpClient, organization: string, folder: string): (Option[PipelineFolderImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{folder}/")
  constructResult[PipelineFolderImpl](response)


proc getPipelineFolderPipeline*(httpClient: HttpClient, organization: string, pipeline: string, folder: string): (Option[PipelineImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}")
  constructResult[PipelineImpl](response)


proc getPipelineQueue*(httpClient: HttpClient, organization: string, pipeline: string): (Option[seq[QueueItemImpl]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue")
  constructResult[seq[QueueItemImpl]](response)


proc getPipelineRun*(httpClient: HttpClient, organization: string, pipeline: string, run: string): (Option[PipelineRun], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}")
  constructResult[PipelineRun](response)


proc getPipelineRunLog*(httpClient: HttpClient, organization: string, pipeline: string, run: string, start: int, download: bool): (Option[string], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $start != "":
    query_params_list.add(("start", $start))
  if $download != "":
    query_params_list.add(("download", $download))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log" & "?" & url_encoded_query_params)
  constructResult[string](response)


proc getPipelineRunNode*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string): (Option[PipelineRunNode], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}")
  constructResult[PipelineRunNode](response)


proc getPipelineRunNodeStep*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string, step: string): (Option[PipelineStepImpl], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}")
  constructResult[PipelineStepImpl](response)


proc getPipelineRunNodeStepLog*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string, step: string): (Option[string], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log")
  constructResult[string](response)


proc getPipelineRunNodeSteps*(httpClient: HttpClient, organization: string, pipeline: string, run: string, node: string): (Option[seq[PipelineStepImpl]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps")
  constructResult[seq[PipelineStepImpl]](response)


proc getPipelineRunNodes*(httpClient: HttpClient, organization: string, pipeline: string, run: string): (Option[seq[PipelineRunNode]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes")
  constructResult[seq[PipelineRunNode]](response)


proc getPipelineRuns*(httpClient: HttpClient, organization: string, pipeline: string): (Option[seq[PipelineRun]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs")
  constructResult[seq[PipelineRun]](response)


proc getPipelines*(httpClient: HttpClient, organization: string): (Option[seq[Pipeline]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/")
  constructResult[seq[Pipeline]](response)


proc getSCM*(httpClient: HttpClient, organization: string, scm: string): (Option[GithubScm], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}")
  constructResult[GithubScm](response)


proc getSCMOrganisationRepositories*(httpClient: HttpClient, organization: string, scm: string, scmOrganisation: string, credentialId: string, pageSize: int, pageNumber: int): (Option[seq[GithubOrganization]], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $credentialId != "":
    query_params_list.add(("credentialId", $credentialId))
  if $pageSize != "":
    query_params_list.add(("pageSize", $pageSize))
  if $pageNumber != "":
    query_params_list.add(("pageNumber", $pageNumber))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories" & "?" & url_encoded_query_params)
  constructResult[seq[GithubOrganization]](response)


proc getSCMOrganisationRepository*(httpClient: HttpClient, organization: string, scm: string, scmOrganisation: string, repository: string, credentialId: string): (Option[seq[GithubOrganization]], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $credentialId != "":
    query_params_list.add(("credentialId", $credentialId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}" & "?" & url_encoded_query_params)
  constructResult[seq[GithubOrganization]](response)


proc getSCMOrganisations*(httpClient: HttpClient, organization: string, scm: string, credentialId: string): (Option[seq[GithubOrganization]], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $credentialId != "":
    query_params_list.add(("credentialId", $credentialId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/scm/{scm}/organizations" & "?" & url_encoded_query_params)
  constructResult[seq[GithubOrganization]](response)


proc getUser*(httpClient: HttpClient, organization: string, user: string): (Option[User], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/users/{user}")
  constructResult[User](response)


proc getUserFavorites*(httpClient: HttpClient, user: string): (Option[seq[FavoriteImpl]], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/users/{user}/favorites")
  constructResult[seq[FavoriteImpl]](response)


proc getUsers*(httpClient: HttpClient, organization: string): (Option[User], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/blue/rest/organizations/{organization}/users/")
  constructResult[User](response)


proc postPipelineRun*(httpClient: HttpClient, organization: string, pipeline: string, run: string): (Option[QueueItemImpl], Response) =
  ## 

  let response = httpClient.post(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay")
  constructResult[QueueItemImpl](response)


proc postPipelineRuns*(httpClient: HttpClient, organization: string, pipeline: string): (Option[QueueItemImpl], Response) =
  ## 

  let response = httpClient.post(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs")
  constructResult[QueueItemImpl](response)


proc putPipelineFavorite*(httpClient: HttpClient, organization: string, pipeline: string, body: bool): (Option[FavoriteImpl], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.put(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite", $(%body))
  constructResult[FavoriteImpl](response)


proc putPipelineRun*(httpClient: HttpClient, organization: string, pipeline: string, run: string, blocking: string, timeOutInSecs: int): (Option[PipelineRun], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $blocking != "":
    query_params_list.add(("blocking", $blocking))
  if $timeOutInSecs != "":
    query_params_list.add(("timeOutInSecs", $timeOutInSecs))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.put(basepath & fmt"/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop" & "?" & url_encoded_query_params)
  constructResult[PipelineRun](response)


proc search*(httpClient: HttpClient, q: string): (Option[string], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/blue/rest/search/" & "?" & url_encoded_query_params)
  constructResult[string](response)


proc searchClasses*(httpClient: HttpClient, q: string): (Option[string], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/blue/rest/classes/" & "?" & url_encoded_query_params)
  constructResult[string](response)

