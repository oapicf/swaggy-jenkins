#
# Swaggy Jenkins
# 
# Jenkins API clients generated from Swagger / Open API specification
# The version of the OpenAPI document: 3.2.1-pre.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import json
import tables
import marshal
import options

import model_cause_action
import model_free_style_build
import model_free_style_project

type QueueLeftItem* = object
  ## 
  class*: Option[string]
  actions*: Option[seq[CauseAction]]
  blocked*: Option[bool]
  buildable*: Option[bool]
  id*: Option[int]
  inQueueSince*: Option[int]
  params*: Option[string]
  stuck*: Option[bool]
  task*: Option[FreeStyleProject]
  url*: Option[string]
  why*: Option[string]
  cancelled*: Option[bool]
  executable*: Option[FreeStyleBuild]


# Custom JSON deserialization for QueueLeftItem with custom field names
proc to*(node: JsonNode, T: typedesc[QueueLeftItem]): QueueLeftItem =
  result = QueueLeftItem()
  if node.kind == JObject:
    if node.hasKey("_class") and node["_class"].kind != JNull:
      result.class = some(to(node["_class"], typeof(result.class.get())))
    if node.hasKey("actions") and node["actions"].kind != JNull:
      # Optional array of types with custom JSON - manually iterate and deserialize
      let arrayNode = node["actions"]
      if arrayNode.kind == JArray:
        var arr: seq[CauseAction] = @[]
        for item in arrayNode.items:
          arr.add(to(item, CauseAction))
        result.actions = some(arr)
    if node.hasKey("blocked") and node["blocked"].kind != JNull:
      result.blocked = some(to(node["blocked"], typeof(result.blocked.get())))
    if node.hasKey("buildable") and node["buildable"].kind != JNull:
      result.buildable = some(to(node["buildable"], typeof(result.buildable.get())))
    if node.hasKey("id") and node["id"].kind != JNull:
      result.id = some(to(node["id"], typeof(result.id.get())))
    if node.hasKey("inQueueSince") and node["inQueueSince"].kind != JNull:
      result.inQueueSince = some(to(node["inQueueSince"], typeof(result.inQueueSince.get())))
    if node.hasKey("params") and node["params"].kind != JNull:
      result.params = some(to(node["params"], typeof(result.params.get())))
    if node.hasKey("stuck") and node["stuck"].kind != JNull:
      result.stuck = some(to(node["stuck"], typeof(result.stuck.get())))
    if node.hasKey("task") and node["task"].kind != JNull:
      result.task = some(to(node["task"], typeof(result.task.get())))
    if node.hasKey("url") and node["url"].kind != JNull:
      result.url = some(to(node["url"], typeof(result.url.get())))
    if node.hasKey("why") and node["why"].kind != JNull:
      result.why = some(to(node["why"], typeof(result.why.get())))
    if node.hasKey("cancelled") and node["cancelled"].kind != JNull:
      result.cancelled = some(to(node["cancelled"], typeof(result.cancelled.get())))
    if node.hasKey("executable") and node["executable"].kind != JNull:
      result.executable = some(to(node["executable"], typeof(result.executable.get())))

# Custom JSON serialization for QueueLeftItem with custom field names
proc `%`*(obj: QueueLeftItem): JsonNode =
  result = newJObject()
  if obj.class.isSome():
    result["_class"] = %obj.class.get()
  if obj.actions.isSome():
    result["actions"] = %obj.actions.get()
  if obj.blocked.isSome():
    result["blocked"] = %obj.blocked.get()
  if obj.buildable.isSome():
    result["buildable"] = %obj.buildable.get()
  if obj.id.isSome():
    result["id"] = %obj.id.get()
  if obj.inQueueSince.isSome():
    result["inQueueSince"] = %obj.inQueueSince.get()
  if obj.params.isSome():
    result["params"] = %obj.params.get()
  if obj.stuck.isSome():
    result["stuck"] = %obj.stuck.get()
  if obj.task.isSome():
    result["task"] = %obj.task.get()
  if obj.url.isSome():
    result["url"] = %obj.url.get()
  if obj.why.isSome():
    result["why"] = %obj.why.get()
  if obj.cancelled.isSome():
    result["cancelled"] = %obj.cancelled.get()
  if obj.executable.isSome():
    result["executable"] = %obj.executable.get()

