/* tslint:disable */
/* eslint-disable */
/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * The version of the OpenAPI document: 3.0.2-pre.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ComputerSet,
  FreeStyleBuild,
  FreeStyleProject,
  Hudson,
  ListView,
  Queue,
} from '../models/index';
import {
    ComputerSetFromJSON,
    ComputerSetToJSON,
    FreeStyleBuildFromJSON,
    FreeStyleBuildToJSON,
    FreeStyleProjectFromJSON,
    FreeStyleProjectToJSON,
    HudsonFromJSON,
    HudsonToJSON,
    ListViewFromJSON,
    ListViewToJSON,
    QueueFromJSON,
    QueueToJSON,
} from '../models/index';

export interface GetComputerRequest {
    depth: number;
}

export interface GetJobRequest {
    name: string;
}

export interface GetJobConfigRequest {
    name: string;
}

export interface GetJobLastBuildRequest {
    name: string;
}

export interface GetJobProgressiveTextRequest {
    name: string;
    number: string;
    start: string;
}

export interface GetQueueItemRequest {
    number: string;
}

export interface GetViewRequest {
    name: string;
}

export interface GetViewConfigRequest {
    name: string;
}

export interface PostCreateItemRequest {
    name: string;
    from?: string;
    mode?: string;
    jenkinsCrumb?: string;
    contentType?: string;
    body?: string;
}

export interface PostCreateViewRequest {
    name: string;
    jenkinsCrumb?: string;
    contentType?: string;
    body?: string;
}

export interface PostJobBuildRequest {
    name: string;
    json: string;
    token?: string;
    jenkinsCrumb?: string;
}

export interface PostJobConfigRequest {
    name: string;
    body: string;
    jenkinsCrumb?: string;
}

export interface PostJobDeleteRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostJobDisableRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostJobEnableRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostJobLastBuildStopRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostViewConfigRequest {
    name: string;
    body: string;
    jenkinsCrumb?: string;
}

/**
 * 
 */
export class RemoteAccessApi extends runtime.BaseAPI {

    /**
     * Retrieve computer details
     */
    async getComputerRaw(requestParameters: GetComputerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ComputerSet>> {
        if (requestParameters['depth'] == null) {
            throw new runtime.RequiredError(
                'depth',
                'Required parameter "depth" was null or undefined when calling getComputer().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['depth'] != null) {
            queryParameters['depth'] = requestParameters['depth'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/computer/api/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ComputerSetFromJSON(jsonValue));
    }

    /**
     * Retrieve computer details
     */
    async getComputer(requestParameters: GetComputerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ComputerSet> {
        const response = await this.getComputerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Jenkins details
     */
    async getJenkinsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Hudson>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HudsonFromJSON(jsonValue));
    }

    /**
     * Retrieve Jenkins details
     */
    async getJenkins(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Hudson> {
        const response = await this.getJenkinsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job details
     */
    async getJobRaw(requestParameters: GetJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FreeStyleProject>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/api/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FreeStyleProjectFromJSON(jsonValue));
    }

    /**
     * Retrieve job details
     */
    async getJob(requestParameters: GetJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FreeStyleProject> {
        const response = await this.getJobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job configuration
     */
    async getJobConfigRaw(requestParameters: GetJobConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getJobConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Retrieve job configuration
     */
    async getJobConfig(requestParameters: GetJobConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getJobConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job\'s last build details
     */
    async getJobLastBuildRaw(requestParameters: GetJobLastBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FreeStyleBuild>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getJobLastBuild().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/lastBuild/api/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FreeStyleBuildFromJSON(jsonValue));
    }

    /**
     * Retrieve job\'s last build details
     */
    async getJobLastBuild(requestParameters: GetJobLastBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FreeStyleBuild> {
        const response = await this.getJobLastBuildRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job\'s build progressive text output
     */
    async getJobProgressiveTextRaw(requestParameters: GetJobProgressiveTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getJobProgressiveText().'
            );
        }

        if (requestParameters['number'] == null) {
            throw new runtime.RequiredError(
                'number',
                'Required parameter "number" was null or undefined when calling getJobProgressiveText().'
            );
        }

        if (requestParameters['start'] == null) {
            throw new runtime.RequiredError(
                'start',
                'Required parameter "start" was null or undefined when calling getJobProgressiveText().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/{number}/logText/progressiveText`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))).replace(`{${"number"}}`, encodeURIComponent(String(requestParameters['number']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve job\'s build progressive text output
     */
    async getJobProgressiveText(requestParameters: GetJobProgressiveTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getJobProgressiveTextRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve queue details
     */
    async getQueueRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Queue>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/queue/api/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueueFromJSON(jsonValue));
    }

    /**
     * Retrieve queue details
     */
    async getQueue(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Queue> {
        const response = await this.getQueueRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve queued item details
     */
    async getQueueItemRaw(requestParameters: GetQueueItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Queue>> {
        if (requestParameters['number'] == null) {
            throw new runtime.RequiredError(
                'number',
                'Required parameter "number" was null or undefined when calling getQueueItem().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/queue/item/{number}/api/json`.replace(`{${"number"}}`, encodeURIComponent(String(requestParameters['number']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueueFromJSON(jsonValue));
    }

    /**
     * Retrieve queued item details
     */
    async getQueueItem(requestParameters: GetQueueItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Queue> {
        const response = await this.getQueueItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve view details
     */
    async getViewRaw(requestParameters: GetViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListView>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getView().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/view/{name}/api/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListViewFromJSON(jsonValue));
    }

    /**
     * Retrieve view details
     */
    async getView(requestParameters: GetViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListView> {
        const response = await this.getViewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve view configuration
     */
    async getViewConfigRaw(requestParameters: GetViewConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getViewConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/view/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Retrieve view configuration
     */
    async getViewConfig(requestParameters: GetViewConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getViewConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Jenkins headers
     */
    async headJenkinsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/json`,
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve Jenkins headers
     */
    async headJenkins(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.headJenkinsRaw(initOverrides);
    }

    /**
     * Create a new job using job configuration, or copied from an existing job
     */
    async postCreateItemRaw(requestParameters: PostCreateItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postCreateItem().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['from'] != null) {
            queryParameters['from'] = requestParameters['from'];
        }

        if (requestParameters['mode'] != null) {
            queryParameters['mode'] = requestParameters['mode'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (requestParameters['contentType'] != null) {
            headerParameters['Content-Type'] = String(requestParameters['contentType']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/createItem`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new job using job configuration, or copied from an existing job
     */
    async postCreateItem(requestParameters: PostCreateItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postCreateItemRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new view using view configuration
     */
    async postCreateViewRaw(requestParameters: PostCreateViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postCreateView().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (requestParameters['contentType'] != null) {
            headerParameters['Content-Type'] = String(requestParameters['contentType']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/createView`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new view using view configuration
     */
    async postCreateView(requestParameters: PostCreateViewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postCreateViewRaw(requestParameters, initOverrides);
    }

    /**
     * Build a job
     */
    async postJobBuildRaw(requestParameters: PostJobBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postJobBuild().'
            );
        }

        if (requestParameters['json'] == null) {
            throw new runtime.RequiredError(
                'json',
                'Required parameter "json" was null or undefined when calling postJobBuild().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['json'] != null) {
            queryParameters['json'] = requestParameters['json'];
        }

        if (requestParameters['token'] != null) {
            queryParameters['token'] = requestParameters['token'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/build`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Build a job
     */
    async postJobBuild(requestParameters: PostJobBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postJobBuildRaw(requestParameters, initOverrides);
    }

    /**
     * Update job configuration
     */
    async postJobConfigRaw(requestParameters: PostJobConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postJobConfig().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling postJobConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update job configuration
     */
    async postJobConfig(requestParameters: PostJobConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postJobConfigRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a job
     */
    async postJobDeleteRaw(requestParameters: PostJobDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postJobDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/doDelete`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a job
     */
    async postJobDelete(requestParameters: PostJobDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postJobDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Disable a job
     */
    async postJobDisableRaw(requestParameters: PostJobDisableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postJobDisable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/disable`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable a job
     */
    async postJobDisable(requestParameters: PostJobDisableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postJobDisableRaw(requestParameters, initOverrides);
    }

    /**
     * Enable a job
     */
    async postJobEnableRaw(requestParameters: PostJobEnableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postJobEnable().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/enable`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable a job
     */
    async postJobEnable(requestParameters: PostJobEnableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postJobEnableRaw(requestParameters, initOverrides);
    }

    /**
     * Stop a job
     */
    async postJobLastBuildStopRaw(requestParameters: PostJobLastBuildStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postJobLastBuildStop().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/lastBuild/stop`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop a job
     */
    async postJobLastBuildStop(requestParameters: PostJobLastBuildStopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postJobLastBuildStopRaw(requestParameters, initOverrides);
    }

    /**
     * Update view configuration
     */
    async postViewConfigRaw(requestParameters: PostViewConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling postViewConfig().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling postViewConfig().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['jenkinsCrumb'] != null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters['jenkinsCrumb']);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/view/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update view configuration
     */
    async postViewConfig(requestParameters: PostViewConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postViewConfigRaw(requestParameters, initOverrides);
    }

}
